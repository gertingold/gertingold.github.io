<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Ein- und Ausgabe &mdash; Einführung in das Programmieren für Physiker und Materialwissenschaftler</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2016',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Einführung in das Programmieren für Physiker und Materialwissenschaftler" href="index.html" />
    <link rel="next" title="Numerische Programmbibliotheken am Beispiel von NumPy/SciPy" href="scipy.html" />
    <link rel="prev" title="Zusammengesetzte Datentypen" href="sequenzen.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Einführung in das Programmieren</span></a></h1>
        <h2 class="heading"><span>Ein- und Ausgabe</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="sequenzen.html">Zusammengesetzte Datentypen</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index_latex.html">Inhalt</a>
        &#160;&#160;::&#160;&#160;
        <a href="scipy.html">Numerische Programmbibliotheken am Beispiel von NumPy/SciPy</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="ein-und-ausgabe">
<span id="einausgabe"></span><h1>Ein- und Ausgabe<a class="headerlink" href="#ein-und-ausgabe" title="Permalink zu dieser Überschrift">¶</a></h1>
<p>Das Ergebnis der Abarbeitung eines Programms wird in den meisten Fällen die
Ausgabe des Ergebnisses zur Folge haben. In den bisherigen Kapiteln haben wir
die Ausgabe auf dem Bildschirm mit Hilfe der <tt class="docutils literal"><span class="pre">print</span></tt>-Funktion kennengelernt.
Insbesondere bei umfangreicheren Ausgaben wird man das Ergebnis in eine Datei
schreiben wollen, um es zu speichern oder später weiter zu verarbeiten,
beispielsweise mittels eines Grafikprogramms. Häufig ist es auch notwendig, dem
Programm Parameter zu übergeben, entweder beim Programmaufruf über Argumente
auf der Kommandozeile, auf Anfrage des Programms über die Tastatur oder durch
Einlesen aus einer Datei. Im Folgenden werden wir uns zunächst die Eingabe über
die Kommandozeile und die Tastatur ansehen und uns anschließend mit der Ein-
und Ausgabe von Daten mit Hilfe von Dateien beschäftigen.</p>
<div class="section" id="eingabe-uber-die-kommandozeile-und-die-tastatur">
<h2>Eingabe über die Kommandozeile und die Tastatur<a class="headerlink" href="#eingabe-uber-die-kommandozeile-und-die-tastatur" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>Ein Python-Programm, nennen wir es <tt class="docutils literal"><span class="pre">foo.py</span></tt> <a class="footnote-reference" href="#foo" id="id1">[1]</a>, lässt sich von der Kommandozeile
mit Hilfe des Aufrufs</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">python</span> <span class="pre">foo.py</span></tt></div></blockquote>
<p>starten. An diesen Aufruf kann man jedoch auch weitere Argumente anhängen, die
innerhalb des Programms verfügbar sind.  Ein solcher Aufruf könnte
beispielsweise lauten</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">python</span> <span class="pre">foo.py</span> <span class="pre">Hallo</span> <span class="pre">3</span></tt></div></blockquote>
<p>Es könnte sich dabei um den Aufruf eines Programms handeln, das den angegebenen
String so oft ausgibt wie es durch das letzte Argument des Aufrufs vorgegeben
ist.  Der Zugriff auf die Argumente erfolgt dabei über die <tt class="docutils literal"><span class="pre">argv</span></tt>-Variable
des <tt class="docutils literal"><span class="pre">sys</span></tt>-Moduls, wobei <tt class="docutils literal"><span class="pre">argv</span></tt> für »argument vector« steht. Eine
Realisierung des Programms könnte also folgendermaßen aussehen:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</td></tr></table></div>
<p>Dieser Code ergibt die folgende Ausgabe</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="s">&#39;foo.py&#39;</span><span class="p">,</span> <span class="s">&#39;Hallo&#39;</span><span class="p">,</span> <span class="s">&#39;3&#39;</span><span class="p">]</span>
<span class="n">Hallo</span>
<span class="n">Hallo</span>
<span class="n">Hallo</span>
</pre></div>
</div>
<p>Aus der ersten Zeile der Ausgabe wird deutlich, dass die Variable <tt class="docutils literal"><span class="pre">sys.argv</span></tt>
die Kommandozeilenargumente in Form einer Liste enthält. Dabei gibt das erste
Element den Namen des aufgerufenen Programms an. Dies ist unter anderem dann
von Interesse, wenn man das Programm unter verschiedenen Namen aufrufen kann
und dabei ein unterschiedliches Verhalten erreichen möchte. Des Weiteren zeigt
die erste Zeile der Ausgabe, dass alle Argumente in der Liste <tt class="docutils literal"><span class="pre">sys.argv</span></tt> als
Strings auftreten. Daher musste das letzte Argument des Programmaufrufs in
Zeile 4 des Programmcodes erst mit Hilfe der <tt class="xref py py-func docutils literal"><span class="pre">int()</span></tt>-Funktion in einen
Integer umgewandelt werden.</p>
<p>Will man für ein Programm eine flexible oder umfangreiche Übergabe von Optionen
auf der Kommandozeile vorsehen, so lohnt sich ein Blick auf das
<tt class="docutils literal"><span class="pre">argparse</span></tt>-Modul <a class="footnote-reference" href="#argparse" id="id2">[2]</a>. Dieses stellt einige nützliche
Funktionalitäten zur Verfügung, unter anderem auch die automatisierte
Erstellung einer Hilfeausgabe.</p>
<p>Eingaben können auch während des Programmablaufs erfolgen. Dies geschieht mit
Hilfe der <tt class="xref py py-func docutils literal"><span class="pre">input()</span></tt>-Funktion, die in dem folgenden Beispiel illustriert
wird.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">&quot;Aufgabe: &quot;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
        <span class="k">break</span>
</pre></div>
</td></tr></table></div>
<p>Uns kommt es zunächst auf die Zeile 3 an. Die <tt class="xref py py-func docutils literal"><span class="pre">input()</span></tt>-Funktion gibt das
Stringargument aus und gibt die Eingabe als String, hier an die Variable <tt class="docutils literal"><span class="pre">x</span></tt>,
zurück. Diese Funktionalität wird in dem Beispiel verwendet, um vom Benutzer
eingegebene Rechenaufgaben zu lösen. Hierzu wird mit der Zeile 1 eine
Dauerschleife eingeleitet, in der in Zeile 3 versucht wird, eine Aufgabe
einzulesen. In Zeile 4 wird die <tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt>-Funktion verwendet, um den String
als Anweisung zu interpretieren und auszuführen. Tritt dabei ein
<tt class="docutils literal"><span class="pre">SyntaxError</span></tt> auf, so wird die Dauerschleife in den Zeilen 5 und 6 beendet.</p>
<p>Die Eingabe kann aber auch einfach in einem Tupel bestehen, dessen Bestandteile
an mehrere Variablen übergeben werden:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s">&quot;Multiplikanden: &quot;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Produkt = {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<p>Dabei muss die Eingabe das erforderliche Komma enthalten:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Multiplikanden</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span>
<span class="n">Produkt</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">Multiplikanden</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span>
<span class="n">Produkt</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>In diesem Beispiel wird die Schleife beendet, sobald das Produkt gleich Null ist, was
dem Wahrheitswert <tt class="docutils literal"><span class="pre">False</span></tt> entspricht. In einem anderen Beispiel wird eine Liste
eingegeben, die in einer Schleife abgearbeitet wird.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">zahlen</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s">&quot;Geben Sie eine Liste ein: &quot;</span><span class="p">))</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">zahlen</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;{:6}</span><span class="se">\t</span><span class="s">{:10}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>Die Eingabe einer Liste gibt die Listenelemente und die zugehörigen Quadrate aus:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Geben</span> <span class="n">Sie</span> <span class="n">eine</span> <span class="n">Liste</span> <span class="n">ein</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">17</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">247</span><span class="p">]</span>
   <span class="o">-</span><span class="mi">17</span>         <span class="mi">289</span>
     <span class="mi">5</span>          <span class="mi">25</span>
   <span class="mi">247</span>       <span class="mi">61009</span>
</pre></div>
</div>
</div>
<div class="section" id="lesen-und-schreiben-von-dateien">
<h2>Lesen und Schreiben von Dateien<a class="headerlink" href="#lesen-und-schreiben-von-dateien" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>Häufig wird man statt der manuellen Eingabe von Daten und der Ausgabe von
Ergebnissen auf dem Bildschirm das Einlesen aus einer Datei und das Schreiben
in eine Datei vorziehen.  Wir betrachten zunächst den Fall, dass eine Datei
vorliegt, auf deren Inhalt wir in einem Programm zugreifen wollen. Für die
folgenden Beispiele nehmen wir an, dass eine Datei namens <tt class="docutils literal"><span class="pre">foo_utf8.dat</span></tt> mit
dem Inhalt</p>
<div class="highlight-none"><div class="highlight"><pre>Einführung in das
Programmieren für
Physiker und
Materialwissenschaftler
</pre></div>
</div>
<p>existiert. Dabei liege diese Datei in der UTF-8-Kodierung vor. Zur Illustration
sei noch eine Datei <tt class="docutils literal"><span class="pre">foo_latin1.dat</span></tt> vorhanden, die die ISO-8859-1-Kodierung,
auch als Latin-1-Kodierung bekannt, verwendet. Während in der ersten Datei der
Umlaut »ü« hexadezimal durch <tt class="docutils literal"><span class="pre">C3BC</span></tt> kodiert ist, ist er in der zweiten Datei
hexadezimal als <tt class="docutils literal"><span class="pre">FC</span></tt> dargestellt.</p>
<p>Bevor Daten aus dieser Datei gelesen werden können, muss die Datei geöffnet werden.
Dies könnte wie in der ersten Zeile gezeigt geschehen:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;foo_utf8.dat&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span>
<span class="go">&lt;_io.TextIOWrapper name=&#39;foo.dat&#39; encoding=&#39;UTF-8&#39;&gt;</span>
</pre></div>
</td></tr></table></div>
<p>Damit haben wir ein Dateiobjekt erhalten, das den Zugriff auf die Datei mit dem
in der ersten Zeile als Argument angegebenen Namen ermöglicht. Falls nichts
anderes beim Öffnen der Datei angegeben wird, ist die Datei lediglich zum Lesen
geöffnet. Die Datei kann also nicht überschrieben werden, und es kann auch
nichts angefügt werden.</p>
<p>Standardmäßig erwartet wird die auf dem jeweiligen System bevorzugte Kodierung.
In unserem Fall ist dies UTF-8.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">locale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">locale</span><span class="o">.</span><span class="n">getpreferredencoding</span><span class="p">()</span>
<span class="go">&#39;UTF-8&#39;</span>
</pre></div>
</div>
<p>Der Versuch, auf eine nicht existierende Datei lesend zuzugreifen, wird mit
einem <tt class="docutils literal"><span class="pre">IOError</span></tt> beantwortet:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;foo.txt&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">IOError</span>: <span class="n">[Errno 2] No such file or directory: &#39;foo.txt&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">IOError</span>: <span class="n">[Errno 2] No such file or directory: &#39;foo.txt&#39;</span>
</pre></div>
</div>
<p>Nachdem die Datei geöffnet wurde, gibt es verschiedene Möglichkeiten, auf ihren Inhalt
zuzugreifen. Mit der <tt class="xref py py-func docutils literal"><span class="pre">read()</span></tt>-Funktion wird, sofern kein Argument eingegeben wurde,
die gesamte Datei in einen String eingelesen:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">&#39;Einführung in das\nProgrammieren für\nPhysiker und\nMaterialwissenschaftler\n&#39;</span>
</pre></div>
</div>
<p>Die in dem String auftretenden <tt class="docutils literal"><span class="pre">\n</span></tt> geben Zeilenumbrüche an <a class="footnote-reference" href="#unicode" id="id3">[3]</a>. Die
Datei besteht also aus vier Zeilen. Versucht man auf die gleiche Weise, die
Datei <tt class="docutils literal"><span class="pre">foo_latin1.dat</span></tt> einzulesen, erhält man einen <tt class="docutils literal"><span class="pre">UnicodeDecodeError</span></tt>
weil die den Umlauten entsprechenden Bytes in dieser Datei nicht im Rahmen der
UTF-8-Kodierung interpretiert werden können.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;foo_latin1.dat&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;/usr/lib/python3.5/codecs.py&quot;</span>, line <span class="m">321</span>, in <span class="n">decode</span>
    <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">consumed</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_decode</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
<span class="gr">UnicodeDecodeError</span>: <span class="n">&#39;utf8&#39; codec can&#39;t decode byte 0xfc in position 4: invalid start byte</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;/usr/lib/python3.5/codecs.py&quot;</span>, line <span class="m">321</span>, in <span class="n">decode</span>
    <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">consumed</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_decode</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
<span class="gr">UnicodeDecodeError</span>: <span class="n">&#39;utf8&#39; codec can&#39;t decode byte 0xfc in position 4: invalid start byte</span>
</pre></div>
</div>
<p>Dagegen funktioniert das Einlesen problemlos, wenn man die richtige Kodierung
angibt.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;foo_latin1.dat&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">&quot;latin1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">&#39;Einführung in das\nProgrammieren für\nPhysiker und\nMaterialwissenschaftler\n&#39;</span>
</pre></div>
</div>
<p>Nach dem Lesen einer gesamten Datei mit der <tt class="xref py py-func docutils literal"><span class="pre">read()</span></tt>-Funktion steht der
Zeiger, der die aktuelle Position in der Datei angibt, am Dateiende. Ein
weiteres Lesen ergibt daher nur einen leeren String wie Zeile 7 in dem
folgenden Beispiel zeigt.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;foo_utf8.dat&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">&#39;Einführung in das\nProgrammieren für\nPhysiker und\nMaterialwissenschaftler\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
<span class="go">75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">&#39;&#39;</span>
</pre></div>
</td></tr></table></div>
<p>In den Zeilen 4 und 5 haben wir mit Hilfe der <tt class="xref py py-func docutils literal"><span class="pre">tell()</span></tt>-Methode die
aktuelle Position des Dateizeigers abgefragt. Dabei zählen die Zeilenumbrüche
mit. Man muss allerdings beachten, dass das Resultat der <tt class="xref py py-func docutils literal"><span class="pre">tell()</span></tt>-Methode
auf der Bytedarstellung beruht und das UTF8-kodierte <tt class="docutils literal"><span class="pre">ü</span></tt> als zwei Bytes zählt.</p>
<p>Mit Hilfe der <tt class="xref py py-func docutils literal"><span class="pre">seek()</span></tt>-Funktion kann man gezielt an bestimmte Stellen der
Datei springen, wobei allerdings wieder die Bytedarstellung relevant ist. Es
besteht also potentiell die Gefahr, mitten in einem Mehrbyte-Code zu
landen. Daher ist es sinnvoll, <tt class="xref py py-func docutils literal"><span class="pre">seek()</span></tt> auf der Basis von Positionen zu
verwenden, die mit <tt class="xref py py-func docutils literal"><span class="pre">tell()</span></tt> bestimmt wurden.</p>
<p>Eindeutig ist jedoch der Dateianfang, der der Zeigerposition <tt class="docutils literal"><span class="pre">0</span></tt> entspricht.
Nach einem <tt class="docutils literal"><span class="pre">seek(0)</span></tt> liest der zweite Aufruf der <tt class="xref py py-func docutils literal"><span class="pre">read()</span></tt>-Funktion im
folgenden Beispiel nochmals die gesamte Datei ein:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;foo_utf8.dat&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">&#39;Einführung in das\nProgrammieren für\nPhysiker und\nMaterialwissenschaftler\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">&#39;Einführung&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">&#39; in das\nPr&#39;</span>
</pre></div>
</td></tr></table></div>
<p>Man kann sich die Funktionsweise wie bei einem Magnetband vorstellen, bei dem
die Position des Lesekopfes durch die <tt class="xref py py-func docutils literal"><span class="pre">tell()</span></tt>-Funktion angegeben wird,
während die <tt class="xref py py-func docutils literal"><span class="pre">seek()</span></tt>-Funktion den Lesekopf neu positioniert. Im gerade
gezeigten Beispiel wird der Lesekopf an den Anfang, d.h. auf die absolute
Position <tt class="docutils literal"><span class="pre">0</span></tt> zurückgesetzt. Anschließend werden zweimal je zehn Zeichen
eingelesen.</p>
<p>Nicht immer möchte man die ganze Datei auf einmal einlesen, sei es weil die
Datei sehr groß ist oder weil man den Inhalt zum Beispiel zeilenweise
verarbeiten möchte. Hierzu stellt Python verschiedene Möglichkeiten zur
Verfügung. Mit Hilfe der <tt class="xref py py-func docutils literal"><span class="pre">readlines()</span></tt>-Funktion lassen sich die einzelnen
Zeile für die weitere Verarbeitung in eine Liste aufnehmen:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;foo_utf8.dat&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inhalt</span> <span class="o">=</span> <span class="n">datei</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">inhalt</span><span class="p">)</span>
<span class="go">[&#39;Einführung in das\n&#39;, &#39;Programmieren für\n&#39;, &#39;Physiker und\n&#39;,</span>
<span class="go">&#39;Materialwissenschaftler\n&#39;]</span>
</pre></div>
</div>
<p>Bei der Verarbeitung der einzelnen Zeilen ist zu beachten, dass die
Zeichenketten am Ende noch die Zeilenumbruchkennzeichnung <tt class="docutils literal"><span class="pre">\n</span></tt> enthalten.</p>
<p>Zeilen lassen sich auch einzeln einlesen.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;foo_utf8.dat&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;Einführung in das\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;Programmieren für\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;Physiker und\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;Materialwissenschaftler\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;&#39;</span>
</pre></div>
</div>
<p>Nachdem alle Zeilen eingelesen wurden, steht der Dateizeiger am Dateiende, so
dass bei weiteren Aufrufen der <tt class="xref py py-func docutils literal"><span class="pre">readline()</span></tt>-Funktion nur ein leerer String
zurückgegeben wird.</p>
<p>Eine elegante Methode, die Zeilen einer Datei in einer Schleife abzuarbeiten,
zeigt das folgende Beispiel.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;foo_utf8.dat&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">zeile</span> <span class="ow">in</span> <span class="n">datei</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">zeile</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
<span class="gp">...</span>
<span class="go">EINFÜHRUNG IN DAS</span>

<span class="go">PROGRAMMIEREN FÜR</span>

<span class="go">PHYSIKER UND</span>

<span class="go">MATERIALWISSENSCHAFTLER</span>
</pre></div>
</div>
<p>Will man die zusätzlichen Leerzeilen vermeiden, so muss man das <tt class="docutils literal"><span class="pre">\n</span></tt> am Ende
der Zeilen entfernen, entweder unter Verwendung der <tt class="xref py py-func docutils literal"><span class="pre">rstrip()</span></tt>-Methode oder
durch Verwendung eines Slices.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;foo_utf8.dat&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">zeile</span> <span class="ow">in</span> <span class="n">datei</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">zeile</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">EINFÜHRUNG IN DAS</span>
<span class="go">PROGRAMMIEREN FÜR</span>
<span class="go">PHYSIKER UND</span>
<span class="go">MATERIALWISSENSCHAFTLER</span>
</pre></div>
</div>
<p>Die gleiche Ausgabe erhält man mit</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;foo_utf8.dat&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">zeile</span> <span class="ow">in</span> <span class="n">datei</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">zeile</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>In allen bisherigen Beispielen haben wir eine Anweisung unterschlagen, die man
am Ende der Arbeit mit einer Datei immer ausführen lassen sollte. Nachdem man
eine Datei zunächst geöffnet hat, sollte man sie am Ende auch wieder schließen.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;foo_utf8.dat&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inhalt</span> <span class="o">=</span> <span class="n">datei</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">closed</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datei</span><span class="o">.</span><span class="n">closed</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Das Schließen einer Datei gibt die im Zusammenhang mit der geöffneten Datei
benötigten Ressourcen wieder frei und bewahrt einen unter Umständen auch vor
einem teilweisen oder vollständigen Verlust der geschriebenen Daten.</p>
<p>Bevor wir uns mit dem Schreiben von Dateien beschäftigen, müssen wir uns
zunächst noch ansehen, wie man Zahlen aus einer Datei liest, eine bei
numerischen Arbeiten sehr häufige Situation. Als Eingabedatei sei eine Datei
namens <tt class="docutils literal"><span class="pre">spam.dat</span></tt> <a class="footnote-reference" href="#spam" id="id4">[4]</a> mit dem Inhalt</p>
<div class="highlight-python"><div class="highlight"><pre> <span class="mf">1.37</span>  <span class="mf">2.59</span>
<span class="mf">10.3</span>  <span class="o">-</span><span class="mf">1.3</span>
 <span class="mf">5.8</span>   <span class="mf">2.0</span>
</pre></div>
</div>
<p>gegeben. Das folgende Programm berechnet zeilenweise das Produkt des jeweiligen
Zahlenpaares.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">daten</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;spam.dat&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">zeile</span> <span class="ow">in</span> <span class="n">daten</span><span class="p">:</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">zeile</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="n">daten</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>In Zeile 3 wird jede eingelesene Zeile an Leerräumen wie zum Beispiel
Leerstellen oder Tabulatorzeichen, aufgeteilt. Damit ergeben sich je zwei
Strings, die die Information über die jeweilige Zahl enthalten. Allerdings kann
man Strings nicht miteinander multiplizieren. Daher muss in Zeile 4 vor der
Multiplikation mit Hilfe der <tt class="xref py py-func docutils literal"><span class="pre">float()</span></tt>-Funktion eine Umwandlung in
Gleitkommazahlen erfolgen. Das Schließen der Datei erfolgt in Zeile 5 außerhalb
der <tt class="docutils literal"><span class="pre">for</span></tt>-Schleife, da sonst die Datei bereits nach dem Einlesen der ersten
Zeile geschlossen würde.</p>
<p>Als Alternative zu der im vorigen Beispiel gezeigten expliziten Umwandlung kann
es sinnvoll sein, die von Python zur Verfügung gestellte <tt class="xref py py-func docutils literal"><span class="pre">map()</span></tt>-Funktion
zu verwenden. Dies ist insbesondere bei mehreren Zahlen oder wenn deren Anzahl
nicht bekannt ist, nützlich. Das Beispiel lautet dann</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">daten</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;spam.dat&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">zeile</span> <span class="ow">in</span> <span class="n">daten</span><span class="p">:</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">zeile</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
<span class="n">daten</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>Dabei wird in Zeile 3 die <tt class="xref py py-func docutils literal"><span class="pre">float()</span></tt>-Funktion zur Umwandlung aller Elemente
der Liste <tt class="docutils literal"><span class="pre">zeile.split()</span></tt> in Gleitkommazahlen angewandt.</p>
<p>In einem Programm möchte man nicht nur Daten aus einer Datei einlesen, sondern
vor allem auch die Ergebnisse in einer Datei speichern. Wie beim Lesen aus
Dateien muss man beim Schreiben in Dateien zunächst eine Datei öffnen. Dies
kann auf verschiedene Weise geschehen. Betrachten wir zunächst das folgende
Beispiel:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">datei</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;foo.dat&quot;</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">datei</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;{:4}{:4}</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">))</span>
<span class="n">datei</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>Die Anweisung in Zeile 1 kennen wir im Prinzip schon, nur dass jetzt das zweite
Argument explizit auf <tt class="docutils literal"><span class="pre">w</span></tt>, also »write« gesetzt ist. Damit wird die Datei
<tt class="docutils literal"><span class="pre">foo.dat</span></tt> zum Schreiben geöffnet. Ob die Datei schon existiert, ist dabei
unerheblich. Existiert sie nicht, so wird eine neue Datei angelegt. Existiert
die Datei dagegen schon, so wird ihre Länge vor dem Schreiben auf Null gesetzt.
Damit wird die zuvor existierende Datei effektiv überschrieben. In der dritten
Zeile erfolgt das Schreiben in die Datei mit Hilfe der <tt class="xref py py-func docutils literal"><span class="pre">write()</span></tt>-Methode.
Wie bei dem uns bereits bekannten <tt class="docutils literal"><span class="pre">print</span></tt>-Befehl muss als Argument ein String
angegeben werden. Dabei können natürlich die im Abschnitt <a class="reference internal" href="datentypen.html#formatierung"><em>Formatierung von Ausgaben</em></a>
besprochenen Formatspezifikationen verwendet werden. Zu beachten ist, dass im
Gegensatz zur <tt class="docutils literal"><span class="pre">print</span></tt>-Anweisung bei Bedarf ein Zeilenumbruch explizit mit
<tt class="docutils literal"><span class="pre">\n</span></tt> zu verlangen ist.  Die <tt class="xref py py-func docutils literal"><span class="pre">read()</span></tt>- und die <tt class="xref py py-func docutils literal"><span class="pre">write()</span></tt>-Methode sind
also insofern symmetrisch als in beiden Fällen der Zeilenumbruch in den
jeweiligen Zeichenketten explizit auftritt. Nicht vergessen werden sollte das
Schließen der Datei in Zeile 4, da ansonsten die Gefahr bestehen könnte, dass
Daten verloren gehen.</p>
<p>Öffnet man eine existierende Datei im Modus <tt class="docutils literal"><span class="pre">r+</span></tt>, so kann man von ihr lesen
und in sie schreiben.  Ähnliches geschieht bei <tt class="docutils literal"><span class="pre">w+</span></tt>, wobei bei Bedarf jedoch
eine neue Datei angelegt wird.  Gelegentlich möchte man Daten an eine Datei
anhängen. In diesem Falle verwendet man den Modus <tt class="docutils literal"><span class="pre">a</span></tt> für »append« oder
<tt class="docutils literal"><span class="pre">a+</span></tt> falls man aus der Datei auch lesen möchte.</p>
<p><a class="reference internal" href="_images/weiterfuehrend.png"><img alt="weiterfuehrend" src="_images/weiterfuehrend.png" style="height: 1em;" /></a> Ab Python 3.3 gibt es auch noch die Option <tt class="docutils literal"><span class="pre">&quot;x&quot;</span></tt>, die nur
dann eine Datei erfolgreich öffnet, falls diese Datei noch nicht existiert.</p>
<p>Bei numerischen Rechnungen ist es oft sinnvoll, die verwendeten Parameter im
Dateinamen aufzuführen wie es im folgenden Beispiel gezeigt ist. Dazu wird in
der Zeile 2 beim Öffnen der Datei ein geeigneter Konvertierungsspezifikator
verwendet.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre> <span class="n">parameter</span> <span class="o">=</span> <span class="mi">12</span>
 <span class="n">datei</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;resultate_{:05}.dat&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">parameter</span><span class="p">),</span> <span class="s">&quot;w&quot;</span><span class="p">)</span>
 <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">parameter</span><span class="p">):</span>
     <span class="n">datei</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;{:10}</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">))</span>
 <span class="n">datei</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>Entsprechend dem Wert der Variable <tt class="docutils literal"><span class="pre">parameter</span></tt> erfolgt die Ausgabe in die
Datei <tt class="docutils literal"><span class="pre">resultate_00012.dat</span></tt>. Die Formatiervorgabe, den Integer bis zur
geforderten Feldbreite von links mit Nullen aufzufüllen, ist hier nützlich, um
bei einer großen Anzahl von Parameterwerten eine ordentlich sortierte Übersicht
über die vorhandenen Dateien bekommen zu können.</p>
<p>Da das Überschreiben von Dateien unangenehme Folgen haben kann, ist es nützlich
zu wissen, wie man die Existenz einer Datei überprüfen kann. Mit einer Methode
aus dem <tt class="docutils literal"><span class="pre">os.path</span></tt>-Modul geht das wie im Folgenden gezeigt,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">os</span>

<span class="n">datei</span> <span class="o">=</span> <span class="s">&quot;foo.dat&quot;</span>
<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">datei</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Achtung! {} existiert bereits.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datei</span><span class="p">))</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Die Datei {} existiert noch nicht.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datei</span><span class="p">))</span>
</pre></div>
</div>
<p>Existiert die Datei bereits, so würde man in einer echten Anwendung dem
Benutzer wohl die Möglichkeit geben, das Programm an dieser Stelle geordnet zu
beenden oder einen alternativen Dateinamen anzugeben.</p>
<p>Abschließend sei noch erwähnt, dass Python für bestimmte Dateiformate spezielle
Module zum Lesen und Schreiben zur Verfügung stellt. Hierzu gehört zum Beispiel
das <tt class="docutils literal"><span class="pre">csv</span></tt>-Modul, das den Zugriff auf Dateien im <tt class="docutils literal"><span class="pre">csv</span></tt>-Format <a class="footnote-reference" href="#csv" id="id5">[5]</a>
erlaubt. Dieses Format wird häufig von Tabellenkalkulationsprogrammen wie zum
Beispiel <tt class="docutils literal"><span class="pre">Microsoft</span> <span class="pre">Excel</span></tt> oder <tt class="docutils literal"><span class="pre">Calc</span></tt> aus <tt class="docutils literal"><span class="pre">OpenOffice</span></tt> bzw.
<tt class="docutils literal"><span class="pre">LibreOffice</span></tt> benutzt. Hat man solche Programme bei der Erfassung der Daten
verwendet, so ist es sinnvoll, sich das <tt class="docutils literal"><span class="pre">csv</span></tt>-Modul <a class="footnote-reference" href="#csvdoc" id="id6">[6]</a> anzusehen.</p>
<p>Bei einer aufwendigen Übergabe von Parametern an ein Programm kann auch das
<tt class="docutils literal"><span class="pre">ConfigParser</span></tt>-Modul <a class="footnote-reference" href="#cpdoc" id="id7">[7]</a> von Interesse sein, das mit Dateien im
<tt class="docutils literal"><span class="pre">INI</span></tt>-Format umgehen kann. Dabei werden Parameter in Name-Wert-Paaren
beschrieben, wobei eine Unterteilung in Abschnitte möglich ist.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="foo" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Zum Ursprung dieses Namens siehe <a class="reference external" href="http://www.ietf.org/rfc/rfc3092.txt">RFC 3092</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="argparse" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Dieses Modul ist unter dem Titel <a class="reference external" href="http://docs.python.org/library/argparse.html">argparse – Parser for command-line options,
arguments and sub-commands</a> in der
Python-Dokumentation beschrieben.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="unicode" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Hierzu und zu den folgenden Überlegungen zur Zeichenkodierung sei auf den
Anhang <a class="reference internal" href="unicode.html#appendixunicode"><em>Unicode</em></a> hingewiesen.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="spam" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Die Verwendung von <tt class="docutils literal"><span class="pre">spam</span></tt> in Python-Beispielen als Name ohne spezifische Bedeutung ist
ein Verweis auf einen Sketch der Komikergruppe Monty Python (siehe <a class="reference external" href="http://de.wikipedia.org/wiki/Spam-Sketch">Wikipedia: Spam-Sketch</a>).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="csv" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td><tt class="docutils literal"><span class="pre">csv</span></tt> steht für <em>comma separated values</em>, wobei allerdings kein verbindlicher Standard
existiert. Beispielsweise können Felder genauso gut durch Kommas wie durch Strichpunkte getrennt
sein.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="csvdoc" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>Dieses Modul ist unter dem Titel <a class="reference external" href="http://docs.python.org/library/csv.html">csv — CSV File Reading and Writing</a> in der Python-Dokumentation beschrieben.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="cpdoc" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td>Dieses Modul ist unter dem Titel <a class="reference external" href="http://docs.python.org/library/configparser.html">ConfigParser — Configuration file parser</a> in der Python-Dokumentation beschrieben.</td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="sequenzen.html">Zusammengesetzte Datentypen</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index_latex.html">Inhalt</a>
        &#160;&#160;::&#160;&#160;
        <a href="scipy.html">Numerische Programmbibliotheken am Beispiel von NumPy/SciPy</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2010-2016, Gert-Ludwig Ingold.
      Mit <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3 erstellt.
    </div>
  </body>
</html>