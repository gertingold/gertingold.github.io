<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Numerische Programmbibliotheken am Beispiel von NumPy/SciPy &mdash; Einführung in das Programmieren für Physiker und Materialwissenschaftler</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2015',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Einführung in das Programmieren für Physiker und Materialwissenschaftler" href="index.html" />
    <link rel="next" title="Objektorientiertes Programmieren" href="objektorientiert.html" />
    <link rel="prev" title="Ein- und Ausgabe" href="einausgabe.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Einführung in das Programmieren</span></a></h1>
        <h2 class="heading"><span>Numerische Programmbibliotheken am Beispiel von NumPy/SciPy</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="einausgabe.html">Ein- und Ausgabe</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index_latex.html">Inhalt</a>
        &#160;&#160;::&#160;&#160;
        <a href="objektorientiert.html">Objektorientiertes Programmieren</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="numerische-programmbibliotheken-am-beispiel-von-numpy-scipy">
<span id="scipy"></span><h1>Numerische Programmbibliotheken am Beispiel von NumPy/SciPy<a class="headerlink" href="#numerische-programmbibliotheken-am-beispiel-von-numpy-scipy" title="Permalink zu dieser Überschrift">¶</a></h1>
<p>Bei der numerischen Lösung von Problemen aus der Physik oder den
Materialwissenschaften benötigt man häufig Funktionalität, die von Python und
der zugehörigen Standardbibliothek nicht unmittelbar zur Verfügung gestellt
wird. Man denke an spezielle Funktionen, die nicht im <tt class="docutils literal"><span class="pre">math</span></tt>-Modul enthalten
sind, beispielsweise Besselfunktionen, an die numerische Auswertung von
Integralen oder die Lösung von Differentialgleichungen. Auch die Verwendung von
Matrizen ist nicht unmittelbar möglich. Zwar erlauben es Listen, matrizenartige
Objekte darzustellen, aber es ist nicht direkt möglich, Matrizen miteinander zu
multiplizieren. Hier bleibt einem die Möglichkeit, die benötigte Funktionalität
selbst zu implementieren oder auf eines der vielen für die verschiedensten
Problemstellungen zur Verfügung stehenden Module zurückzugreifen.  Letzteres
ist sicherlich bequemer. Zudem handelt es sich häufig um effiziente und
sorgfältige Implementierungen. In diesem Kapitel wollen wir uns beispielhaft
das Numerikmodul NumPy/SciPy ansehen.</p>
<div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>Nachdem NumPy/SciPy nicht Bestandteil von Pythons Standardbibliothek ist, steht
es standardmäßig noch nicht zur Verfügung. Ob es installiert ist, lässt sich
leicht mit Hilfe eines <tt class="docutils literal"><span class="pre">import</span></tt>-Versuchs feststellen:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">__version__</span>
<span class="go">&#39;1.10.4&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scipy</span><span class="o">.</span><span class="n">__version__</span>
<span class="go">&#39;0.17.0&#39;</span>
</pre></div>
</div>
<p>Sind die Bibliotheken nicht vorhanden, so würde eine <tt class="docutils literal"><span class="pre">ImportError</span></tt>-Ausnahme
geworfen. Dann muss SciPy, das wiederum von NumPy abhängt, zunächst installiert
werden. Die Software lässt sich von
<a class="reference external" href="http://sourceforge.net/projects/numpy/files/">http://sourceforge.net/projects/numpy/files/</a> (NumPy) und
<a class="reference external" href="http://sourceforge.net/projects/scipy/files/">http://sourceforge.net/projects/scipy/files/</a> (SciPy) herunterladen. Eine
vollständige Übersicht über die zur Verfügung stehenden Varianten findet man
auf den <a class="reference external" href="http://www.scipy.org">SciPy-Seiten</a> unter
<a class="reference external" href="http://www.scipy.org/Download">http://www.scipy.org/Download</a>. Bei der Installation unter
Windows-Betriebssystemen ist zu beachten, dass die Datei für die verwendete
Python-Version heruntergeladen wird. Unter Linux-Betriebssystemen stellt das
Paketverwaltungssystem der jeweiligen Distribution normalerweise einen bequemen
Weg zur Installation von NumPy/SciPy zur Verfügung. <a class="footnote-reference" href="#scipydeb" id="id1">[1]</a> Alternativ ist
eine Installation der Quellen mit Hilfe des Python-Interpreters möglich, wobei
die Module im Verzeichnis der entsprechenden Python-Version abgelegt werden.
Nach der Installation sollte der Import funktionieren und die Versionsnummer
wie oben angegeben abrufbar sein <a class="footnote-reference" href="#version" id="id2">[2]</a>.</p>
</div>
<div class="section" id="arrays-und-anwendungen">
<span id="numpy"></span><h2>Arrays und Anwendungen<a class="headerlink" href="#arrays-und-anwendungen" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>Im Folgenden soll anhand von wenigen Beispielen ein kurzer Einblick in die
Möglichkeiten gegeben werden, die NumPy bietet. Das Programm</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">matrixA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.7</span><span class="p">,</span> <span class="mf">3.9</span><span class="p">]])</span>
<span class="n">matrixB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.1</span><span class="p">]])</span>
<span class="k">print</span><span class="p">(</span><span class="n">matrixA</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matrixB</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrixA</span><span class="p">,</span> <span class="n">matrixB</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="n">anweisung</span> <span class="o">=</span> <span class="s">&quot;{:g}*{:g}+{:g}*{:g}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">matrixA</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">matrixB</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                         <span class="n">matrixA</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">matrixB</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s">&quot;{} = {:g}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">anweisung</span><span class="p">,</span> <span class="nb">eval</span><span class="p">(</span><span class="n">anweisung</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>erzeugt die Ausgabe</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[[</span> <span class="mf">1.3</span>  <span class="mf">2.5</span><span class="p">]</span>
 <span class="p">[</span><span class="o">-</span><span class="mf">1.7</span>  <span class="mf">3.9</span><span class="p">]]</span>

<span class="p">[[</span> <span class="mf">2.1</span> <span class="o">-</span><span class="mf">4.5</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.9</span> <span class="o">-</span><span class="mf">2.1</span><span class="p">]]</span>

<span class="p">[[</span>  <span class="mf">4.98</span> <span class="o">-</span><span class="mf">11.1</span> <span class="p">]</span>
 <span class="p">[</span> <span class="o">-</span><span class="mf">0.06</span>  <span class="o">-</span><span class="mf">0.54</span><span class="p">]]</span>

<span class="mf">1.3</span><span class="o">*</span><span class="mf">2.1</span><span class="o">+</span><span class="mf">2.5</span><span class="o">*</span><span class="mf">0.9</span> <span class="o">=</span> <span class="mf">4.98</span>
</pre></div>
</div>
<p>In der ersten Zeile des Programmcodes wird das NumPy-Modul geladen, wobei die
Verwendung des kurzen Bezeichners <tt class="docutils literal"><span class="pre">np</span></tt> eine häufig verwendete Konvention ist,
um im Programmtext auf die Herkunft der verwendeten Methoden hinzuweisen. In
den Zeilen 3 und 4 ist eine Möglichkeit gezeigt, Matrizen mit Hilfe von NumPy
aus einer Liste zu erzeugen. In Zeile 9 wird das Produkt der beiden Matrizen
berechnet und ausgegeben. Die in den Zeilen 11 und 12 erzeugte Ausgabe weist
die Korrektheit anhand des obersten Diagonalelements des Produkts durch
Multiplikation der entsprechenden Zeile von <tt class="docutils literal"><span class="pre">matrixA</span></tt> und Spalte von
<tt class="docutils literal"><span class="pre">matrixB</span></tt> nach. Zugleich erkennt man aus Zeile 11, dass die Nummerierung der
Matrixelemente, wie die von Python-Listen, mit <tt class="docutils literal"><span class="pre">0</span></tt> beginnt. Im Gegensatz zu
Listen werden die Matrixelemente jedoch durch Kommas getrennt in einem einzigen
eckigen Klammerpaar angegeben. Daraus wird deutlich, dass im Gegensatz zu der
hierarchischen Konstruktion der Listen von Listen hier die verschiedenen
Dimensionen eines Arrays gleichberechtigt sind.</p>
<p>Multipliziert man zwei Arrays mit Hilfe des Multiplikationsoperators <tt class="docutils literal"><span class="pre">*</span></tt>, so
wird keine Matrixmultiplikation durchgeführt. Vielmehr werden die Elemente an
den jeweils gleichen Positionen der beiden Matrizen miteinander multipliziert.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">matrixA</span><span class="o">*</span><span class="n">matrixB</span>
<span class="go">array([[  2.73 -11.25],</span>
<span class="go">       [ -1.53  -8.19]])</span>
</pre></div>
</div>
<p>Das folgende Beispiel zeigt die Berechnung von Skalarprodukt, dyadischem
Produkt sowie Kreuzprodukt für zwei Vektoren.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">vecA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">vecB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vecA</span><span class="p">,</span> <span class="n">vecB</span><span class="p">)</span>
<span class="k">print</span>
<span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">vecA</span><span class="p">,</span> <span class="n">vecB</span><span class="p">)</span>
<span class="k">print</span>
<span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vecA</span><span class="p">,</span> <span class="n">vecB</span><span class="p">)</span>
</pre></div>
</div>
<p>Als Ausgabe findet man erwartungsgemäß</p>
<div class="highlight-python"><div class="highlight"><pre><span class="o">-</span><span class="mi">2</span>

<span class="p">[[</span> <span class="mi">10</span>   <span class="mi">8</span>   <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="o">-</span><span class="mi">15</span> <span class="o">-</span><span class="mi">12</span>   <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span>  <span class="mi">0</span>   <span class="mi">0</span>   <span class="mi">0</span><span class="p">]]</span>

<span class="p">[</span> <span class="mi">0</span>  <span class="mi">0</span> <span class="mi">23</span><span class="p">]</span>
</pre></div>
</div>
<p>Interessant ist die Möglichkeit, Arrays als Argumente von mathematischen Funktionen zu verwenden:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9,  1. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([ 1.        ,  1.10517092,  1.22140276,  1.34985881,  1.4918247 ,</span>
<span class="go">        1.64872127,  1.8221188 ,  2.01375271,  2.22554093,  2.45960311,</span>
<span class="go">        2.71828183])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">only length-1 arrays can be converted to Python scalars</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">only length-1 arrays can be converted to Python scalars</span>
</pre></div>
</td></tr></table></div>
<p>Eine praktische Methode, um ein Array mit äquidistanten Werten zwischen zwei
Grenzen zu erzeugen, ist die <tt class="xref py py-func docutils literal"><span class="pre">linspace()</span></tt>-Funktion, die in Zeile 3 zur
Erzeugung der Argumente benutzt wird. Der Aufruf der Exponentialfunktion aus
NumPy gibt in den Zeilen 6-9 ein ganzes Array der entsprechenden Ergebnisse
zurück. Zeilen 10-13 zeigen, dass dies mit der Exponentialfunktion aus dem
<tt class="docutils literal"><span class="pre">math</span></tt>-Modul nicht möglich wäre.  Bei umfangreichen Arrays spart die
Verwendung der NumPy-Funktion Rechenzeit gegenüber einer Schleife, die die
Funktion nacheinander auf jedes Element einzeln anwendet. Als Faustregel gilt
bei der Verwendung von NumPy, dass im Hinblick auf die Effizienz eines Programms
<tt class="docutils literal"><span class="pre">for</span></tt>-Schleifen nach Möglichkeit durch geeignete <tt class="docutils literal"><span class="pre">array</span></tt>-Operationen
ersetzt werden sollten.</p>
<p>Zum Abschluss kehren wir noch einmal zu den Matrizen zurück und sehen uns
einige Funktionen aus dem Bereich der Linearen Algebra an.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span> <span class="k">as</span> <span class="n">LA</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">-1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([[-5.,  3.],</span>
<span class="go">       [ 2., -1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">LA</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">array([[ 1.,  0.],</span>
<span class="go">       [ 0.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(array([-0.16227766,  6.16227766]), array([[-0.93246475, -0.50245469],</span>
<span class="go">       [ 0.36126098, -0.86460354]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eigenwerte</span><span class="p">,</span> <span class="n">eigenvektoren</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">eigenwerte</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">eigenvektoren</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]),</span> <span class="n">eigenwerte</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">eigenvektoren</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">[ 0.1513182  -0.05862459] [ 0.1513182  -0.05862459]</span>
<span class="go">[-3.09626531 -5.32792709] [-3.09626531 -5.32792709]</span>
</pre></div>
</td></tr></table></div>
<p>In den Zeilen 1 und 2 werden zunächst die weiter unten benötigten Funktionen
importiert.  Dabei bezieht sich Zeile 2 auf die Funktionen, die im Modul zur
Linearen Algebra von NumPy enthalten sind. Nachdem in Zeile 3 eine Matrix
definiert wurde, wird in Zeile 4 die zugehörige Determinante bestimmt. In Zeile
6 wird die inverse Matrix berechnet und die Korrektheit des Ergebnisses durch
Multiplikation mit der ursprünglichen Matrix nachgewiesen. In Zeile 9 werden
die Eigenwerte und Eigenvektoren der Matrix <tt class="docutils literal"><span class="pre">a</span></tt> berechnet. Um auf das Tupel
nicht über die entsprechenden Indizes zugreifen zu müssen, kann man das
Ergebnis wie in Zeile 12 gezeigt gleich in die Eigenwerte und die Eigenvektoren
aufteilen. In den Zeilen 13-17 wird schließlich nachgewiesen, dass die
Eigenwerte und Eigenvektoren korrekt sind. Dabei wird verwendet, dass die
Spalten der Eigenvektormatrix den Eigenvektoren entsprechen. Der erste
Eigenvektor wird mit <tt class="docutils literal"><span class="pre">eigenvektor[:,</span> <span class="pre">0]</span></tt> angegeben. Wie bei Listen bedeutet
der einzelne Doppelpunkt, dass der erste Index von seinem Minimalwert <tt class="docutils literal"><span class="pre">0</span></tt> bis
zu seinem Maximalwert, hier <tt class="docutils literal"><span class="pre">1</span></tt>, läuft.</p>
</div>
<div class="section" id="numerische-integration">
<h2>Numerische Integration<a class="headerlink" href="#numerische-integration" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>Als Anwendung von SciPy betrachten wir die numerische Auswertung des Integrals</p>
<div class="math">
\[J_0(1) = \frac{1}{\pi}\int_0^\pi\cos(\cos(x))\mathrm{d}x.\]</div>
<p>Hierbei ist <span class="math">\(J_0(z)\)</span> die Besselfunktion erster Gattung und nullter
Ordnung, deren Wert wir probehalber ebenfalls mit Hilfe von SciPy berechnen
lassen können. Das folgende Programm führt die notwendigen Berechnungen durch:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">pi</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">integrate</span><span class="p">,</span> <span class="n">special</span>

<span class="n">resultat</span><span class="p">,</span> <span class="n">fehler</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cos</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">resultat</span><span class="o">/</span><span class="n">pi</span><span class="p">,</span> <span class="n">fehler</span><span class="o">/</span><span class="n">pi</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">special</span><span class="o">.</span><span class="n">j0</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>Die zugehörige Ausgabe lautet</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mf">0.7651976865579664</span> <span class="mf">7.610964456309953e-11</span>
<span class="mf">0.765197686558</span>
</pre></div>
</div>
<p>In den ersten beiden Programmzeilen werden zunächst die benötigten Unterpakete
von SciPy, <tt class="xref py py-mod docutils literal"><span class="pre">integrate</span></tt> für die Integration und <tt class="xref py py-mod docutils literal"><span class="pre">special</span></tt> für
spezielle Funktionen, sowie der Kosinus und die Kreiszahl aus dem
<tt class="xref py py-mod docutils literal"><span class="pre">math</span></tt>-Modul importiert. In Zeile 4 wird zur Integration die Funktion
<tt class="xref py py-func docutils literal"><span class="pre">quad()</span></tt> (von »Quadratur« oder Englisch »quadrature«) aus dem
<tt class="xref py py-mod docutils literal"><span class="pre">integrate</span></tt>-Modul verwendet. <tt class="xref py py-func docutils literal"><span class="pre">quad()</span></tt> verlangt zwingend eine Funktion,
die den Integranden beschreibt und hier als Lambdafunktion angegeben ist, sowie
die Integrationsgrenzen. Ausgegeben werden das Resultat der numerischen
Integration und eine Abschätzung des absoluten Fehlers. Zur Beurteilung der
Qualität des Resultats verwenden wir in Zeile 6 die Besselfunktion <tt class="xref py py-func docutils literal"><span class="pre">j0()</span></tt>
aus dem <tt class="xref py py-mod docutils literal"><span class="pre">special</span></tt>-Modul von SciPy.  Der Vergleich des Ergebnisses der
numerischen Integration mit <span class="math">\(J_0(1)\)</span>, für das SciPy einen ebenfalls im
Prinzip mit Fehlern behafteten numerischen Wert bestimmt, ergibt perfekte
Übereinstimmung.</p>
<p>Wenn man die Konstante <tt class="docutils literal"><span class="pre">inf</span></tt> aus NumPy importiert, kann man auch
uneigentliche Integrale berechnen:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">integrate</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">resultat</span><span class="p">,</span> <span class="n">fehler</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">resultat</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">fehler</span><span class="p">)</span>
</pre></div>
</div>
<p>Der erste Wert der Ausgabe</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mf">1.0</span> <span class="mf">5.155583905474508e-10</span>
</pre></div>
</div>
<p>zeigt, dass der Wert des Integrals</p>
<div class="math">
\[\int_{-\infty}^\infty\frac{1}{x^2+1}\mathrm{d}x = \pi\]</div>
<p>korrekt bestimmt wird. Man sollte sich von der Qualität dieses Ergebnisses jedoch nicht täuschen lassen.
Nicht immer kann ein numerisches Resultat mit einer solchen Genauigkeit erhalten werden. Manchmal muss
das Integrationsproblem auch zunächst geeignet formuliert werden, zum Beispiel in der Nähe von Singularitäten
oder wenn der Integrand schnell oszilliert.</p>
</div>
<div class="section" id="integration-gewohnlicher-differentialgleichungen">
<span id="ode"></span><h2>Integration gewöhnlicher Differentialgleichungen<a class="headerlink" href="#integration-gewohnlicher-differentialgleichungen" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>Häufig steht man in der Physik und den Materialwissenschaften vor der Aufgabe,
Differentialgleichungen zu lösen.  Wir beschränken uns hier auf gewöhnliche
Differentialgleichungen, die als Anfangswertproblem gelöst werden sollen. Wir
beginnen mit einer Differentialgleichung erster Ordnung</p>
<div class="math">
\[\dot x = -x^2,\]</div>
<p>die sich durch Trennung der Variablen lösen lässt. Will man nicht selbst ein
Lösungsverfahren, zum Beispiel das Euler- oder Runge-Kutta-Verfahren
implementieren, so kann man wiederum auf das SciPy-Paket zurückgreifen. Dort
wird unter anderem die Funktion <tt class="docutils literal"><span class="pre">odeint</span></tt> zur Verfügung gestellt, die wir im
Folgenden benutzen wollen. Der Name der Funktion enthält das englische
»ordinary differential equation« in abgekürzter Form.</p>
<p>Da der Funktionsaufruf in einem solchen Fall durchaus komplexer sein kann, muss
man sich zunächst über die von der Funktion erwarteten Argumente informieren.
In Python kann man das leicht mit der <tt class="xref py py-func docutils literal"><span class="pre">help()</span></tt>-Funktion tun, aber auch im
Internet unter <a class="reference external" href="http://docs.scipy.org/doc/">http://docs.scipy.org/doc/</a> finden sich Dokumentationen.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">integrate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">)</span>

<span class="go">Help on function odeint in module scipy.integrate.odepack:</span>

<span class="go">odeint(func, y0, t, args=(), Dfun=None, col_deriv=0, full_output=0, ml=None,</span>
<span class="go">mu=None, rtol=None, atol=None, tcrit=None, h0=0.0, hmax=0.0, hmin=0.0, ixpr=0,</span>
<span class="go">mxstep=0, mxhnil=0, mxordn=12, mxords=5, printmessg=0)</span>
<span class="go">    Integrate a system of ordinary differential equations.</span>

<span class="go">    Solve a system of ordinary differential equations using lsoda from the</span>
<span class="go">    FORTRAN library odepack.</span>

<span class="go">    Solves the initial value problem for stiff or non-stiff systems</span>
<span class="go">    of first order ode-s::</span>

<span class="go">        dy/dt = func(y,t0,...)</span>

<span class="go">    where y can be a vector.</span>

<span class="go">    Parameters</span>
<span class="go">    ----------</span>
<span class="go">    func : callable(y, t0, ...)</span>
<span class="go">        Computes the derivative of y at t0.</span>
<span class="go">    y0 : array</span>
<span class="go">        Initial condition on y (can be a vector).</span>
<span class="go">    t : array</span>
<span class="go">        A sequence of time points for which to solve for y.  The initial</span>
<span class="go">        value point should be the first element of this sequence.</span>
<span class="go">[…]</span>

<span class="go">    Returns</span>
<span class="go">    -------</span>
<span class="go">    y : array, shape (len(t), len(y0))</span>
<span class="go">        Array containing the value of y for each desired time in t,</span>
<span class="go">        with the initial value y0 in the first row.</span>
<span class="go">[…]</span>
</pre></div>
</div>
<p>Wir haben an den mit <tt class="docutils literal"><span class="pre">[…]</span></tt> markierten Stellen einigen Text ausgelassen. Bereits der
gleich zu Beginn angegebene Funktionsaufruf zeigt, dass eine Vielzahl an Parametern übergeben
werden können. Die meisten sind jedoch mit Defaultwerten belegt, so dass wir nicht gezwungen
sind, sie zu spezifizieren. Sollte es jedoch zum Beispiel nötig sein, den relativen oder absoluten
Fehler besser zu kontrollieren, so kann man dies tun. Beim Aufruf der Funktion <tt class="xref py py-func docutils literal"><span class="pre">odeint()</span></tt>
müssen wir aber auf jeden Fall eine aufrufbare Funktion übergeben, die es erlaubt, die Ableitung
zu berechnen. Diese Funktion muss zumindest zwei Argumente besitzen, nämlich die aktuellen Werte
der abhängigen und der unabhängigen Variablen. Ferner benötigen wir einen Anfangswert und
einen Vektor, der die Werte der unabhängigen Variablen enthält, zu der die gesuchte Lösung der
Differentialgleichung bestimmt werden soll. Das folgende Programm berechnet eine numerische
Lösung für die oben genannte Differentialgleichung.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">integrate</span>

<span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="n">ergebnis</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pts</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">)):</span>
    <span class="n">exakt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">pts</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;{:3.0f}  {:10.8f}  {:11.5g}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                      <span class="n">pts</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                      <span class="n">ergebnis</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                      <span class="p">(</span><span class="n">ergebnis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">exakt</span><span class="p">)</span><span class="o">/</span><span class="n">exakt</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>In Zeile 1 importieren wir zunächst das <tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt>-Modul, das wir benötigen,
um in Zeile 4 ein Array mit äquidistanten Zeitpunkten zu erzeugen. Außerdem
wird in Zeile 2 das <tt class="xref py py-mod docutils literal"><span class="pre">integrate</span></tt>-Unterpaket aus SciPy importiert, aus dem
wir die Funktion <tt class="xref py py-func docutils literal"><span class="pre">odeint()</span></tt> zum Lösen der Differentialgleichung verwenden
wollen.  Dies geschieht in Zeile 5. Dabei haben wir die Ableitung der
Einfachheit halber als Lambda-Funktion in den Aufruf geschrieben.  Der
Anfangswert ist im zweiten Argument gleich <tt class="docutils literal"><span class="pre">1</span></tt> gesetzt und das dritte
Argument enthält das NumPy-Array mit den Punkten, für die die Lösung bestimmt
werden soll. <tt class="xref py py-func docutils literal"><span class="pre">odeint()</span></tt> gibt ein zweidimensionales Array zurück, das bei
Differentialgleichungssystemen in jeder Spalte den Zeitverlauf für eine
Komponente enthält. Da wir in unserem Beispiel nur eine einzige
Differentialgleichung erster Ordnung vorliegen haben, wählen wir explizit die
Spalte 0 aus. Ab Zeile 6 wird das exakte Ergebnis an den vorgegebenen Punkten
ausgewertet und die Lösung samt den Werten der unabhängigen Variablen und des
relativen Fehlers ausgegeben. Führt man das Programm aus, so erhält man etwa
die folgende Ausgabe</p>
<div class="highlight-python"><div class="highlight"><pre>  0  1.00000000            0
  1  0.50000000   1.1693e-09
  2  0.33333332  -5.1641e-08
  3  0.24999998   -8.066e-08
  4  0.19999998  -1.0617e-07
[…]
 95  0.01041665  -1.1279e-06
 96  0.01030927   -1.126e-06
 97  0.01020407  -1.1343e-06
 98  0.01010100   -1.146e-06
 99  0.00999999  -1.1439e-06
100  0.00990098   -1.135e-06
</pre></div>
</div>
<p>Wir verzichten darauf, die gesamte Ausgabe zu reproduzieren. Man sieht aber bereits an
diesen Zeilen, dass das erhaltene Ergebnis nicht exakt ist und der relative Fehler mit zunehmendem
Abstand vom Startwert zunimmt. Dennoch ist der relative Fehler gut kontrolliert, so dass hier
eine brauchbare Lösung erzeugt wurde.</p>
<p>Wenn wir uns die Dokumentation der <tt class="xref py py-func docutils literal"><span class="pre">odeint()</span></tt>-Funktion noch einmal ansehen, stellen wir
fest, dass die Funktion zunächst für Differentialgleichungen erster Ordnung gedacht ist.
Allerdings kann es sich bei der Variablen <tt class="docutils literal"><span class="pre">y</span></tt> um einen Vektor handeln. Dies gibt uns die
Möglichkeit, auch Differentialgleichungen höherer Ordnung numerisch zu behandeln. Wir müssen
sie nur in ein System von Differentialgleichungen erster Ordnung umformulieren. Betrachten wir
als Beispiel die Differentialgleichung eines gedämpften harmonischen Oszillators</p>
<div class="math">
\[\ddot x+\gamma\dot x+x=0,\]</div>
<p>wobei γ die Dämpfungskonstante ist. Diese Differentialgleichung ist zu dem Satz
zweier Differentialgleichungen erster Ordnung</p>
<div class="math">
\[\dot p=-x-\gamma p\]</div>
<div class="math">
\[\dot x=p\]</div>
<p>äquivalent, den wir nun mit den Anfangsbedingungen <span class="math">\(x(0)=0,\,p(0)=1\)</span>
numerisch lösen wollen.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">integrate</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">sqrt</span>

<span class="k">def</span> <span class="nf">ableitung</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">y</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="n">gamma</span><span class="o">*</span><span class="n">p</span><span class="p">])</span>

<span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="n">anfangsbedingungen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="n">omega</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mf">0.25</span><span class="o">*</span><span class="n">gamma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="n">ergebnis</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">ableitung</span><span class="p">,</span> <span class="n">anfangsbedingungen</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,))</span>
<span class="n">ort</span> <span class="o">=</span> <span class="n">ergebnis</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">)):</span>
    <span class="n">exakt</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">gamma</span><span class="o">*</span><span class="n">pts</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">pts</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">/</span><span class="n">omega</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;{:4.1f}  {:8.5f}  {:11.5g}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">pts</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">ort</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">ort</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">exakt</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>Nachdem wir bereits ein Beispiel besprochen haben, können wir uns hier auf die
neuen Aspekte beschränken. In den Zeilen 5-7 wurde diesmal eine Funktion
definiert, die einen Vektor mit den benötigten ersten Ableitungen zurückgibt.
Die in Zeile 10 definierten Anfangsbedingungen müssen jetzt ebenfalls aus einem
Vektor bestehen. Außerdem enthält die Funktion <tt class="xref py py-func docutils literal"><span class="pre">ableitung()</span></tt> ein
zusätzliches Argument, nämlich <tt class="docutils literal"><span class="pre">gamma</span></tt>, das übergeben werden muss. Dazu sieht
<tt class="xref py py-func docutils literal"><span class="pre">odeint()</span></tt> ein viertes Argument vor, das ein Tupel sein muss und dessen
Elemente dem dritten und eventuell weiteren Argumenten der Ableitungsfunktion
zugeordnet werden.  Es ist zu beachten, dass ein einzelner eingeklammerter
Variablenname nur dann als Tupel interpretiert wird, wenn dieser von einem
Komma gefolgt wird.</p>
<p><a class="reference internal" href="_images/question.png"><img alt="frage" src="_images/question.png" style="height: 1em;" /></a> Warum wird hier im Gegensatz zum ersten Beispiel nicht der relative sondern
der absolute Fehler ausgegeben?</p>
<p>Auch wenn der hier vorgestellte Programmcode nur die Position des Oszillators
als Funktion der Zeit ausgibt, könnte man genauso seine Geschwindigkeit
ausgeben. Nachdem wir zwei Differentialgleichungen erster Ordnung gelöst haben,
ist die Geschwindigkeit bei der von uns gewählten Reihenfolge als zweite Spalte
<tt class="docutils literal"><span class="pre">ergebnis[:,</span> <span class="pre">1]</span></tt> in der Ergebnismatrix zugänglich.</p>
<p><a class="reference internal" href="_images/question.png"><img alt="frage" src="_images/question.png" style="height: 1em;" /></a> Wie ändert sich die Trajektorie, wenn in der Bewegungsgleichung
<span class="math">\(\dot x\)</span> durch <span class="math">\(\dot x^2\)</span> ersetzt wird, so dass die Bewegungsgleichung
nichtlinear wird? Mit den in Kapitel <a class="reference internal" href="grafik.html#grafik"><em>Erstellung von Grafiken</em></a> dargestellten Techniken können
Sie die berechneten Trajektorien leicht vergleichen.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="scipydeb" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Unter Debian und Ubuntu heißen die zu installierenden Pakete <tt class="docutils literal"><span class="pre">python3-numpy</span></tt> und
<tt class="docutils literal"><span class="pre">python3-scipy</span></tt>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="version" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Man beachte, dass vor und nach <tt class="docutils literal"><span class="pre">version</span></tt> jeweils <em>zwei</em> Unterstriche einzugeben sind.</td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="einausgabe.html">Ein- und Ausgabe</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index_latex.html">Inhalt</a>
        &#160;&#160;::&#160;&#160;
        <a href="objektorientiert.html">Objektorientiertes Programmieren</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2010-2016, Gert-Ludwig Ingold.
      Mit <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3 erstellt.
    </div>
  </body>
</html>