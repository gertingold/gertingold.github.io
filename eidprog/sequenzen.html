<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="de">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Zusammengesetzte Datentypen &#8212; Einführung in das Programmieren für Physiker und Materialwissenschaftler</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2018alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" title="Suche" href="search.html" />
    <link rel="top" title="Einführung in das Programmieren für Physiker und Materialwissenschaftler" href="index_latex.html" />
    <link rel="next" title="Ein- und Ausgabe" href="einausgabe.html" />
    <link rel="prev" title="Funktionen" href="funktionen.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Einführung in das Programmieren</span></a></h1>
        <h2 class="heading"><span>Zusammengesetzte Datentypen</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="funktionen.html">Funktionen</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index_latex.html">Inhalt</a>
        &#160;&#160;::&#160;&#160;
        <a href="einausgabe.html">Ein- und Ausgabe</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="zusammengesetzte-datentypen">
<span id="zusgdatentypen"></span><h1>Zusammengesetzte Datentypen<a class="headerlink" href="#zusammengesetzte-datentypen" title="Link zu dieser Überschrift">¶</a></h1>
<div class="section" id="listen">
<span id="id1"></span><h2>Listen<a class="headerlink" href="#listen" title="Link zu dieser Überschrift">¶</a></h2>
<p>Bei numerischen Anwendungen in Physik und Materialwissenschaften will man neben
den einfachen Datentypen des Kapitels <a class="reference internal" href="datentypen.html#datentypen"><span class="std std-ref">Einfache Datentypen, Variablen und Zuweisungen</span></a> unter anderem auch
Vektoren und Matrizen verwenden. Echte Vektoren und Matrizen mit zugehörigen
Funktionen wie beispielsweise dem Skalarprodukt werden von Python nicht direkt
zur Verfügung gestellt.  Hierzu greift man auf das Numpy-Modul zurück, das im
Abschnitt <a class="reference internal" href="scipy.html#numpy"><span class="std std-ref">Arrays und Anwendungen</span></a> besprochen wird. Python stellt jedoch sehr wohl
Datentypen zur Verfügung, die als Ansammlung von Zahlen verwendet werden
können. Der erste Typ dieser Art, den wir hier besprechen wollen, ist die
Liste.  Wir haben sie bereits im Abschnitt <a class="reference internal" href="kontrollstrukturen.html#forloop"><span class="std std-ref">For-Schleife</span></a> kennengelernt. Dort
hatten wir mit Hilfe von <code class="xref py py-func docutils literal"><span class="pre">range()</span></code> und <code class="xref py py-func docutils literal"><span class="pre">list()</span></code> Listen erzeugt,
auch wenn wir uns dessen dort nicht wirklich bewusst waren. Dementsprechend
lässt sich eine, zugegebenermaßen sehr spezielle Liste folgendermaßen erzeugen:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">liste</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">liste</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">liste</span><span class="p">)</span>
<span class="go">&lt;class &#39;list&#39;&gt;</span>
</pre></div>
</div>
<p>Wie wir aus dem Abschnitt <a class="reference internal" href="kontrollstrukturen.html#forloop"><span class="std std-ref">For-Schleife</span></a> wissen, erzeugt die
<code class="xref py py-func docutils literal"><span class="pre">range()</span></code>-Funktion bei Angabe eines einzigen Arguments eine Sequenz von
Zahlen, die mit Null beginnt und mit dem um Eins verminderten Argument endet.
Aufeinanderfolgende Listenelemente unterscheiden sich in diesem Fall jeweils um
Eins.</p>
<p>Häufig ist es notwendig, die Anzahl der Elemente einer Liste zu kennen. Diese Information
erhält man mit Hilfe der Funktion <code class="xref py py-func docutils literal"><span class="pre">len()</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">liste</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">liste</span><span class="p">)</span>
<span class="go">[1, 4, 7, 10, 13, 16]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">liste</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
<p>Es ist möglich, auf einzelne Elemente der Liste zuzugreifen und diese auch zu verändern:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">liste</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">liste</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">liste</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">liste</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
<p>Dabei ist immer zu bedenken, dass der Index, mit dem die Elemente durchnummeriert werden, mit
Null beginnt. Das zweite Element ist also in diesem Fall <code class="docutils literal"><span class="pre">liste[1]</span></code>. Diese Zählweise wird
auch in einigen anderen Programmiersprachen verwendet, nicht aber zum Beispiel in FORTRAN.</p>
<p>Neben einzelnen Elementen kann man auch Unterlisten, so genannte »slices«, erzeugen.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">23</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[3, 5, 7, 11]</span>
</pre></div>
</div>
<p>Vor dem Doppelpunkt steht der Index des ersten Elements des Ausschnitts der Liste. Dies ist
hier also <code class="docutils literal"><span class="pre">a[1]</span></code>. Der Index des letzten Elements, hier <code class="docutils literal"><span class="pre">a[4]</span></code>, ist durch die um Eins
verminderte Zahl nach dem Doppelpunkt gegeben. Dieses Verhalten entspricht genau dem, was
wir von der <code class="xref py py-func docutils literal"><span class="pre">range()</span></code>-Funktion her kennen. Eine Unterliste von <code class="docutils literal"><span class="pre">a</span></code>, die direkt an
<code class="docutils literal"><span class="pre">a[1:5]</span></code> anschließt, hat als ersten Index die <code class="docutils literal"><span class="pre">5</span></code>, also</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span>
<span class="go">[13, 17, 19]</span>
</pre></div>
</div>
<p>Die Funktionsweise der Indizes lässt sich anschaulich verstehen, wenn man sie nicht als
Index eines Listeneintrags ansieht, sondern als Markierung »zwischen« den Listeneinträgen,
wie es die folgende Abbildung zeigt:</p>
<a class="reference internal image-reference" href="_images/listnumbering1.png"><img alt="_images/listnumbering1.png" class="align-center" src="_images/listnumbering1.png" style="width: 30em;" /></a>
<p><a class="reference internal" href="_images/question.png"><img alt="frage" src="_images/question.png" style="height: 1em;" /></a> Was ergibt <code class="docutils literal"><span class="pre">a[2:2]</span></code>?</p>
<p>Wird einer der beiden Indizes nicht angegeben, so wird er durch den Index ersetzt, der auf
den Beginn bzw. das Ende der Liste zeigt.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[2, 3, 5, 7, 11]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:]</span>
<span class="go">[13, 17, 19, 23]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:]</span>
<span class="go">[2, 3, 5, 7, 11, 13, 17, 19, 23]</span>
</pre></div>
</div>
<p>In der letzten Anweisung wurden beide Indizes weggelassen, so dass man die
gesamte Liste erhält, was zum Beispiel auch folgendermaßen möglich wäre:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[2, 3, 5, 7, 11, 13, 17, 19, 23]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>
<span class="go">[2, 3, 5, 7, 11, 13, 17, 19, 23]</span>
</pre></div>
</div>
<p>Was passiert nun, wenn man den ersten Index außerhalb des Bereichs zwischen
<code class="docutils literal"><span class="pre">0</span></code> und <code class="docutils literal"><span class="pre">N-1</span></code> oder den zweiten Index außerhalb des Bereichs <code class="docutils literal"><span class="pre">1</span></code> und <code class="docutils literal"><span class="pre">N</span></code>
wählt, wobei <code class="docutils literal"><span class="pre">N</span></code> die Listenlänge sei? In manchen Programmiersprachen kann es
passieren, dass man auf ein zufällig im Speicher benachbart liegendes Objekt
zugreift.  In den meisten Fällen wird dies zu einem unerwünschten Ergebnis
führen. Python dagegen weist auf den illegalen Zugriff hin:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">IndexError</span>: <span class="n">list index out of range</span>
</pre></div>
</div>
<p>Allerdings sind negative Indizes bis zu <code class="docutils literal"><span class="pre">-N</span></code> erlaubt. Dabei beginnt die Zählung
mit <code class="docutils literal"><span class="pre">-1</span></code> vom letzten Listenelement an rückwärts, so dass das erste Element auch
mit dem Index <code class="docutils literal"><span class="pre">-N</span></code> angesprochen werden kann. Das folgende Bild stellt die Zuordnung
der Indizes dar.</p>
<a class="reference internal image-reference" href="_images/listnumbering2.png"><img alt="_images/listnumbering2.png" class="align-center" src="_images/listnumbering2.png" style="width: 20em;" /></a>
<p>Die letzten beiden Elemente einer Liste erhält man demnach mit Hilfe von</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">23</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
<span class="go">[19, 23]</span>
</pre></div>
</div>
<p>Schließlich gibt es auch noch die Möglichkeit, die Schrittweite bei der Erzeugung
der Unterliste festzulegen, wie die folgenden Beispiele zeigen:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[2, 5, 11]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[2, 7, 17]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[23, 19, 17, 13, 11, 7, 5, 3, 2]</span>
</pre></div>
</div>
<p>In der ersten Anweisung wird jedes zweite Listenelement aus dem Indexbereich <code class="docutils literal"><span class="pre">0</span></code>
bis <code class="docutils literal"><span class="pre">5</span></code> ausgewählt, also die Listenelemente <code class="docutils literal"><span class="pre">a[0]</span></code>, <code class="docutils literal"><span class="pre">a[2]</span></code> und <code class="docutils literal"><span class="pre">a[4]</span></code>.
In der zweiten Anweisung wird jedes dritte Listenelement aus der gesamten Liste
ausgewählt. Letzteres ergibt sich daraus, dass die ersten beiden Indizes nicht
explizit angegeben sind. Eine Schrittweite von <code class="docutils literal"><span class="pre">-1</span></code> führt schließlich zu einer
Umkehrung der Reihenfolge der Listenelemente. Eine Alternative hierzu bietet die
<code class="xref py py-func docutils literal"><span class="pre">reverse()</span></code>-Methode an, die wir am Ende dieses Unterkapitels besprechen
werden.</p>
<p>In Python ist zu beachten, dass sich das Kopieren von Listen nicht so verhält, wie
man es vielleicht erwarten würde.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3070057740</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">3070057740</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">111</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[111, 17, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">[111, 17, 9]</span>
</pre></div>
</td></tr></table></div>
<p>Die Zuweisung in Zeile 4 führt nicht zu einem neuen Listenobjekt, das unabhängig
verändert werden kann. Vielmehr zeigen die Zeilen 2 und 3 bzw. 5 und 6, dass es sich
bei <code class="docutils literal"><span class="pre">a</span></code> und <code class="docutils literal"><span class="pre">b</span></code> um dasselbe Objekt handelt. Ändert man ein Element der Liste <code class="docutils literal"><span class="pre">a</span></code>,
so wird, wie die Zeilen 8-11 zeigen, auch die Liste <code class="docutils literal"><span class="pre">b</span></code> entsprechend geändert.
Letztlich hat man durch die Anweisung in Zeile 4 lediglich einen alternativen Namen
definiert, über den die Liste angesprochen werden kann. Eine unabhängige Kopie einer
Liste erhält man unter anderem auf folgende Weise:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3070057740</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">3070058220</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">111</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[111, 17, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">[2, 17, 9]</span>
</pre></div>
</td></tr></table></div>
<p>In Zeile 1 werden die Listeneinträge von <code class="docutils literal"><span class="pre">a</span></code> in eine neue Liste <code class="docutils literal"><span class="pre">b</span></code> kopiert.
Wie die Zeilen 2-5 zeigen, wird dabei tatsächlich ein neues Listenobjekt erzeugt.
Die beiden Listen <code class="docutils literal"><span class="pre">a</span></code> und <code class="docutils literal"><span class="pre">b</span></code> lassen sich damit unabhängig voneinander verändern,
wie die Zeilen 6-10 zeigen.</p>
<p>In den bisherigen Beispielen waren alle Elemente der Liste vom gleichen Typ, hier speziell
vom Typ Integer. In manchen Programmiersprachen ist dies nicht anders möglich oder nur
unter Verwendung anderer Sprachelemente. In Python können Listenelemente beliebige Objekte
sein, die auch nicht unbedingt vom gleichen Typ sein müssen. Im Abschnitt <a class="reference internal" href="funktionen.html#funcarg"><span class="std std-ref">Funktionen als Argumente von Funktionen</span></a>
hatten wir beispielsweise schon eine Liste kennengelernt, deren Elemente Funktionsnamen
waren. Dadurch, dass nicht alle Elemente von gleichem Typ sein müssen, ist der folgende
Code im Prinzip möglich:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aufgabe</span> <span class="o">=</span> <span class="p">[</span><span class="n">exp</span><span class="p">,</span> <span class="mf">5.2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aufgabe</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">aufgabe</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">181.27224187515122</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span><span class="p">(</span><span class="mf">5.2</span><span class="p">)</span>
<span class="go">181.27224187515122</span>
</pre></div>
</td></tr></table></div>
<p>In Zeile 2 wird eine Liste definiert, die einen Funktionsnamen und einen Float-Wert
enthält. Anschließend werden die Listenelemente in Zeile 3 verwendet, um einen
Funktionswert zu berechnen, der in den Zeilen 5 und 6 überprüft wird. Natürlich ist
es auch möglich, Listen als Listenelemente zu verwenden.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[1, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[2, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
<span class="go">3</span>
</pre></div>
</td></tr></table></div>
<p>In den Zeilen 2 und 4 werden Elemente der Liste <code class="docutils literal"><span class="pre">a</span></code> ausgewählt, wie wir es
schon aus den obigen Beispielen kennen. Das Ergebnis ist hier jeweils eine
Liste, aus der wiederum ein Element ausgewählt werden kann. In Zeile 6 bedeutet
<code class="docutils literal"><span class="pre">a[0][1]</span></code> also, dass das Listenelement <code class="docutils literal"><span class="pre">a[0]</span></code> betrachtet werden soll, eine
Liste von der wiederum das Element mit dem Index <code class="docutils literal"><span class="pre">1</span></code> ausgewählt wird. Auch
wenn die in dem Beispiel definierte Liste <code class="docutils literal"><span class="pre">a</span></code> sehr an eine Matrix erinnert,
ist zu bedenken, dass Python für Listen keine spezifischen Matrixoperationen
zur Verfügung stellt. Entweder definiert man sich solche Operationen selbst
oder man greift auf die Möglichkeiten zurück, die das <a class="reference external" href="http://numpy.scipy.org/">Numpy</a>-Modul bietet, das im Kapitel <a class="reference internal" href="scipy.html#scipy"><span class="std std-ref">Numerische Programmbibliotheken am Beispiel von NumPy/SciPy</span></a> genauer
besprochen wird.</p>
<p>Bis jetzt haben wir bei der Definition einer Liste immer gleich alle Elemente
festgelegt.  Wenn wir nachträglich Elemente hinzufügen wollen, ergibt sich das
Problem, dass wir nicht auf nicht existierende Elemente zugreifen dürfen, da
sonst ein <code class="docutils literal"><span class="pre">IndexError</span></code> geworfen wird.  In manchen Programmiersprachen ist bei
der Definition einer Liste die Größe fest vorzugeben, wobei jedoch nicht
unbedingt jedes Element spezifiziert werden muss. In Python dagegen lässt sich
die Länge der Liste durch Hinzufügen von Elementen verändern. In dem folgenden
Beispiel definieren wir zunächst in Zeile 1 eine leere Liste, an die wir
anschließend Elemente anhängen:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 1, 4, 9, 16]</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference internal" href="_images/weiterfuehrend.png"><img alt="weiterfuehrend" src="_images/weiterfuehrend.png" style="height: 1em;" /></a> <code class="docutils literal"><span class="pre">for</span></code>-Schleifen werden in Python relativ langsam abgearbeitet.
Die Funktionalität des angegebenen Codes lässt sich wesentlich effizienter als
so genannte »list comprehension« realisieren <a class="footnote-reference" href="#list-comprehension" id="id2">[1]</a>, die für unser
Beispiel die folgende Form hat:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 1, 4, 9, 16]</span>
</pre></div>
</div>
<p>Mit Hilfe der <code class="xref py py-func docutils literal"><span class="pre">append()</span></code>-Methode lassen sich also Elemente zu einer Liste
hinzufügen. Sollen zunächst alle Listenelemente gleich sein, so kann man auch
eine Multiplikation verwenden.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span>
</pre></div>
</div>
<p>Mit der <code class="xref py py-func docutils literal"><span class="pre">append()</span></code>-Methode verwandt ist die <code class="xref py py-func docutils literal"><span class="pre">extend()</span></code>-Methode, mit der
man eine Liste an eine andere Liste anhängen kann.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;eins&quot;</span><span class="p">,</span> <span class="s2">&quot;zwei&quot;</span><span class="p">,</span> <span class="s2">&quot;drei&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">[&#39;eins&#39;, &#39;zwei&#39;, &#39;drei&#39;, 1, 2, 3]</span>
</pre></div>
</td></tr></table></div>
<p>Hier wird in Zeile 3 die Liste <code class="docutils literal"><span class="pre">b</span></code> um die Elemente der Liste <code class="docutils literal"><span class="pre">a</span></code> erweitert.
Alternativ kann man zwei Listen mit Hilfe des <code class="docutils literal"><span class="pre">+</span></code>-Operators aneinanderhängen
wie folgendes Beispiel zeigt.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;eins&quot;</span><span class="p">,</span> <span class="s2">&quot;zwei&quot;</span><span class="p">,</span> <span class="s2">&quot;drei&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">+</span><span class="n">a</span>
<span class="go">[&#39;eins&#39;, &#39;zwei&#39;, &#39;drei&#39;, 1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">+</span><span class="mi">3</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">can only concatenate list (not &quot;int&quot;) to list</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">+</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[&#39;eins&#39;, &#39;zwei&#39;, &#39;drei&#39;, 3]</span>
</pre></div>
</td></tr></table></div>
<p>Dabei ist allerdings darauf zu achten, dass beide Objekte Listen sein müssen wie
aus den Zeilen 5-10 zu sehen ist.</p>
<p>Wir wollen im Folgenden nicht auf alle Möglichkeiten eingehen, mit Listen zu
arbeiten <a class="footnote-reference" href="#doc-datastructures" id="id3">[2]</a>, sondern nur noch einige ausgewählte Punkte
ansprechen. Gelegentlich möchte man in einer Liste nach Elementen suchen. Die
<code class="xref py py-func docutils literal"><span class="pre">index()</span></code>-Methode gibt den Index des ersten Auftretens des gesuchten Objekts
an.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Will man nach einem weiteren Auftreten des Objekts suchen, so betrachtet man die
auf das erste Auftreten folgende Unterliste. Das Ergebnis bezeichnet dann jedoch
den betreffenden Index in der Unterliste, nicht in der ursprünglichen Liste.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Ist das gesuchte Objekt nicht in der Liste vorhanden, so wird ein <code class="docutils literal"><span class="pre">ValueError</span></code>
geworfen.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">list.index(x): x not in list</span>
</pre></div>
</div>
<p>Dieser Fall sollte mit einer <code class="docutils literal"><span class="pre">try</span></code> … <code class="docutils literal"><span class="pre">except</span></code>-Konstruktion abgefangen
werden. Der entsprechende Code könnte folgendermaßen aussehen:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
    <span class="k">print</span> <span class="p">(</span><span class="s2">&quot;Objekt nicht gefunden&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Manchmal genügt es auch, danach zu fragen, ob das Objekt in der Liste vorhanden
ist. Hier bekommt man als Antwort entweder <code class="docutils literal"><span class="pre">True</span></code> oder <code class="docutils literal"><span class="pre">False</span></code>. Den Index
des gesuchten Listenelements erfährt man auf diese Weise allerdings nicht.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="ow">in</span> <span class="n">a</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">4</span> <span class="ow">in</span> <span class="n">a</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Zwei Methoden geben keine neue Liste zurück, sondern verändern die aktuelle Liste. So kann
man die Reihenfolge einer Liste umkehren</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[3, 2, 1]</span>
</pre></div>
</div>
<p>oder die Elemente einer Liste sortieren</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
<p>Es sei nur kurz erwähnt, dass im Prinzip auch eine beliebige Sortierfunktion vorgegeben
werden kann, was insbesondere bei nichtnumerischen Listenelementen interessant sein kann.</p>
<p>Zum Abschluss der Diskussion von Listen sei noch einmal kurz an die Verwendung in
<code class="docutils literal"><span class="pre">for</span></code>-Schleifen erinnert. Das folgende Beispiel zeigt eine Anwendung, bei der jedes
Listenelement eine zwei Zahlen umfassende Liste ist.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{} - {} = {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">5 - 3 = 2</span>
<span class="go">2 - 4 = -2</span>
</pre></div>
</td></tr></table></div>
<p>Entsprechend sind in Zeile 2 der <code class="docutils literal"><span class="pre">for</span></code>-Schleife zwei Variable anzugeben, die entsprechend
ihrer Reihenfolge den beiden Zahlen in den Listen zugeordnet werden.</p>
</div>
<div class="section" id="tupel">
<h2>Tupel<a class="headerlink" href="#tupel" title="Link zu dieser Überschrift">¶</a></h2>
<p>Tupel sind ähnlich wie Listen Sequenzen von Objekten beliebigen Typs. Der wesentliche Unterschied
zu Listen besteht darin, dass Tupel unveränderlich sind. Man kann also wie bei Listen auf einzelne
Elemente oder Untersequenzen zugreifen. Es ist jedoch nicht möglich, die Sequenz durch eine
Zuweisung zu verändern.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">19</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="go">(1,)</span>
</pre></div>
</td></tr></table></div>
<p>Im Gegensatz zu Listen, die durch eckige Klammern gekennzeichnet werden, sind
bei Tupeln runde Klammern, wie in Zeile 1 zu sehen ist, zu verwenden. Zugriffe
auf einzelne Elemente, wie in Zeile 2 auf das letzte Element der Sequenz, sowie
auf Untersequenzen sind problemlos möglich. Enthält die Sequenz wie in Zeile 5
nur ein Element, so ist ein Komma vor der schließenden Klammer notwendig.
<code class="docutils literal"><span class="pre">(1)</span></code> würde nicht als Tupel, sondern als geklammerte Eins interpretiert
werden.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">&lt;class &#39;int&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">&lt;class &#39;tuple&#39;&gt;</span>
</pre></div>
</div>
<p>Die folgenden Zeilen zeigen schließlich, dass der Versuch, ein Element des
Tupels zu verändern, mit einem <code class="docutils literal"><span class="pre">TypeError</span></code> beendet wird. Tupel sind also,
wie oben behauptet, tatsächlich unveränderlich.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">23</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
</div>
<div class="section" id="zeichenketten">
<span id="strings"></span><h2>Zeichenketten<a class="headerlink" href="#zeichenketten" title="Link zu dieser Überschrift">¶</a></h2>
<p>Eine wichtige Art von ebenfalls unveränderlichen Sequenzen sind Zeichenketten
oder »Strings«. Ihnen sind wir in verschiedenen Codebeispielen schon
gelegentlich begegnet. Solange die Zeichenkette in eine Zeile passt, wird sie
durch Hochkommas (<code class="docutils literal"><span class="pre">'</span></code>) oder Anführungszeichen (<code class="docutils literal"><span class="pre">&quot;</span></code>) begrenzt.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Hallo&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="s1">&#39;Hallo&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">==</span><span class="n">t</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Diese beiden Strings sind also identisch. Die Möglichkeit Strings auf zwei Arten
zu begrenzen, erleichtert es, Hochkommas oder Anführungszeichen in einem String
unterzubringen. Wenn der Begrenzer jedoch auch innerhalb des Strings auftreten
soll, muss diesem mit einem vorgestellten Backslash (<code class="docutils literal"><span class="pre">\</span></code>) seine Sonderbedeutung
genommen werden.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&quot;God said, </span><span class="se">\&#39;</span><span class="s1">Let Newton be!</span><span class="se">\&#39;</span><span class="s1"> and all was light&quot; (Alexander Pope)&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="s2">&quot;God said, &#39;Let Newton be!&#39; and all was light&quot;</span> <span class="p">(</span><span class="n">Alexander</span> <span class="n">Pope</span><span class="p">)</span>
</pre></div>
</div>
<p>Der Backslash kann auch dazu benutzt werden, dem nachfolgenden Zeichen eine besondere
Bedeutung als Steuerzeichen zu geben. Besonders wichtig ist <code class="docutils literal"><span class="pre">\n</span></code>, das einen
Zeilenumbruch zur Folge hat.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Eine Zeile</span><span class="se">\n</span><span class="s2">und noch eine Zeile&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">Eine Zeile</span>
<span class="go">und noch eine Zeile</span>
</pre></div>
</div>
<p>Wie wir im Kapitel <a class="reference internal" href="funktionen.html#funcdoc"><span class="std std-ref">Dokumentation von Funktionen</span></a> bereits gesehen haben, lassen sich über mehrere
Zeilen gehende Strings auch durch Begrenzung mit jeweils drei Hochkommas oder drei
Anführungszeichen angeben. Dabei sind die Fortsetzungszeilen nicht speziell zu markieren.</p>
<p>Gelegentlich von Nutzen sind <code class="docutils literal"><span class="pre">\t</span></code> für einen horizontalen Tabulator und <code class="docutils literal"><span class="pre">\f</span></code>
für einen Seitenvorschub. Wenn man einen Backslash als normales Zeichen in
einem String benötigt, so kann er entweder mit einem zusätzlichen Backslash
versehen werden (<code class="docutils literal"><span class="pre">\\</span></code>) oder der ganze String durch Voranstellen eines <code class="docutils literal"><span class="pre">r</span></code>
oder eines <code class="docutils literal"><span class="pre">R</span></code> als »raw string« gekennzeichnet werden.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Eine Zeile\nund noch eine Zeile&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&#39;Eine Zeile\\nund noch eine Zeile&#39;</span>
</pre></div>
</div>
<p>Aus der letzten Zeile ersieht man, dass »raw strings« nur für die Eingabe relevant sind.
Für die interne Darstellung verwendet Python dann den doppelten Backslash.</p>
<p>In Python 3 werden grundsätzlich alle Zeichen durch ihren Unicode-Codepoint
identifiziert.  Damit ist eine größtmögliche Anzahl von Zeichen für eine
konsistente Verarbeitung in Strings verfügbar. Im Anhang
<a class="reference internal" href="unicode.html#appendixunicode"><span class="std std-ref">Unicode</span></a> werden einige Informationen zum Unicode-Standard
gegeben. Sollen Strings nicht nur innerhalb eines bestimmten
Python-Programms verarbeitet werden, sondern zum Beispiel von Dateien gelesen
oder in solche geschrieben werden, so müssen die Zeichen kodiert werden. Ein
wichtiges Beispiel hierfür ist die im Unicode-Standard definierte
UTF-8-Kodierung. Solchermaßen kodierte Zeichen werden in Python 3 in Objekten
vom <code class="docutils literal"><span class="pre">bytes</span></code>-Typ abgespeichert. Eine Variante hiervon ist der
<code class="docutils literal"><span class="pre">bytearray</span></code>-Typ, der es, ähnlich wie bei dem im Abschnitt <a class="reference internal" href="#listen"><span class="std std-ref">Listen</span></a>
besprochenen <code class="docutils literal"><span class="pre">list</span></code>-Typ, erlaubt, einzelne Bytes zu modifizieren.
<a class="footnote-reference" href="#bytetype" id="id4">[3]</a> Der folgende Code soll diese Aspekte verdeutlichen.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Prüfung&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">(&#39;P&#39;, &#39;ü&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">b&#39;Pr\xc3\xbcfung&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">195</span>
</pre></div>
</td></tr></table></div>
<p>Die Zahl der Zeichen der in Zeile 1 definierten Zeichenkette wird in den Zeilen 2
und 3 trotz des Umlauts richtig bestimmt. Beim Zugriff auf einzelne Zeichen der
Zeichenkette bekommt man, wie in den Zeilen 4 und 5 zu sehen ist, die
entsprechenden Zeichen.  Man kann nun die Zeichenkette in einer
Binärdarstellung kodieren. Zeile 6 zeigt dies für die Umwandlung in eine
Bytefolge mit Hilfe der UTF-8-Kodierung. Sofern das entsprechende Byte im
Rahmen der auf sieben Bit beruhenden ASCII-Kodierung interpretiert werden kann,
wird diese Darstellung in Zeile 8 verwendet. Der Umlaut <code class="docutils literal"><span class="pre">ü</span></code> wird im Rahmen
der UTF-8-Kodierung jedoch mit Hilfe von zwei Bytes dargestellt, wobei in
beiden Fällen das erste Bit auf Eins gesetzt ist. Daraus ergibt sich die
hexadezimale Darstellung der Bytes, beispielsweise als <code class="docutils literal"><span class="pre">\xc3</span></code>. Wie man Zeile
10 entnehmen kann, gibt die Länge der Bytedarstellung nun nicht mehr
notwendigerweise die Anzahl der ursprünglichen Zeichen an. Greift man auf
einzelne Elemente des <code class="docutils literal"><span class="pre">bytes</span></code>-Objekts zu, so erhält man den dem jeweiligen
Byte entsprechenden Integer. Dies ist in den Zeilen 11-14 zu sehen.</p>
<p>Die folgenden Beispiele zeigen, dass man mit Hilfe des Backslash Unicode-Strings auch
über ihren Codepoint (<code class="docutils literal"><span class="pre">\u</span></code>) oder mit dem Unicodenamen des Zeichens (<code class="docutils literal"><span class="pre">\N</span></code>) definieren
kann.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\u03a8</span><span class="s2">&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&#39;Ψ&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\N{GREEK SMALL LETTER PI}</span><span class="s2">&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&#39;π&#39;</span>
</pre></div>
</div>
<p>Wie wir im vorigen Abschnitt gesehen haben, sind Tupel unveränderlich. Das gilt auch
für Strings:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;abc&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">3085106464L</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">+</span><span class="s2">&quot;def&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">3085106560L</span>
</pre></div>
</div>
<p>Die Identität <code class="docutils literal"><span class="pre">id(s)</span></code> der hier definierten Strings <code class="docutils literal"><span class="pre">s</span></code> ist tatsächlich verschieden. Dieses
Codebeispiel zeigt auch die Anwendung des Additionsoperators. Zudem ist ein Multiplikationsoperator
wie folgt definiert:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;abc&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">*</span><span class="mi">5</span>
<span class="go">&#39;abcabcabcabcabc&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="_images/weiterfuehrend.png"><img alt="weiterfuehrend" src="_images/weiterfuehrend.png" style="height: 1em;" /></a> Die Verwendung des Additionsoperators ist wegen der
Notwendigkeit, ein neues Objekt zu erzeugen, nicht sehr effizient. Will man
viele Teilstrings aneinanderfügen, so verwendet man besser die
<code class="xref py py-func docutils literal"><span class="pre">join()</span></code>-Methode, bei der sich noch eine Zeichenkette angeben lässt, die
zwischen den Elementen der Liste von Strings im Argument der
<code class="xref py py-func docutils literal"><span class="pre">join()</span></code>-Methode eingesetzt wird. So ergibt <code class="docutils literal"><span class="pre">&quot;--&quot;.join([&quot;1&quot;,</span> <span class="pre">&quot;2&quot;,</span> <span class="pre">&quot;3&quot;])</span></code>
das Resultat <code class="docutils literal"><span class="pre">&quot;1--2--3&quot;</span></code>. Will man auf die Einfügung verzichten, so würde
das Beispiel stattdessen <code class="docutils literal"><span class="pre">&quot;&quot;.join([&quot;1&quot;,</span> <span class="pre">&quot;2&quot;,</span> <span class="pre">&quot;3&quot;])</span></code> lauten.</p>
<p>Bei Strings lassen sich wie in Abschnitt <a class="reference internal" href="#listen"><span class="std std-ref">Listen</span></a> beschrieben Teilstrings generieren,
und es lässt sich über die darin enthaltenen Zeichen iterieren wie im Folgenden kurz
demonstriert wird:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Hallo&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&#39;ollaH&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">H</span>
<span class="go">a</span>
<span class="go">l</span>
<span class="go">l</span>
<span class="go">o</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;H&#39;, &#39;a&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]</span>
</pre></div>
</div>
<p>Wie die letzten beiden Zeilen zeigen, kann ein String in eine Liste umgewandelt werden, wobei die
Zeichenkette in die einzelnen Zeichen aufgelöst wird.</p>
<p>Es sei hier nur kurz erwähnt, dass für String-Objekte eine ganze Reihe von Methoden existieren,
von denen hier einige beispielhaft erwähnt werden sollen. <a class="footnote-reference" href="#string-methoden" id="id5">[4]</a></p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;   Hallo   &quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
<span class="go">&#39;Hallo   &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;---Hallo-----&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
<span class="go">&#39;---Hallo&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="go">&#39;---hallo---&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;eins, zwei, drei&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
<span class="go">[&#39;eins&#39;, &#39; zwei&#39;, &#39; drei&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;H&quot;</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;H&quot;</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</td></tr></table></div>
<p>Zeile 2 zeigt, dass Leerzeichen mit <code class="xref py py-func docutils literal"><span class="pre">lstrip()</span></code> links und mit
<code class="xref py py-func docutils literal"><span class="pre">rstrip()</span></code> auch rechts entfernt werden können, wobei sich alternativ
wie in Zeile 5 andere Zeichen entfernen lassen. Zeile 7 zeigt die Umwandlung in
Kleinbuchstaben und in Zeile 10 wird ein String an einem vorgegebenen Zeichen,
hier einem Komma, aufgespalten. Es lassen sich auch eine Reihe von Tests an
Strings durchführen. Zwei Beispiele sind in den Zeilen 12-15 gezeigt.</p>
</div>
<div class="section" id="dictionaries">
<span id="id6"></span><h2>Dictionaries<a class="headerlink" href="#dictionaries" title="Link zu dieser Überschrift">¶</a></h2>
<p>Dictionaries sind assoziative Felder, die Schlüsseln Werte zuordnen. Man kann
sich Dictionaries wie Wörterbücher oder Telefonbücher vorstellen. Betrachten
wir ein Beispiel.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geburtsjahre</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Galilei&quot;</span><span class="p">:</span> <span class="mi">1564</span><span class="p">,</span> <span class="s2">&quot;Maxwell&quot;</span><span class="p">:</span> <span class="mi">1831</span><span class="p">,</span> <span class="s2">&quot;Einstein&quot;</span><span class="p">:</span> <span class="mi">1879</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geburtsjahre</span><span class="p">[</span><span class="s2">&quot;Einstein&quot;</span><span class="p">]</span>
<span class="go">1879</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geburtsjahre</span><span class="p">[</span><span class="s2">&quot;Heisenberg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1901</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geburtsjahre</span>
<span class="go">{&#39;Heisenberg&#39;: 1901, &#39;Maxwell&#39;: 1831, &#39;Galilei&#39;: 1564, &#39;Einstein&#39;: 1879}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geburtsjahre</span><span class="p">[</span><span class="s2">&quot;Newton&quot;</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">KeyError</span>: <span class="n">&#39;Newton&#39;</span>
</pre></div>
</td></tr></table></div>
<p>Jedes Element des Dictionaries besteht aus einem Schlüssel (»key«), der vor dem
Doppelpunkt steht und hier vom Typ String ist, und einem Wert (»value«), der
nach dem Doppelpunkt steht und hier vom Typ Integer ist. Als Schlüssel können
beliebige unveränderliche Objekte verwendet werden, wozu insbesondere die
numerischen Objekte und Strings gehören, aber auch Tupel. Als Werte kommen
dagegen auch veränderliche Objekte, insbesondere Listen, in Frage. Im Gegensatz
zu Listen, die durch eckige Klammern begrenzt werden, und Tupeln, die durch
runde Klammern begrenzt werden, werden die Elemente eines Dictionaries, wie in
Zeile 1 zu sehen ist, von geschweiften Klammern umschlossen.</p>
<p>Der zu einem Schlüssel gehörende Wert kann, wie in Zeile 2 gezeigt, abgefragt
werden. Umgekehrt kann einem existierenden oder noch nicht existierenden
Schlüssel ein Wert zugeordnet werden. Der Schlüssel in Zeile 4 ist noch nicht
im Dictionary vorhanden, so dass die Anzahl der Elemente des Dictionaries mit
der Ausführung der Anweisung um Eins zunimmt. Wird umgekehrt der Wert zu einem
nicht vorhandenen Schlüssel abgefragt, kommt es zu einem <code class="docutils literal"><span class="pre">KeyError</span></code>. Wie der
Vergleich der Zeilen 1 und 6 zeigt, kann sich die Reihenfolge der Elemente in
einem Dictionary ändern.</p>
<p><a class="reference internal" href="_images/weiterfuehrend.png"><img alt="weiterfuehrend" src="_images/weiterfuehrend.png" style="height: 1em;" /></a> Sollte man tatsächlich ein Dictionary mit fester Ordnung
benötigen, so steht in Python 3 auch der Objekttyp <code class="docutils literal"><span class="pre">OrderedDict</span></code> zur
Verfügung, der sich die Reihenfolge merkt, in der dem Dictionary Schlüssel
zugeordnet wurden.</p>
<p>Wie oben schon angedeutet, können als Schlüssel auch Integer verwendet werden.
Worin bestehen die Vorteile gegenüber einer Liste, die ja auch mit Integern
adressiert wird? Stellen wir uns vor, dass wir eine Liste mit den Quadraten der
ersten fünf Primzahlen erstellen wollen. Eine mögliche Lösung wäre die folgende
Liste.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">prim2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">121</span><span class="p">]</span>
</pre></div>
</div>
<p>Ist der Index eine Primzahl, so ist die entsprechende Quadratzahl eingetragen.
Alle anderen Zahlen werden gemäß der Aufgabenstellung nicht benötigt. Es ist
jedoch klar, dass mit diesem Zugang unter Umständen sehr viel Speicherplatz
verschwendet wird. Eine alternative Lösung wäre die Liste:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">prim2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">121</span><span class="p">]</span>
</pre></div>
</div>
<p>Allerdings hat man jetzt keine einfache Zuordnung zwischen Primzahl und Listenindex.
Wo steht beispielsweise das Quadrat der Primzahl <code class="docutils literal"><span class="pre">7</span></code>? Man könnte nun für jeden
Listeneintrag ein Tupel aus der Primzahl und ihrem Quadrat vorsehen, was aber
die Suche aufwendiger macht. Alternativ könnte man eine zweite Liste anlegen, die
zwischen Primzahl und Listenindex vermittelt. Am effizientesten ist aber ein
Dictionary.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">prim2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">7</span><span class="p">:</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">11</span><span class="p">:</span> <span class="mi">121</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prim2</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
<span class="go">49</span>
</pre></div>
</div>
<p>Über die Einträge eines Dictionaries kann iteriert werden. Zur Illustration
verwenden wir wieder unser Geburtsjahr-Dictionary</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">geburtsjahre</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{} wurde im Jahr {} geboren.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">geburtsjahre</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
<span class="gp">...</span>
<span class="go">Einstein wurde im Jahr 1879 geboren.</span>
<span class="go">Heisenberg wurde im Jahr 1901 geboren.</span>
<span class="go">Maxwell wurde im Jahr 1831 geboren.</span>
<span class="go">Galilei wurde im Jahr 1564 geboren.</span>
</pre></div>
</div>
<p>Diese Funktionalität könnte man natürlich auch mit Hilfe einer Liste erhalten.
Allerdings wäre es viel aufwendiger, gezielt auf bestimmte Einträge zuzugreifen.</p>
<p>Es kann auch auf die Existenz eines Schlüssels abgefragt werden:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;Einstein&quot;</span> <span class="ow">in</span> <span class="n">geburtsjahre</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;Newton&quot;</span> <span class="ow">in</span> <span class="n">geburtsjahre</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Anstatt zunächst die Existenz eines Schlüssel zu überprüfen, würde man in Python
allerdings die Behandlung einer eventuell geworfenen <code class="docutils literal"><span class="pre">KeyError</span></code>-Ausnahme
vorziehen.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">physiker</span> <span class="o">=</span> <span class="s2">&quot;Newton&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{} wurde im Jahr {} geboren.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">physiker</span><span class="p">,</span> <span class="n">geburtsjahre</span><span class="p">[</span><span class="n">physiker</span><span class="p">]))</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Das Geburtsjahr von {} ist nicht gespeichert.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">physiker</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">Das Geburtsjahr von Newton ist nicht gespeichert.</span>
</pre></div>
</div>
<p><a class="reference internal" href="_images/weiterfuehrend.png"><img alt="weiterfuehrend" src="_images/weiterfuehrend.png" style="height: 1em;" /></a> Ein zusammengesetzter Datentyp, der hier nur kurz wegen seiner Verwandtschaft
mit Dictionaries erwähnt werden soll, ist das Set, das man sich wie ein Dictionary vorstellen
kann, das nur Schlüssel, aber keine zugehörigen Werte enthält. Auf diese Weise lassen sich
Mengen definieren, die kein Element mehrfach enthalten, und die Mengenoperationen wie Vereingungs-
und Schnittmenge zulassen. Sets haben beispielsweise dann einen großen Vorteil gegenüber Listen,
wenn man überprüfen möchte, ob ein Element in einer gegebenen Menge vorhanden ist.</p>
<p>Im Abschnitt <a class="reference internal" href="datentypen.html#formatierung"><span class="std std-ref">Formatierung von Ausgaben</span></a> hatten wir gesehen, dass man beim Zusammenbauen eines Strings
einzelne Objekte mit Hilfe ihres Namens übergeben kann. Manchmal ist es praktisch, hierzu ein
Dictionary zu verwenden. Stellt man dem Namen des Dictionaries zwei Sternchen voran, so wird
aus dem Dictionary eine Liste von Parametern, die über ihre Namen identifiziert werden, wie man
im folgenden Beispiel sieht.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">zahlworte</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;dt&quot;</span><span class="p">:</span> <span class="s2">&quot;eins&quot;</span><span class="p">,</span> <span class="s2">&quot;en&quot;</span><span class="p">:</span> <span class="s2">&quot;one&quot;</span><span class="p">,</span> <span class="s2">&quot;fr&quot;</span><span class="p">:</span> <span class="s2">&quot;un&quot;</span><span class="p">},</span>
             <span class="p">{</span><span class="s2">&quot;dt&quot;</span><span class="p">:</span> <span class="s2">&quot;zwei&quot;</span><span class="p">,</span> <span class="s2">&quot;en&quot;</span><span class="p">:</span> <span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="s2">&quot;fr&quot;</span><span class="p">:</span> <span class="s2">&quot;deux&quot;</span><span class="p">},</span>
             <span class="p">{</span><span class="s2">&quot;dt&quot;</span><span class="p">:</span> <span class="s2">&quot;drei&quot;</span><span class="p">,</span> <span class="s2">&quot;en&quot;</span><span class="p">:</span> <span class="s2">&quot;three&quot;</span><span class="p">,</span> <span class="s2">&quot;fr&quot;</span><span class="p">:</span> <span class="s2">&quot;trois&quot;</span><span class="p">}]</span>

<span class="k">for</span> <span class="n">zahlwort</span> <span class="ow">in</span> <span class="n">zahlworte</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{dt:7s} | {en:7s} | {fr:7s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">zahlwort</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>Damit ergibt sich die folgende Ausgabe:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">eins</span>    <span class="o">|</span> <span class="n">one</span>     <span class="o">|</span> <span class="n">un</span>
<span class="n">zwei</span>    <span class="o">|</span> <span class="n">two</span>     <span class="o">|</span> <span class="n">deux</span>
<span class="n">drei</span>    <span class="o">|</span> <span class="n">three</span>   <span class="o">|</span> <span class="n">trois</span>
</pre></div>
</div>
<p>Diese Verwendung von Dictionaries führt einerseits zu einer impliziten Dokumentation
des Codes und zum anderen zu einer größeren Stabilität des Codes bei Erweiterungen.</p>
<p>Ähnlich kann man bei Funktionen vorgehen, um Argumente mit Hilfe von
Schlüsselworten zu übergeben. In Abschnitt <a class="reference internal" href="funktionen.html#funckeywords"><span class="std std-ref">Schlüsselworte und Defaultwerte</span></a> hatten wir diese
Möglichkeit für festgelegte Variablennamen kennengelernt. Im folgenden Beispiel
wird gezeigt, wie man Objekte, die mit beliebigen Schlüsselworten übergeben
werden, als Dictionary in der Funktion verfügbar macht.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

<span class="n">test</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">foo</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spam</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>In Zeile 1 wird in der Argumentliste wieder ein durch zwei Sternchen
gekennzeichneter Name eines Dictionaries angegeben, in dem die durch nicht
vorgegebene Schlüsselworte übergebenen Argumente gesammelt werden. Wir nennen
dieses Dictionary hier <code class="docutils literal"><span class="pre">kwargs</span></code> für »keyword arguments«. Ein anderer, im
Rahmen der Vorgaben für Variablennamen erlaubter Name wäre jedoch genauso
möglich. Entsprechend dieser Erläuterungen sieht die Ausgabe der Funktion
folgendermaßen aus:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="mi">0</span>
<span class="n">foo</span> <span class="mi">1</span>
<span class="n">spam</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Neben zusätzlichen, mit Schlüsselworten versehenen Argumenten kann man auch noch
zusätzliche Argumente ohne Schlüsselwort übergeben. Diese werden in einem Tupel
gesammelt und stehen somit für die weitere Verarbeitung zur Verfügung. Dies wird
im folgenden Beispiel an einer Funktion zur Berechnung eines Mittelwerts illustriert.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mittelwert1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="nb">sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="o">+</span><span class="n">x</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">mittelwert1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">3.8</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">))</span>
</pre></div>
</div>
<p>Die Funktion <code class="xref py py-func docutils literal"><span class="pre">mittelwert1()</span></code> hat ein Pflichtargument, das sicherstellt, dass sich
der Mittelwert sinnvoll berechnen lässt. Darüber hinaus kann eine beliebige Anzahl von
Argumenten übergeben werden, die in einem Tupel, hier <code class="docutils literal"><span class="pre">args</span></code> genannt, gesammelt werden.
Im Gegensatz zu dem zuvor besprochenen Dictionary-Argument, das durch zwei vorangestellte
Sternchen gekennzeichnet ist, wird das Tupelargument, <code class="docutils literal"><span class="pre">args</span></code> in unserem Beispiel, nur durch
ein einziges Sternchen gekennzeichnet. Will man sowohl Tupelargumente als auch
Schlüsselwortargumente ermöglichen, so müssen diese genau in dieser Reihenfolge vorkommen.
Im Argument einer Funktionsdefinition könnte also <code class="docutils literal"><span class="pre">f(*args,</span> <span class="pre">**kwargs)</span></code> stehen.</p>
<p>Alternativ zum vorigen Beispiel könnte man natürlich auch wie in folgendem
Beispiel ein einziges Tupelargument vorsehen. Dies impliziert im Aufruf
zusätzliche Klammern.  Außerdem sollte in diesem Beispiel überprüft werden, ob
das Tupel mindestens ein Element enthält.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mittelwert2</span><span class="p">(</span><span class="n">argumente</span><span class="p">):</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">argumente</span><span class="p">:</span>
        <span class="nb">sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="o">+</span><span class="n">x</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">argumente</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">mittelwert2</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">3.8</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">)))</span>
</pre></div>
</div>
<p>Eine weitere Anwendung von Dictionaries betrifft Mehrfachverzweigungen, die wir
bereits im Abschnitt <a class="reference internal" href="kontrollstrukturen.html#ifelse"><span class="std std-ref">Verzweigungen</span></a> diskutiert hatten.  Häufig will man auf eine
Liste von vorgegebenen Werten abprüfen und je nach Wert bestimmte Anweisungen
ausführen. Programmiersprachen stellen hierfür häufig eine so genannte
<code class="docutils literal"><span class="pre">case</span></code>- oder <code class="docutils literal"><span class="pre">switch</span></code>-Anweisung zur Verfügung. In folgendem Pascal-Beispiel
wird abhängig vom Wert der Variable <code class="docutils literal"><span class="pre">i</span></code> eine bestimmte mathematische Funktion
auf die Variable <code class="docutils literal"><span class="pre">x</span></code> angewandt:<a class="footnote-reference" href="#jensen-wirth" id="id7">[5]</a></p>
<div class="highlight-pascal"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">i</span> <span class="k">of</span>
  <span class="mi">0</span><span class="o">:</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="mi">1</span><span class="o">:</span> <span class="n">x</span> <span class="o">:=</span> <span class="nb">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">;</span>
  <span class="mi">2</span><span class="o">:</span> <span class="n">x</span> <span class="o">:=</span> <span class="nb">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">;</span>
  <span class="mi">3</span><span class="o">:</span> <span class="n">x</span> <span class="o">:=</span> <span class="nb">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">;</span>
  <span class="mi">4</span><span class="o">:</span> <span class="n">x</span> <span class="o">:=</span> <span class="nb">ln</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">;</span>
<span class="k">end</span>
</pre></div>
</div>
<p>In Python gibt es die Mehrfachverzweigung in dieser Form nicht. Stattdessen kann man
in solchen Fällen häufig ein Dictionary einsetzen.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func1</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;führe Funktion 1 aus&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">func2</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;führe Funktion 2 aus&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">func3</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;führe Funktion 3 aus&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">default</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;führe Defaultfunktion aus&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">verzweigung</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">alternativen</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">func1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">func2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="n">func3</span><span class="p">}</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">alternativen</span><span class="p">[</span><span class="n">n</span><span class="p">]()</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">default</span><span class="p">()</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.7</span><span class="p">,</span> <span class="s2">&quot;???&quot;</span><span class="p">]:</span>
    <span class="n">verzweigung</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Der wesentliche Teil ist hier in den Zeilen 13-18 in eine Funktion verpackt,
was man jedoch nicht zwingend machen muss. Entscheidend ist, dass man in der
Zeile 14 ein Dictionary definiert, das hier abhängig von dem vorgegebenen Integer
eine Funktion zurückgibt, die dann in Zeile 16 aufgerufen wird. Außerdem ist
in den Zeilen 17 und 18 die Möglichkeit vorgesehen, bei einer anderen als den
im Dictionary vorgesehenen Eingaben eine Defaultfunktion auszuführen. Iteriert
man über die Liste in Zeile 20, so erhält man die folgende Ausgabe:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>führe Funktion 1 aus
führe Defaultfunktion aus
führe Defaultfunktion aus
</pre></div>
</div>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="list-comprehension" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Eine ausführlichere Beschreibung von »list comprehensions«
findet sich in der Python-Dokumentation im
<a class="reference external" href="http://docs.python.org/tutorial/datastructures.html">Kapitel über Datenstrukturen</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="doc-datastructures" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>Eine ausführliche Dokumentation der auf Listen anwendbaren
Methoden findet sich in der Python-Dokumentation im
<a class="reference external" href="http://docs.python.org/tutorial/datastructures.html">Kapitel über Datenstrukturen</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="bytetype" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>Die Datentypen <code class="docutils literal"><span class="pre">bytes</span></code> und <code class="docutils literal"><span class="pre">bytearray</span></code> wurden in Python 3 neu eingeführt.
In Python 2 musste dagegen zwischen Byte-Strings und Unicode-Strings unterschieden werden,
was gelegentlich zu Verwirrung führte. Die für Python 3 getroffene Wahl erlaubt eine
klare Unterscheidung zwischen den beiden Datentypen.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="string-methoden" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td>Für eine ausführlichere Beschreibung siehe den
<a class="reference external" href="http://docs.python.org/library/stdtypes.html#string-methods">Abschnitt über Stringmethoden</a>
im <a class="reference external" href="http://docs.python.org/library/stdtypes.html">Kapitel über eingebaute Datentypen</a> der
Python-Dokumentation.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="jensen-wirth" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[5]</a></td><td>nach: K. Jensen, N. Wirth, <em>PASCAL User Manual and Report</em>, S. 31 (Springer, 1975)</td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="funktionen.html">Funktionen</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index_latex.html">Inhalt</a>
        &#160;&#160;::&#160;&#160;
        <a href="einausgabe.html">Ein- und Ausgabe</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2010-2018, Gert-Ludwig Ingold, Lizenz: CC BY 4.0 International.
      Mit <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.9 erstellt.
    </div>
  </body>
</html>