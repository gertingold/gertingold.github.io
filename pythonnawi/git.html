<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Versionskontrolle mit Git &mdash; Python für Naturwissenschaftler</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2016alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Python für Naturwissenschaftler" href="index.html" />
    <link rel="next" title="Testen von Programmen" href="testing.html" />
    <link rel="prev" title="Erstellung von Grafiken mit matplotlib" href="graphics.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Python für Naturwissenschaftler</span></a></h1>
        <h2 class="heading"><span>Versionskontrolle mit Git</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="graphics.html">Erstellung von Grafiken mit matplotlib</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Inhalt</a>
        &#160;&#160;::&#160;&#160;
        <a href="testing.html">Testen von Programmen</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="versionskontrolle-mit-git">
<span id="vcgit"></span><h1>Versionskontrolle mit Git<a class="headerlink" href="#versionskontrolle-mit-git" title="Permalink zu dieser Überschrift">¶</a></h1>
<div class="section" id="vorbemerkungen">
<h2>Vorbemerkungen<a class="headerlink" href="#vorbemerkungen" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>Bei der Entwicklung von Programmen ist es sinnvoll, ein Versionskontrollsystem
zu verwenden, das es erlaubt, alte Programmversionen systematisch aufzubewahren.
Damit wird es beispielsweise möglich, auf definierte ältere Programmstände
zurückzugehen. Es kann auch sinnvoll sein, die Versionsnummer in vom Programm
erzeugten Daten abzuspeichern. Sollte sich später herausstellen, dass ein
Programm fehlerhaft war, lässt sich auf diese Weise entscheiden, ob Daten von
diesem Fehler betroffen sind oder nicht.</p>
<p>Das erste Versionskontrollsystem war das 1972 entwickelte SCCS. Später folgten
Systeme wie RCS, CVS, Subversion, Git und Mercurial. Bei den aktuellen
Versionskontrollsysteme lassen sich zwei Arten unterscheiden, solche die
die Programmversionen zentral auf einem Server speichern und solche, bei denen
die Programmversionen auf verschiedenen Rechnern verteilt vorliegen können.
Die zweite Variante schließt den Fall mit ein, bei dem die Programmversionen
ausschließlich lokal auf einem Rechner vorgehalten werden. Während bei einem
zentralen Versionskontrollsystem eine Internetverbindung zum Server zwingend
notwendig ist, lassen sich bei einem dezentralen Versionskontrollsystem
Versionierungen auch ohne Internetanbindung vornehmen.</p>
<p>Ein Beispiel für ein modernes zentrales Versionskontrollsystem ist Subversion,
während es sich bei Git und Mercurial um dezentrale Versionskontrollsysteme
handelt. Obwohl Mercurial in Python geschrieben ist, wollen wir uns im Folgenden
mit Git beschäftigen, das sich bei der Entwicklung freier Software großer
Beliebtheit erfreut. Auch wenn es im Detail Unterschiede zwischen Mercurial
und Git gibt, sind die beiden Versionskontrollsysteme einander sehr ähnlich.</p>
<p>Die Entwicklung von Git <a class="footnote-reference" href="#git" id="id1">[1]</a> wurde 2005 von Linus Torvalds begonnen, um ein
geeignetes Versionskontrollsystem zur Entwicklung des Betriebssystemkerns von
Linux zur Verfügung zu haben. Die Anforderungen ergaben sich vor allem daraus,
dass Linux von einer sehr großen Zahl von Programmierern entwickelt wird, und
somit die Übertragung von Code möglichst effizient, aber auch sicher vonstatten
gehen muss. Im Hinblick auf den ersten Aspekt ist ein dezentrales System
wesentlich besser geeignet als ein zentrales System. Detaillierte Informationen
über Git findet man im Internet unter <a class="reference external" href="http://git-scm.com/">git-scm.com</a> im
<a class="reference external" href="http://git-scm.com/documentation">Dokumentationsbereich</a>.</p>
</div>
<div class="section" id="grundlegende-arbeitsschritte">
<h2>Grundlegende Arbeitsschritte<a class="headerlink" href="#grundlegende-arbeitsschritte" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>Um für ein Verzeichnis sowie die darunterliegenden Verzeichnisse eine
Versionierung zu ermöglichen, muss man zunächst die von Git benötigte
Verzeichnisstruktur einrichten. Wir nehmen an, dass in unserem
Benutzerverzeichnis, hier <tt class="docutils literal"><span class="pre">/home/gert</span></tt>, ein Verzeichnis <tt class="docutils literal"><span class="pre">wd</span></tt> für »working
directory« existiert, in dem wir unsere Programmentwicklung durchführen wollen.
Dieses Verzeichnis kann im Prinzip jeden beliebigen geeigneten Namen haben. Wir
gehen zunächst in dieses Verzeichnis und initialisieren es für die Benutzung
mit Git:</p>
<div class="highlight-python"><div class="highlight"><pre>$ cd ~/wd
$ git init
Initialisierte leeres Git-Repository in /home/gert/wd/.git/
</pre></div>
</div>
<p>Im Unterverzeichnis <tt class="docutils literal"><span class="pre">.git</span></tt> werden alle relevanten Daten des Archivs liegen. So
lange dieses Verzeichnis nicht modifiziert wird, was man ohnehin nicht tun
sollte, oder gar gelöscht wird, sind die dort abgelegten Daten und damit alle
Versionen noch verfügbar auch wenn alle anderen Dateien im Arbeitsverzeichnis
gelöscht wurden.</p>
<p>Zu diesem Zeitpunkt ist es sinnvoll, Git auch den vollständigen Namen des
Benutzers und eine zugehörige E-Mail-Adresse mitzuteilen:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git config user.name &quot;Gert-Ludwig Ingold&quot;
$ git config user.email &quot;gert.ingold@physik.uni-augsburg.de&quot;
</pre></div>
</div>
<p>Diese Informationen legt Git im Hauptverzeichnis des Benutzers in der Datei
<tt class="docutils literal"><span class="pre">.gitconfig</span></tt> ab und verwendet sie bei der Übernahme von Dateien in das
Versionsarchiv. Bei Bedarf lassen sich noch weitere Parameter einstellen,
beispielsweise der Editor, den Git aufrufen soll, um dem Benutzer beim
Abspeichern einer neuen Version die Möglichkeit zu geben, einen Kommentar
abzuspeichern.</p>
<p>Um das Arbeiten mit Git zu illustrieren, legen wir anschließend eine erste
Version eines Skripts <tt class="docutils literal"><span class="pre">hello.py</span></tt> mit folgendem Inhalt</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span><span class="p">(</span><span class="s">&#39;Hello world&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>in unserem Verzeichnis an. Nun, aber auch zu jeder anderen Zeit, kann man
den Zustand des Arbeitsverzeichnisses abfragen:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git status
Auf Branch master

Initialer Commit

Unbeobachtete Dateien:
  (benutzen Sie &quot;git add &lt;Datei&gt;...&quot;, um die Änderungen zum Commit vorzumerken)

        hello.py

nichts zum Commit vorgemerkt, aber es gibt unbeobachtete Dateien (benutzen Sie
&quot;git add&quot; zum Beobachten)
</pre></div>
</div>
<p>Git gibt hier eine ganze Menge an Informationen einschließlich eines Vorschlags, was wir als
Nächstes tun könnten. Doch gehen wir der Reihe nach vor. Wir befinden uns laut der ersten
Zeile der Statusausgabe auf dem <tt class="docutils literal"><span class="pre">master</span></tt>-Zweig. Weiter unten werden wir sehen, dass wir
unter Git weitere Zweige anlegen können, in denen wir beispielsweise bestimmte Aspekte eines
Programms weiterentwickeln wollen. Solche Zweige können später auch wieder zusammengeführt
werden. Ferner weist uns Git darauf hin, dass noch keine Dateien versioniert wurden. Dem
unteren Teil der Ausgabe können wir entnehmen, dass die Versionierung in zwei Stufen vor
sich geht und es demzufolge zwei verschiedene Arten von Dateien gibt.</p>
<p>Git hat sehr wohl bemerkt, dass es eine neue Datei <tt class="docutils literal"><span class="pre">hello.py</span></tt> gibt, beachtet diese jedoch
zunächst nicht weiter. Es wird aber am Ende darauf hingewiesen, dass sich Dateien mit
Hilfe von <tt class="docutils literal"><span class="pre">git</span> <span class="pre">add</span></tt> für einen <em>commit</em>, also eine Versionierung, vormerken lassen.
Diese Dateien werden dabei in eine so genannte <em>staging area</em> gebracht. Wir führen diesen
Schritt nun aus und sehen uns den neuen Status an:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git add hello.py
$ git status
Auf Branch master

Initialer Commit

zum Commit vorgemerkte Änderungen:
  (benutzen Sie &quot;git rm --cached &lt;Datei&gt;...&quot; zum Entfernen aus der Staging-Area)

        neue Datei:     hello.py
</pre></div>
</div>
<p>Damit ist unsere Datei nun für einen <em>commit</em> vorgemerkt. Gleichzeitig gibt uns Git einen
Hinweis, wie wir die Datei wieder aus der <em>staging area</em> entfernen können, falls wir doch
keine Versionierung durchführen möchten. Bevor wir mit einem <em>commit</em> fortfahren, wollen
wir zunächst erkunden, was es damit auf sich hat, wenn eine Datei in die <em>staging
area</em> gebracht wird. Dazu sehen wir uns etwas im <tt class="docutils literal"><span class="pre">.git</span></tt>-Unterverzeichnis um:</p>
<div class="highlight-python"><div class="highlight"><pre>$ ls .git
branches  config  description  HEAD  hooks  index  info  objects  refs
$ ls .git/objects
75  info  pack
$ ls .git/objects/75
d9766db981cf4e8c59be50ff01e574581d43fc
</pre></div>
</div>
<p>Im Unterverzeichnis <tt class="docutils literal"><span class="pre">.git/objects/75</span></tt> liegt nun eine Datei mit der etwas
merkwürdigen Bezeichnung <tt class="docutils literal"><span class="pre">d9766db981cf4e8c59be50ff01e574581d43fc</span></tt>. Stellt man
noch die <tt class="docutils literal"><span class="pre">75</span></tt> aus dem Verzeichnisnamen voran, so handelt es sich hierbei um
den so genannten SHA1-Hashwert <a class="footnote-reference" href="#sha1" id="id2">[2]</a> des Objekts, wie wir folgendermaßen
überprüfen können <a class="footnote-reference" href="#so552659" id="id3">[3]</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">sha1</span>
<span class="k">def</span> <span class="nf">githash</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">sha1</span><span class="p">()</span>
    <span class="n">s</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="s">&quot;blob </span><span class="si">%u</span><span class="se">\0</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;utf8&#39;</span><span class="p">))</span>
    <span class="n">s</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

<span class="n">content</span> <span class="o">=</span> <span class="s">&quot;print(&#39;hello world&#39;)</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="k">print</span><span class="p">(</span><span class="n">githash</span><span class="p">(</span><span class="n">content</span><span class="p">))</span>
</pre></div>
</div>
<p>SHA1-Hashwerte bestehen aus 40 Hexadezimalzahlen und charakterisieren den
Inhalt eines Objekts eindeutig. Immerhin gibt es etwa <span class="math">\(10^{48}\)</span>
verschiedene Hashwerte. Git benutzt diesen Hashwert, um schnell Objekte
identifizieren und auf Gleichheit testen zu können.  Meistens genügen die
ersten sechs oder sieben Hexadezimalzahlen, um ein Objekt eindeutig
auszuwählen. Wir können uns den Inhalt des erzeugten Objekts mit Hilfe von Git
folgendermaßen ansehen:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git cat-file -p 75d9766
print(&#39;hello world&#39;)
</pre></div>
</div>
<p>Gemäß der obigen Statusanzeige müssen wir in einem zweiten Schritt noch einen <em>commit</em>
ausführen:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git commit -m &quot;ein erstes Skript&quot;
[master (Basis-Commit) f442b34] ein erstes Skript
 1 file changed, 1 insertion(+)
  create mode 100644 hello.py
</pre></div>
</div>
<p>Mit Hilfe des Arguments <tt class="docutils literal"><span class="pre">-m</span></tt> haben wir noch einen Kommentar angegeben. Ohne dieses
Argument hätte Git einen Editor geöffnet, um die Eingabe eines Kommentars zu ermöglichen.
Es empfiehlt sich im Hinblick auf die Übersichtlichkeit von späteren längeren Ausgaben,
Kommentare auf nicht zu lange Einzeiler zu beschränken.</p>
<p>Was hat sich durch den <em>commit</em> im Verzeichnis der Objekte getan? Wir stellen fest,
dass unser altes Objekt noch vorhanden ist und zwei Objekte hinzugekommen sind:</p>
<div class="highlight-python"><div class="highlight"><pre>$ ls -R .git/objects
.git/objects:
75  ed  f4  info  pack

.git/objects/75:
d9766db981cf4e8c59be50ff01e574581d43fc

.git/objects/ed:
868ae92a213b64de2ad627b27458537539bcdc

.git/objects/f4:
42b34f6400811648a3c94a8ddd5bfb417e1cf5

.git/objects/info:

.git/objects/pack:
</pre></div>
</div>
<p>Sehen wir uns die neuen Objekte an:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git cat-file -p f442b34
tree ed868ae92a213b64de2ad627b27458537539bcdc
author Gert-Ludwig Ingold &lt;gert.ingold@physik.uni-augsburg.de&gt; 1420469345 +0100
committer Gert-Ludwig Ingold &lt;gert.ingold@physik.uni-augsburg.de&gt; 1420469345 +0100

ein erstes Skript
$ git cat-file -p ed868ae
100644 blob 75d9766db981cf4e8c59be50ff01e574581d43fc    hello.py
</pre></div>
</div>
<p>Bei dem ersten Objekt handelt es sich um ein so genanntes <em>commit</em>-Objekt, das neben
den Angaben zur Person und dem Kommentar einen Verweis auf ein <em>tree</em>-Objekt enthält.
Das zweite neue Objekt ist genau dieses <em>tree</em>-Objekt. Es enthält Informationen über
die Objekte, die zu dem betreffenden <em>commit</em> gehören. In unserem Fall ist dies das
uns bereits bekannte <em>blob</em>-Objekt, das den Inhalt unseres Skripts <tt class="docutils literal"><span class="pre">hello.py</span></tt> enthält.</p>
<p>Nun ist es Zeit, unser Skript zu überarbeiten. Im Wort »hello« ersetzen wir das kleine
<tt class="docutils literal"><span class="pre">h</span></tt> durch ein großes <tt class="docutils literal"><span class="pre">H</span></tt>. Git meldet dann den folgenden Status:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git status
Auf Branch master
Änderungen, die nicht zum Commit vorgemerkt sind:
  (benutzen Sie &quot;git add &lt;Datei&gt;...&quot;, um die Änderungen zum Commit vorzumerken)
  (benutzen Sie &quot;git checkout -- &lt;Datei&gt;...&quot;, um die Änderungen im Arbeitsverzeichnis
   zu verwerfen)

        geändert:       hello.py

keine Änderungen zum Commit vorgemerkt (benutzen Sie &quot;git add&quot; und/oder
                                        &quot;git commit -a&quot;)
</pre></div>
</div>
<p>Git hat erkannt, dass wir unser Skript modifiziert haben, führt aber keinerlei
Schritte im Hinblick auf eine Versionierung aus. Diese sind uns überlassen, wobei
uns Git wieder Hilfestellung gibt. Nehmen wir an, dass wir die Änderungen wieder
rückgängig machen wollen. Dies geht wie folgt:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git checkout -- hello.py
$ git status
Auf Branch master
nichts zu committen, Arbeitsverzeichnis unverändert
$ cat hello.py
print(&#39;hello world&#39;)
</pre></div>
</div>
<p>Tatsächlich liegt jetzt wieder die ursprüngliche Fassung des Skripts vor. Da
wir die neue Fassung nicht zur <em>staging area</em> hinzugefügt haben, sind unsere
Änderungen verloren gegangen. Sie können somit nicht wiederhergestellt werden,
wie dies bei einer erfolgten Versionierung der Fall gewesen wäre. Man sollte
daher mit dem beschriebenen Vorgehen besonders vorsichtig sein.</p>
<p>Wir wiederholen nun zur Wiederherstellung der geänderten Version die Umwandlung
des <tt class="docutils literal"><span class="pre">h</span></tt> in einen Großbuchstaben. Anschließend könnten wir wieder die beiden
Schritte <tt class="docutils literal"><span class="pre">git</span> <span class="pre">add</span> <span class="pre">hello.py</span></tt> und <tt class="docutils literal"><span class="pre">git</span> <span class="pre">commit</span></tt> ausführen. Alternativ lässt
sich dies in unserem Fall in einem einzigen Schritt bewältigen:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git commit -a -m &quot;fange mit Großbuchstabe an&quot;
[master 79ff614] fange mit Großbuchstabe an
 1 file changed, 1 insertion(+), 1 deletion(-)
</pre></div>
</div>
<p>Zu beachten ist dabei allerdings, dass auf diese Weise alle Dateien, von denen
Git weiß, dem <em>commit</em> unterzogen werden auch wenn dies vielleicht nicht
gewünscht ist. Es ist daher oft sinnvoll, zunächst explizit mit <tt class="docutils literal"><span class="pre">git</span> <span class="pre">add</span></tt> die
Dateien für einen <em>commit</em> festzulegen. Damit lassen sich gezielt thematisch
zusammenhängende Änderungen auswählen.</p>
<p>Während der Hashwert des ersten <em>commit</em>-Objekts mit <tt class="docutils literal"><span class="pre">f442b34</span></tt> begann, fängt
der Hashwert des neuesten <em>commit</em>-Objekts mit <tt class="docutils literal"><span class="pre">79ff614</span></tt> an. Git bezieht sich
auf Versionen mit Hilfe dieser Hashwerte und nicht mit zeitlich ansteigenden
Versionsnummern. Letzteres ist für ein dezentral organisiertes
Versionskontrollsystem nicht möglich, da im Allgemeinen nicht bekannt sein
kann, ob andere Entwickler in der Zwischenzeit Änderungen am gleichen Projekt
durchgeführt haben.</p>
<p>Einen Überblick über die verschiedenen vorhandenen Versionen kann man sich
folgendermaßen verschaffen:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git log
commit 79ff6141783ca76a5424271d2cede769ff45fb28
Author: Gert-Ludwig Ingold &lt;gert.ingold@physik.uni-augsburg.de&gt;
Date:   Mon Jan 5 16:30:22 2015 +0100

    fange mit Großbuchstabe an

commit f442b34f6400811648a3c94a8ddd5bfb417e1cf5
Author: Gert-Ludwig Ingold &lt;gert.ingold@physik.uni-augsburg.de&gt;
Date:   Mon Jan 5 15:49:05 2015 +0100

    ein erstes Skript
</pre></div>
</div>
<p>Die Ausgabe kann mit Optionen sehr detailliert beeinflusst werden. Wir geben
hier nur ein Beispiel:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git log --pretty=oneline
79ff6141783ca76a5424271d2cede769ff45fb28 fange mit Großbuchstabe an
f442b34f6400811648a3c94a8ddd5bfb417e1cf5 ein erstes Skript
</pre></div>
</div>
<p>Diese einzeilige Ausgabe funktioniert dann besonders gut, wenn man sich wie
weiter oben bereits empfohlen bei der Beschreibung der Version auf eine
einzige, möglichst informative Zeile beschränkt. Informationen über weitere
Optionen von Git-Befehlen erhält man grundsätzlich mit <tt class="docutils literal"><span class="pre">git</span> <span class="pre">help</span></tt> und der
anschließenden Angabe des gewünschten Befehls, in unserem Falle also <tt class="docutils literal"><span class="pre">git</span> <span class="pre">help</span>
<span class="pre">log</span></tt>.</p>
<p>Details zu einer Version, im Folgenden die Version <tt class="docutils literal"><span class="pre">79ff614</span></tt>, erhält man
folgendermaßen:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git show 79ff614
commit 79ff6141783ca76a5424271d2cede769ff45fb28
Author: Gert-Ludwig Ingold &lt;gert.ingold@physik.uni-augsburg.de&gt;
Date:   Mon Jan 5 16:30:22 2015 +0100

    fange mit Großbuchstabe an

diff --git a/hello.py b/hello.py
index 75d9766..f7d1785 100644
--- a/hello.py
+++ b/hello.py
@@ -1 +1 @@
-print(&#39;hello world&#39;)
+print(&#39;Hello world&#39;)
</pre></div>
</div>
<p>Dieser Ausgabe kann man entnehmen, dass das Objekt <tt class="docutils literal"><span class="pre">75d9766...</span></tt> in das
Objekt <tt class="docutils literal"><span class="pre">f7d1785...</span></tt> umgewandelt wurde. Aus den letzten Zeilen kann man die
Details der Änderung ersehen.</p>
<p>Wir hatten weiter oben darauf hingewiesen, dass man im Detail beeinflussen
kann, welche Dateien beim nächsten <em>commit</em> berücksichtigt werden. Dazu
werden die betreffenden Dateien mit einem <tt class="docutils literal"><span class="pre">git</span> <span class="pre">add</span></tt> in die <em>staging area</em>
aufgenommen.  In diesem Zusammenhang kann es passieren, dass man eine Datei
versehentlich zu diesem Index hinzufügt. Im folgenden Beispiel sei dies eine
Datei namens <tt class="docutils literal"><span class="pre">spam.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git add spam.py
$ git status
Auf Branch master
zum Commit vorgemerkte Änderungen:
  (benutzen Sie &quot;git reset HEAD &lt;Datei&gt;...&quot; zum Entfernen aus der Staging-Area)

        neue Datei:     spam.py
</pre></div>
</div>
<p>Diese Datei lässt sich nun wie angegeben wieder aus der <em>staging area</em> entfernen:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git reset HEAD spam.py
$ git status
Auf Branch master
Unbeobachtete Dateien:
  (benutzen Sie &quot;git add &lt;Datei&gt;...&quot;, um die Änderungen zum Commit vorzumerken)

        spam.py

nichts zum Commit vorgemerkt, aber es gibt unbeobachtete Dateien (benutzen Sie
&quot;git add&quot; zum Beobachten)
</pre></div>
</div>
<p>Im Arbeitsverzeichnis ist die Datei <tt class="docutils literal"><span class="pre">spam.py</span></tt> weiterhin vorhanden. Im <tt class="docutils literal"><span class="pre">reset</span></tt>-Befehl
verweist <tt class="docutils literal"><span class="pre">HEAD</span></tt> hier auf die Arbeitsversion im aktuellen Zweig, deren Hashwert
wir somit nicht explizit kennen müssen.</p>
</div>
<div class="section" id="verzweigen-und-zusammenfuhren">
<h2>Verzweigen und Zusammenführen<a class="headerlink" href="#verzweigen-und-zusammenfuhren" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>Bei der Entwicklung von Software ist es häufig sinnvoll, gewisse
Weiterentwicklungen vom Hauptentwicklungsstrang zumindest zeitweise
abzukoppeln. Dies erreicht man durch Verzweigungen. Ein typischer Fall wäre ein
öffentliches Release, das im Hauptzweig zum nächsten Release weiterentwickelt
wird. Daneben kann es aber noch einen Zweig geben, in dem ausschließlich Fehler
des Releases korrigiert und dann wieder veröffentlicht werden. In einem anderen
Szenario behinhaltet der Hauptzweig, der in Git unter dem Namen <em>master</em> läuft,
immer eine lauffähige Version, während zur Entwicklung gewisser Programmaspekte
separate Zweige benutzt werden. Um ein auf diese Weise entwickeltes Feature in
die Version des Hauptzweiges einfließen zu lassen, muss man Zweige auch wieder
zusammenführen können. Das Verzweigen und Zusammenführen geht in Git sehr
einfach, da lediglich Markierungen gesetzt werden. Daher gehört das Verzweigen
und Zusammenführen bei der Arbeit mit Git zu den Standardverfahren, die
regelmäßig zum Einsatz kommen.</p>
<p>Zu Beginn gibt es nur einen Zweig, der, wie wir bereits wissen, den Namen <tt class="docutils literal"><span class="pre">master</span></tt>
besitzt. Im vorigen Kapitel haben wir in diesem Zweig zwei Versionen erzeugt. Eine
graphische Darstellung, die hier mit dem Git-Archive-Betrachter <tt class="docutils literal"><span class="pre">gitg</span></tt> erzeugt
wurde, sieht dann folgendermaßen aus:</p>
<a class="reference internal image-reference" href="_images/gitbranch_01.png"><img alt="_images/gitbranch_01.png" class="align-center" src="_images/gitbranch_01.png" style="width: 12cm;" /></a>
<p>Die Information über die vorhandenen Zweige lässt sich auch direkt auf der
Kommandzeile erhalten. In der folgenden Ausgabe ist zu erkennen, dass es nur
einen Zweig, nämlich <tt class="docutils literal"><span class="pre">master</span></tt> gibt. Der Stern zeigt zudem an, dass wir uns
gerade in diesem Zweig befinden.</p>
<div class="highlight-python"><div class="highlight"><pre>$ git branch
* master
</pre></div>
</div>
<p>Die Situation wird interessanter, wenn wir einen weiteren Zweig anlegen, der
von <tt class="docutils literal"><span class="pre">master</span></tt> abzweigt. Wir nennen ihn <tt class="docutils literal"><span class="pre">develop</span></tt>, da dort die
Programmentwicklung erfolgen soll, während in <tt class="docutils literal"><span class="pre">master</span></tt> immer eine lauffähige
Version enthalten sein soll. Damit ist es unproblematisch, wenn das Programm
im <tt class="docutils literal"><span class="pre">develop</span></tt>-Zweig zeitweise nicht funktionsfähig ist.</p>
<div class="highlight-python"><div class="highlight"><pre>$ git branch develop
$ git branch
  develop
* master
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/gitbranch_02.png"><img alt="_images/gitbranch_02.png" class="align-center" src="_images/gitbranch_02.png" style="width: 12cm;" /></a>
<p>Der neue Zweig <tt class="docutils literal"><span class="pre">develop</span></tt> tritt zunächst nur als weitere Bezeichnung neben
<tt class="docutils literal"><span class="pre">master</span></tt> in Erscheinung. Die Verzweigung wird erst später deutlich werden,
wenn wir Dateien in den jeweiligen Zweigen verändern.</p>
<p>Um nun in <tt class="docutils literal"><span class="pre">develop</span></tt> arbeiten zu können, müssen wir in diesen Zweig wechseln:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git checkout develop
Zu Branch &#39;develop&#39; gewechselt
$ git branch
* develop
  master
</pre></div>
</div>
<p>Der Stern zeigt an, dass der Zweigwechsel tatsächlich vollzogen wurde.</p>
<p>Bearbeitet man nun eine Datei im <tt class="docutils literal"><span class="pre">develop</span></tt>-Zweig und führt ein <em>commit</em> durch,
so wird die Trennung der beiden Zweige deutlich.</p>
<a class="reference internal image-reference" href="_images/gitbranch_03.png"><img alt="_images/gitbranch_03.png" class="align-center" src="_images/gitbranch_03.png" style="width: 12cm;" /></a>
<p>Wir wechseln nun in den <tt class="docutils literal"><span class="pre">master</span></tt>-Zweig zurück und führen ein <em>merge</em>, also eine
Vereinigung von zwei Zweigen durch. Git sucht in diesem Fall nach dem gemeinsamen
Vorfahren der beiden Zweige und baut die im <tt class="docutils literal"><span class="pre">develop</span></tt>-Zweig durchgeführten
Änderungen auch im <tt class="docutils literal"><span class="pre">master</span></tt>-Zweig ein:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git checkout master
Zu Branch &#39;master&#39; gewechselt
$ git merge develop
Aktualisiere 79ff614..79f695b
Fast-forward
 hello.py | 1 +
  1 file changed, 1 insertion(+)
</pre></div>
</div>
<p>Da im <tt class="docutils literal"><span class="pre">master</span></tt>-Zweig in der Zwischenzeit keine Änderungen vorgenommen wurden,
linearisiert Git die Vorgeschichte. Es sind aber nach wie vor beide Zweige
vorhanden.</p>
<a class="reference internal image-reference" href="_images/gitbranch_04.png"><img alt="_images/gitbranch_04.png" class="align-center" src="_images/gitbranch_04.png" style="width: 12cm;" /></a>
<p>Möchte man festhalten, dass die Entwicklung im <tt class="docutils literal"><span class="pre">develop</span></tt>-Zweig durchgeführt
wurde, so kann man dieses so genannte <em>fast forward</em> mit der Option <tt class="docutils literal"><span class="pre">--no-ff</span></tt>
beim Zusammenführen der beiden Zweige verhindern. Um dies zu zeigen, wechseln
wir zunächst in den <tt class="docutils literal"><span class="pre">develop</span></tt>-Zweig.</p>
<div class="highlight-python"><div class="highlight"><pre>$ git checkout develop
Zu Branch &#39;develop&#39; gewechselt
</pre></div>
</div>
<p>Dort führen wir die gewünschten Änderungen und einen anschließenden <em>commit</em> durch.
Nach dem Wechsel in den <tt class="docutils literal"><span class="pre">master</span></tt>-Zweig benutzen wir nun beim Zusammenführen die
Option <tt class="docutils literal"><span class="pre">--no-ff</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>$ git commit -a -m &#39;dreifache Ausgabe&#39;
[develop d2bfce0] dreifache Ausgabe
 1 file changed, 3 insertions(+), 2 deletions(-)
$ git checkout master
Zu Branch &#39;master&#39; gewechselt
$ git merge --no-ff develop
Merge made by the &#39;recursive&#39; strategy.
 hello.py | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)
</pre></div>
</div>
<p>Die folgende Abbildung zeigt, dass die Versionsgeschichte jetzt den Zweig darstellt,
in dem die Änderung tatsächlich erfolgte.</p>
<a class="reference internal image-reference" href="_images/gitbranch_05.png"><img alt="_images/gitbranch_05.png" class="align-center" src="_images/gitbranch_05.png" style="width: 12cm;" /></a>
<p>Genauso wie man Änderungen aus dem <tt class="docutils literal"><span class="pre">develop</span></tt>-Zweig in den <tt class="docutils literal"><span class="pre">master</span></tt>-Zweig übernehmen
kann, kann man auch Änderungen vom <tt class="docutils literal"><span class="pre">master</span></tt>-Zweig in den <tt class="docutils literal"><span class="pre">develop</span></tt>-Zweig übernehmen.
Eine typische Situation besteht darin, dass im <tt class="docutils literal"><span class="pre">master</span></tt>-Zweig ein Fehler korrigiert
wird, der auch in der Entwicklungsversion vorliegt. Zunächst nehmen wir an, dass im
<tt class="docutils literal"><span class="pre">develop</span></tt>-Zweig weiter gearbeitet wird. Im <tt class="docutils literal"><span class="pre">master</span></tt>-Zweig wird der Fehler korrigiert,
so dass jetzt in beiden Zweigen Änderungen vorliegen.</p>
<a class="reference internal image-reference" href="_images/gitbranch_06.png"><img alt="_images/gitbranch_06.png" class="align-center" src="_images/gitbranch_06.png" style="width: 12cm;" /></a>
<p>Um Änderungen aus dem <tt class="docutils literal"><span class="pre">master</span></tt>-Zweig in den <tt class="docutils literal"><span class="pre">develop</span></tt>-Zweig zu übernehmen, wechseln
wir in Letzteren und führen dort ein <em>merge</em> des <tt class="docutils literal"><span class="pre">master</span></tt>-Zweigs durch:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git checkout develop
Zu Branch &#39;develop&#39; gewechselt
$ git merge master
Merge made by the &#39;recursive&#39; strategy.
 hello.py | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
</pre></div>
</div>
<p>Damit sieht unser Verzweigungsschema folgendermaßen aus:</p>
<a class="reference internal image-reference" href="_images/gitbranch_07.png"><img alt="_images/gitbranch_07.png" class="align-center" src="_images/gitbranch_07.png" style="width: 12cm;" /></a>
<p>Um ein neues Feature für ein Programm zu entwickeln, wird häufig ein Zweig vom
<tt class="docutils literal"><span class="pre">develop</span></tt>-Zweig abgespalten und nach der Entwicklung mit Letzterem wieder
zusammengeführt. Sollte die Entwicklung nicht erfolgreich gewesen sein, so
verzichtet man auf die Zusammenführung oder löscht den überflüssig gewordenen
Zweig. Bei dieser Gelegenheit zeigen wir, wie man das Anlegen eines neuen Zweigs
und das Wechseln in diesen Zweig mit einem Kommando erledigen kann:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git checkout -b feature1
Gewechselt zu einem neuen Branch &#39;feature1&#39;
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/gitbranch_08.png"><img alt="_images/gitbranch_08.png" class="align-center" src="_images/gitbranch_08.png" style="width: 12cm;" /></a>
<p>Unabhängig von der Entwicklung im <tt class="docutils literal"><span class="pre">feature1</span></tt>-Zweig kann man nun Änderungen
zwischen dem <tt class="docutils literal"><span class="pre">master</span></tt>- und dem <tt class="docutils literal"><span class="pre">develop</span></tt>-Zweig austauschen:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git branch
  develop
* feature1
  master
$ git checkout master
Zu Branch &#39;master&#39; gewechselt
$ git merge develop
Aktualisiere 70f9136..5b5d1e9
Fast-forward
 foo.py | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 foo.py
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/gitbranch_09.png"><img alt="_images/gitbranch_09.png" class="align-center" src="_images/gitbranch_09.png" style="width: 12cm;" /></a>
<p>Bis jetzt gingen alle Zusammenführungen problemlos von statten. Es kann aber
durchaus zu Konflikten kommen, die sich für Git nicht eindeutig auflösen
lassen. Dann muss der Konflikt von Hand gelöst werden. Um dies zu illustrieren,
führen wir im <tt class="docutils literal"><span class="pre">develop</span></tt>-Zweig eine Änderung ein, die beim Zusammenführen mit
dem <tt class="docutils literal"><span class="pre">feature1</span></tt>-Zweig zu einem Konflikt führt.</p>
<a class="reference internal image-reference" href="_images/gitbranch_10.png"><img alt="_images/gitbranch_10.png" class="align-center" src="_images/gitbranch_10.png" style="width: 14cm;" /></a>
<p>Die folgende Ausgabe zeigt, wie Git einen Konflikt anzeigt. In der konfliktbehafteten
Datei <tt class="docutils literal"><span class="pre">hello.py</span></tt> sind die kritischen Stellen gegenübergestellt. Zunächst wird die
problematische Codestelle in der Arbeitsversion des <tt class="docutils literal"><span class="pre">develop</span></tt>-Zweigs angezeigt.
Getrennt von <tt class="docutils literal"><span class="pre">=======</span></tt> folgt dann der Code aus dem <tt class="docutils literal"><span class="pre">feature1</span></tt>-Zweig, der im
<tt class="docutils literal"><span class="pre">develop</span></tt>-Zweig aufgenommen werden soll.</p>
<div class="highlight-python"><div class="highlight"><pre>$ git branch
* develop
  feature1
  master
$ git merge feature1
automatischer Merge von hello.py
KONFLIKT (Inhalt): Merge-Konflikt in hello.py
Automatischer Merge fehlgeschlagen; beheben Sie die Konflikte und committen Sie
dann das Ergebnis.
$ cat hello.py
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
for n in range(4):
    print(&#39;Hello world!&#39;)
    print(&#39;Hallo Welt!&#39;)
=======
def myfunc1(n):
    for _ in range(3):
        print(&#39;Hello world!&#39;)
        print(&#39;Hallo Welt!&#39;)
&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1
</pre></div>
</div>
<p>In einer solchen Situation muss der Benutzer entscheiden, welche Version die gewünschte
ist. Unter Umständen kann es erwünscht, Teile jeweils aus dem einen oder dem anderen
Zweig zu entnehmen. Hat man eine zufriedenstellende Version erstellt, kann man einen
<em>commit</em> durchführen.</p>
<div class="highlight-python"><div class="highlight"><pre>$ git add hello.py
$ git commit -m&#39;Konflikt behoben&#39;
[develop ef71e70] Konflikt behoben
</pre></div>
</div>
<p>Um abschließend die drei Zweige zu zeigen, die in der Diskussion eine Rolle gespielt haben,
führen wir noch je eine Änderung im <tt class="docutils literal"><span class="pre">master</span></tt>- und im <tt class="docutils literal"><span class="pre">feature1</span></tt>-Zweig durch und erhalten
damit das folgende Bild:</p>
<a class="reference internal image-reference" href="_images/gitbranch_11.png"><img alt="_images/gitbranch_11.png" class="align-center" src="_images/gitbranch_11.png" style="width: 12cm;" /></a>
<p>Der Umstand, dass wir bereits in wenigen Schritten ein relativ komplexes
Verzweigungsdiagramm erhalten haben, legt es inbesondere für größere Projekte
nahe, sich eine Strategie für das Anlegen von Zweigen und die darin
auszuführenden Aufgaben zu überlegen. Bei Projekten mit mehreren Entwicklern ist
andererseits gerade die Möglichkeit, Zweige einzurichten, nützlich, um die anderen
Entwickler nicht unnötig mit Code zu belasten, der nur lokal für einen Entwickler
von Bedeutung ist.</p>
</div>
<div class="section" id="umgang-mit-entfernten-archiven">
<h2>Umgang mit entfernten Archiven<a class="headerlink" href="#umgang-mit-entfernten-archiven" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>Bis jetzt haben wir uns nur mit der Arbeit mit einem lokalen Archiv
beschäftigt. Wenn mehrere Entwickler zusammenarbeiten, muss es jedoch die
Möglichkeit des Austauschs von Code geben. Unter einem zentralen
Versionskontrollsystem wie Subversion dient hierzu das Archiv auf dem zentralen
Server, über den ohnehin die gesamte Versionskontrolle läuft. Auch unter Git
ist es sinnvoll, ein zentrales Archiv zu haben, das jedoch vor allem für den
Datenaustausch und nicht so sehr für die Versionskontrolle herangezogen wird.
Somit benötigt man nur für den Datenaustausch mit dem zentralen Archiv eine
funktionierende Internetanbindung, während die Versionskontrolle auch ohne sie
möglich ist.</p>
<p>Je nachdem welches Protokoll für den Datenzugriff zugelassen ist und welche
Zugriffsrechte man besitzt, kann man auf das zentrale Archiv lesend oder
eventuell auch schreibend zugreifen. In den folgenden Beispielen wollen wir
einen Zugriff per <tt class="docutils literal"><span class="pre">ssh</span></tt>, also <em>secure shell</em>, annehmen, der uns, nach
entsprechender Authentifizierung, sowohl Lese- als auch Schreibzugriff
ermöglicht. Das zentrale Archiv soll auf dem Rechner <tt class="docutils literal"><span class="pre">nonexistent</span></tt> liegen,
der, wie der Name schon andeutet, in Wirklichkeit nicht existiert. Der Name
ist also entsprechend anzupassen. Der Zugriff erfolge über einen Benutzer
namens <tt class="docutils literal"><span class="pre">user</span></tt>. Auch der Benutzername muss an die tatsächlichen Gegebenheiten
angepasst werden.</p>
<p>Als erstes erzeugen wir uns lokal ein Git-Arbeitsverzeichnis, indem wir das
zentrale Archiv klonen. Zur Illustration haben wir dort zunächst wieder nur
eine Version eines einfachen Skripts abgelegt.</p>
<div class="highlight-python"><div class="highlight"><pre>$ git clone ssh://user@nonexistent.physik.uni-augsburg.de/home/user/dummy.git dummy
Klone nach &#39;dummy&#39;...
remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0)
Empfange Objekte: 100% (3/3), Fertig.
Prüfe Konnektivität... Fertig
$ cd dummy
$ git branch -va
* master                96ffbf6 hello world Skript
  remotes/origin/HEAD   -&gt; origin/master
  remotes/origin/master 96ffbf6 hello world Skript
$ cat hello.py
print(&#39;hello world&#39;)
</pre></div>
</div>
<p>Nach dem Wechsel in das Arbeitsverzeichnis sehen wir, dass neben dem gewohnten
<tt class="docutils literal"><span class="pre">master</span></tt>-Zweig noch zwei <tt class="docutils literal"><span class="pre">remote</span></tt>-Zweige existieren. Hierbei handelt es
sich um Zweige, die auf das zentrale Archiv verweisen, das standardmäßig mit
<tt class="docutils literal"><span class="pre">origin</span></tt> bezeichnet wird. Um die <tt class="docutils literal"><span class="pre">remote</span></tt>-Zweige angezeigt zu bekommen,
muss die Option <tt class="docutils literal"><span class="pre">-a</span></tt> angegeben werden. Andernfalls beschränkt sich die
Ausgabe auf die lokal vorhandenen Zweige. Informationen über entfernte Archive
und den zugehörigen Zugriffsweg erhält man mit:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git remote -v
origin  ssh://user@nonexistent.physik.uni-augsburg.de/home/user/dummy.git (fetch)
origin  ssh://user@nonexistent.physik.uni-augsburg.de/home/user/dummy.git (push)
</pre></div>
</div>
<p>Nehmen wir an, dass auf dem zentralen Server eine Datei verändert wurde, so
können wir diese von dort in unser Arbeitsverzeichnis holen:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git fetch origin
remote: Counting objects: 5, done.
remote: Total 3 (delta 0), reused 0 (delta 0)
Entpacke Objekte: 100% (3/3), Fertig.
Von ssh://user@nonexistent.physik.uni-augsburg.de/home/user/dummy.git
   96ffbf6..26f3c10  master     -&gt; origin/master
</pre></div>
</div>
<p>Dabei wird nur der <tt class="docutils literal"><span class="pre">origin</span></tt>-Zweig aktualisiert, wie am Ausrufezeichen, das in
der aktuellen Version von <tt class="docutils literal"><span class="pre">hello.py</span></tt> hinzugefügt wurde, zu sehen ist:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git branch -a
* master
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/master
$ cat hello.py
print(&#39;hello world&#39;)
$ git checkout origin
Note: checking out &#39;origin&#39;.

You are in &#39;detached HEAD&#39; state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b new_branch_name

HEAD ist jetzt bei 26f3c10... mit Ausrufezeichen
$ cat hello.py
print(&#39;hello world!&#39;)
</pre></div>
</div>
<p>Wie uns Git informiert, können wir im <tt class="docutils literal"><span class="pre">origin</span></tt>-Zweig keine Änderungen
vornehmen.  Wir können uns dort aber umsehen und uns auf diese Weise davon
überzeugen, dass das Skript dort das Aufrufezeichen enthält. Die Änderung
können wir wie im vorigen Kapitel beschrieben in den <tt class="docutils literal"><span class="pre">master</span></tt>-Zweig unseres
lokalen Archivs übernehmen:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git checkout master
Vorherige Position von HEAD war 26f3c10... mit Ausrufezeichen
Zu Branch &#39;master&#39; gewechselt
Ihr Branch ist zu &#39;origin/master&#39; um 1 Commit hinterher, und kann vorgespult werden.
  (benutzen Sie &quot;git pull&quot;, um Ihren lokalen Branch zu aktualisieren)
$ git merge origin
Aktualisiere 96ffbf6..26f3c10
Fast-forward
 hello.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
$ cat hello.py
print(&#39;hello world!&#39;)
</pre></div>
</div>
<p>Die Aktualisierung auf den Stand des zentralen Archivs haben wir hier in zwei
Schritten durchgeführt.  Es ist jedoch auch möglich, dies in einem Schritt zu
erledigen. Wir nehmen an, dass ein anderer Entwickler das Skript mit einem
weiteren Ausrufezeichen versehen hat, und führen dann eine so genannte
<em>pull</em>-Operation aus:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git pull origin
remote: Counting objects: 5, done.
remote: Total 3 (delta 0), reused 0 (delta 0)
Entpacke Objekte: 100% (3/3), Fertig.
Von ssh://user@nonexistent.physik.uni-augsburg.de/home/user/dummy.git
   26f3c10..10f6489  master     -&gt; origin/master
Aktualisiere 26f3c10..10f6489
Fast-forward
 hello.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
$ cat hello.py
print(&quot;hello world!!&quot;)
</pre></div>
</div>
<p>Schreibzugriff vorausgesetzt kann man umgekehrt auch neue Dateiversionen im
zentralen Archiv ablegen. Hierzu dient die <em>push</em>-Operation. Hierzu ändern wir
den Ausgabetext unseres Skripts und legen das neue Skript in unser lokales
Archiv. Anschließend kann die Übertragung in das zentrale Archiv erfolgen:</p>
<div class="highlight-python"><div class="highlight"><pre>$ cat hello.py
print &quot;Hallo Welt!!&quot;
$ git commit hello.py -m&quot;deutsche Variante&quot;
[master d2b98d1] deutsche Variante
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git push origin
Zähle Objekte: 3, Fertig.
Schreibe Objekte: 100% (3/3), 290 bytes | 0 bytes/s, Fertig.
Total 3 (delta 0), reused 0 (delta 0)
To ssh://user@nonexistent.physik.uni-augsburg.de/home/user/dummy.git
   10f6489..d2b98d1  master -&gt; master
</pre></div>
</div>
<p>Problematisch wird die Situation, wenn zwischen einer <em>pull</em>-Operation und einer <em>push</em>-Operation ein
anderer Entwickler das zentrale Archiv verändert hat:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git commit hello.py -m&quot;Ausgabe deutsch und englisch&quot;
[master 8e5577d] Ausgabe deutsch und englisch
 1 file changed, 1 insertion(+)
$ git push origin
To ssh://user@nonexistent.physik.uni-augsburg.de/home/user/dummy
 ! [rejected]        master -&gt; master (fetch first)
error: Fehler beim Versenden einiger Referenzen nach
               &#39;ssh://user@nonexistent.physik.uni-augsburg.de/home/user/dummy.git&#39;
Hinweis: Aktualisierungen wurden zurückgewiesen, weil das Remote-Repository Commits
Hinweis: enthält, die lokal nicht vorhanden sind. Das wird üblicherweise durch einen
Hinweis: &quot;push&quot; von Commits auf dieselbe Referenz von einem anderen Repository aus
Hinweis: verursacht. Vielleicht müssen Sie die externen Änderungen zusammenzuführen
Hinweis: (z.B. &#39;git pull ...&#39;) bevor Sie erneut &quot;push&quot; ausführen.
Hinweis: Siehe auch die Sektion &#39;Note about fast-forwards&#39; in &#39;git push --help&#39;
Hinweis: für weitere Details.
</pre></div>
</div>
<p>Wir folgen dem Hinweis und holen uns zunächst die veränderte Version:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git pull origin
remote: Counting objects: 10, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 6 (delta 0), reused 0 (delta 0)
Entpacke Objekte: 100% (6/6), Fertig.
Von ssh://user@nonexistent.physik.uni-augsburg.de/home/user/dummy.git
   d2b98d1..a2e308b  master     -&gt; origin/master
automatischer Merge von hello.py
KONFLIKT (Inhalt): Merge-Konflikt in hello.py
Automatischer Merge fehlgeschlagen; beheben Sie die Konflikte und committen Sie dann
das Ergebnis.
</pre></div>
</div>
<p>Dabei kommt es zu einem Konflikt, da das gleiche Skript in verschiedener Weise verändert wurde.
Zunächst muss nun dieser Konflikt beseitigt werden, damit anschließend die gewünschte Fassung
der Datei versioniert werden kann:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git add hello.py
$ git commit
[master c189281] Merge branch &#39;master&#39; of
   ssh://user@nonexistent.physik.uni-augsburg.de/home/user/dummy.git
</pre></div>
</div>
<p>Anschließend kann diese Version erfolgreich im zentralen Archiv abgelegt werden:</p>
<div class="highlight-python"><div class="highlight"><pre>$ git push origin
Zähle Objekte: 4, Fertig.
Delta compression using up to 4 threads.
Komprimiere Objekte: 100% (2/2), Fertig.
Schreibe Objekte: 100% (4/4), 515 bytes | 0 bytes/s, Fertig.
Total 4 (delta 1), reused 0 (delta 0)
To ssh://user@nonexistent.physik.uni-augsburg.de/home/user/dummy.git
   a2e308b..c189281  master -&gt; master
</pre></div>
</div>
<p>An diesem Beispiel wird deutlich, dass es durchaus problematisch sein kann,
wenn viele Entwickler Schreibzugriff auf ein zentrales Archiv haben. Daher wird
häufig einem breiteren Personenkreis lediglich Lesezugriff gewährt. Nur ein
einzelner Entwickler oder eine kleine Gruppe hat Schreibzugriff auf das
zentrale Archiv und kann so neuen Code dort ablegen. Dies geschieht mit einer
<em>pull</em>-Operation von einem Archiv des Entwicklers, der den Code zur Verfügung
stellt. Hierzu ist wiederum eine Leseberechtigung nötig. Möchte ein Entwickler
bei diesem Verfahren Code für das zentrale Archive zur Verfügung stellen, so
stellt er eine <em>pull</em>-Anfrage (<em>pull request</em>).  Eventuell nach einer
Diskussion und Prüfung entscheidet der Verantwortliche für das zentrale Archiv
über die Aufnahme in das zentrale Archiv und führt die <em>pull</em>-Operation durch
(oder auch nicht). Eine häufig verwendete Infrastruktur, die in dieser Weise
insbesondere auch für die Entwicklung freier Software benutzt wird, ist <a class="reference external" href="http://github.com/">GitHub</a>.</p>
<table class="docutils footnote" frame="void" id="git" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Zur Namensgebung sagte Linus Torvalds unter anderem „I&#8217;m an egoistical bastard, and I name
all my projects after myself. First Linux, now git.“ Die Ironie dieses Satzes wird deutlich
wenn man bedenkt, dass <em>git</em> im Englischen so viel wie Blödmann oder Depp bedeutet.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="sha1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Siehe zum Beispiel <a class="reference external" href="http://en.wikipedia.org/wiki/SHA-1">en.wikipedia.org/wiki/SHA-1</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="so552659" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Der folgende Code basiert auf einem Vorschlag auf <a class="reference external" href="http://stackoverflow.com/questions/552659/assigning-git-sha1s-without-git">stackoverflow.com/questions/552659/assigning-git-sha1s-without-git</a>.</td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="graphics.html">Erstellung von Grafiken mit matplotlib</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Inhalt</a>
        &#160;&#160;::&#160;&#160;
        <a href="testing.html">Testen von Programmen</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012-2016, Gert-Ludwig Ingold.
      Mit <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3 erstellt.
    </div>
  </body>
</html>