<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>NumPy &mdash; Python für Naturwissenschaftler</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2016alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Python für Naturwissenschaftler" href="index.html" />
    <link rel="next" title="Erstellung von Grafiken" href="graphics.html" />
    <link rel="prev" title="Fortgeschrittene Aspekte von Python" href="advancedpython.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Python für Naturwissenschaftler</span></a></h1>
        <h2 class="heading"><span>NumPy</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="advancedpython.html">Fortgeschrittene Aspekte von Python</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Inhalt</a>
        &#160;&#160;::&#160;&#160;
        <a href="graphics.html">Erstellung von Grafiken</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="numpy">
<h1>NumPy<a class="headerlink" href="#numpy" title="Permalink zu dieser Überschrift">¶</a></h1>
<p>In der Vorlesung »Einführung in das Programmieren für Physiker und Naturwissenschaftler«
wurde am Beispiel von NumPy und SciPy eine kurze Einführung in die Benutzung numerischer
Programmbibliotheken gegeben. Dabei wurde an einigen wenigen Beispielen gezeigt, wie man
in Python mit Vektoren und Matrizen arbeiten und einfache Problemstellungen der linearen
Algebra lösen kann. Im Folgenden wollen wir uns etwas genauer mit NumPy beschäftigen, das
die Basis für wichtige wissenschaftliche Programmbibliotheken bildet, wie das
bereits genannte <a class="reference external" href="https://www.scipy.org">SciPy</a>, <a class="reference external" href="http://matplotlib.org">Matplotlib</a>
für die Erstellung von Grafiken, <a class="reference external" href="http://pandas.pydata.org">Pandas</a> für
die Analyse großer Datenmengen, <a class="reference external" href="http://scikit-image.org">Scikit-image</a> für die Bildbearbeitung,
<a class="reference external" href="http://scikit-learn.org">Scikit-learn</a> für maschinenbasiertes Lernen und einige andere
mehr.</p>
<p>Wegen des großen Umfangs der von NumPy zur Verfügung gestellten Funktionalität
werden wir uns auf wesentliche Aspekte beschränken und keine
vollständige Beschreibung anstreben. Bei Bedarf sollte daher die
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/">NumPy Referenzdokumentation</a> herangezogen
werden. Als Informationsquelle sind zudem die <a class="reference external" href="http://scipy-lectures.github.com/">Python Scientific Lecture Notes</a> empfehlenswert. Dort werden auch weitere
Programmbibliotheken diskutiert, die in naturwissenschaftlichen Anwendungen hilfreich
sein können.</p>
<div class="section" id="python-listen-und-matrizen">
<span id="pythonlisten"></span><h2>Python-Listen und Matrizen<a class="headerlink" href="#python-listen-und-matrizen" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>Viele naturwissenschaftliche Problemstellungen lassen sich in natürlicher Weise mit Hilfe
von Vektoren und Matrizen formulieren. Dies kann entweder eine Eigenschaft des ursprünglichen
Problems sein, beispielsweise bei der Beschreibung eines gekoppelten schwingenden Systems
mit Hilfe von gekoppelten Differentialgleichungen. Es kann aber auch vorkommen, dass erst
die numerische Umsetzung zu einer Formulierung in Vektoren und Matrizen führt, zum Beispiel
bei der Diskretisierung einer partiellen Differentialgleichung.</p>
<p>Will man solche Problemstellungen mit den Standardmitteln bearbeiten, die von
Python zur Verfügung gestellt werden, so wird man auf Listen zurückgreifen
müssen. Um eine zweidimensionale Matrix zu definieren, würde man eine Liste von
Listen anlegen und könnte dann durch eine doppelte Indizierung auf ein einzelnes Element
zugreifen.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.4</span><span class="p">,</span> <span class="mf">5.5</span><span class="p">,</span> <span class="mf">6.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">7.7</span><span class="p">,</span> <span class="mf">8.8</span><span class="p">,</span> <span class="mf">9.9</span><span class="p">]]</span>

<span class="gp">In [2]: </span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gr">Out[2]: </span><span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">]</span>

<span class="gp">In [3]: </span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="gr">Out[3]: </span><span class="mf">3.3</span>
</pre></div>
</div>
<p>Das Beispiel erklärt die doppelte Indizierung. Durch den ersten Index, hier <tt class="docutils literal"><span class="pre">[0]</span></tt>, wird
die erste Unterliste ausgewählt, aus der wiederum ein einzelnes Element, hier das dritte,
ausgewählt werden kann.</p>
<p>Eine Zeile kann man entweder wie oben in der Eingabe 2 erhalten oder auch etwas umständlicher mit</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [4]: </span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span>
<span class="gr">Out[4]: </span><span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">]</span>
</pre></div>
</div>
<p>Hier ist explizit angegeben, dass wir alle Elemente der ersten Zeile haben wollen. Ein
enstprechender Zugriff auf eine Spalte funktioniert jedoch nicht:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [5]: </span><span class="n">matrix</span><span class="p">[:][</span><span class="mi">0</span><span class="p">]</span>
<span class="gr">Out[5]: </span><span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">]</span>
</pre></div>
</div>
<p>Hier gibt <tt class="docutils literal"><span class="pre">matrix[:]</span></tt> eine Liste mit allen Unterlisten, also einfach die
ursprüngliche Liste zurück. Somit ist <tt class="docutils literal"><span class="pre">matrix[:][0]</span></tt> nichts anderes als die
erste Unterliste. Wir erhalten also wiederum die erste Zeile und keineswegs die
erste Spalte. Auch wenn es beispielsweise mit Hilfe einer list comprehension
möglich ist, eine Spalte aus einer Matrix zu extrahieren, zeigt das Beispiel,
dass Zeilen und Spalten in einer durch eine Liste dargestellten Matrix nicht in
gleicher Weise behandelt werden können. Für eine Matrix würde man eine
Gleichbehandlung jedoch auf jeden Fall erwarten.</p>
<p>Ein weiterer Nachteil besteht in der Flexibilität von Listen, die ja bekanntlich beliebige
Objekte enthalten können. Python muss daher einen erheblichen Aufwand bei der Verwaltung
von Listen treiben. Dies betrifft alleine schon die Adressierung eines einzelnen Elements.
Andererseits wird diese Flexibilität bei Matrizen überhaupt nicht benötigt, da dort alle
Einträge vom gleichen Datentyp sind. Es sollte also möglich sein, erheblich effizientere
Programme zu schreiben, indem man Matrizen nicht durch Listen darstellt, sondern durch
einen auf diese Aufgabe zugeschnittenen Datentypen. Hierzu greift man auf das von NumPy
zur Verfügung gestellte <tt class="docutils literal"><span class="pre">ndarray</span></tt>-Objekt, also ein N-dimensionales Array, zurück.</p>
</div>
<div class="section" id="numpy-arrays">
<h2>NumPy-Arrays<a class="headerlink" href="#numpy-arrays" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>Bevor wir mit NumPy-Arrays <a class="footnote-reference" href="#array" id="id1">[1]</a> arbeiten können, müssen wir NumPy importieren.
Da der Namensraum von NumPy sehr groß ist, empfiehlt es sich, diesen nicht mit
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">numpy</span> <span class="pre">import</span> <span class="pre">*</span></tt> zu importieren. Auch der Import einzelner Objekte empfiehlt
sich nicht. Importiert man beispielsweise die Sinusfunktion aus NumPy, so ist
weiter unten in einem Pythonskript nicht mehr ohne Weiteres erkennbar, ob es sich
um den Sinus aus NumPy oder aus dem <tt class="docutils literal"><span class="pre">math</span></tt>-Modul handelt. Üblicherweise importiert
man daher NumPy in folgender Weise:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
</pre></div>
</div>
<p>Die Abkürzung <tt class="docutils literal"><span class="pre">np</span></tt> erspart dabei etwas Schreibarbeit, macht aber zugleich die Herkunft
eines Objekts deutlich. Hält man sich an diese Konvention, so trägt man zur Verständlichkeit
des Codes bei.</p>
<p>Um die Eigenschaften von Arrays zu untersuchen, müssen wir zunächst wissen, wie sich ein
Array erzeugen lässt. In NumPy ist es sehr einfach, die Dokumentation nach einem bestimmten
Text zu durchsuchen. Die zahlreichen Möglichkeiten, ein Array zu erzeugen, lassen sich
folgendermaßen erhalten:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [2]: </span><span class="n">np</span><span class="o">.</span><span class="n">lookfor</span><span class="p">(</span><span class="s">&#39;create array&#39;</span><span class="p">)</span>
<span class="go">Search results for &#39;create array&#39;</span>
<span class="go">---------------------------------</span>
<span class="go">numpy.array</span>
<span class="go">    Create an array.</span>
<span class="go">numpy.memmap</span>
<span class="go">    Create a memory-map to an array stored in a *binary* file on disk.</span>
<span class="go">numpy.diagflat</span>
<span class="go">    Create a two-dimensional array with the flattened input as a diagonal.</span>
<span class="go">numpy.fromiter</span>
<span class="go">    Create a new 1-dimensional array from an iterable object.</span>
<span class="go">...</span>
</pre></div>
</div>
<p>Dabei wurde hier nur ein Teil der Ausgabe dargestellt. Gleich der erste Eintrag verrät
uns, wie man aus einer Liste von Listen ein Array erzeugen kann. Details hierzu erhält
man bei Bedarf wie üblich mit <tt class="docutils literal"><span class="pre">help(np.array)</span></tt> oder alternativ mit
<tt class="docutils literal"><span class="pre">np.info(np.array)</span></tt>.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [3]: </span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">   ...:</span>           <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">   ...:</span>           <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="gp">In [4]: </span><span class="n">myarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

<span class="gp">In [5]: </span><span class="n">myarray</span>
<span class="go">Out[5]:</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>

<span class="gp">In [6]: </span><span class="nb">type</span><span class="p">(</span><span class="n">myarray</span><span class="p">)</span>
<span class="gr">Out[6]: </span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span>
</pre></div>
</div>
<p>Ein Array besitzt als wesentliche Bestandteile die Daten im
eigentlichen Sinne, also die Werte der einzelnen Matrixelemente, sowie
Information darüber, wie auf ein spezifisches Matrixelement zugegriffen werden
kann. Die Daten sind im Speicher einfach hintereinander, also in
eindimensionaler Form, abgelegt. Dabei gibt es die Möglichkeit, die Matrix
zeilenweise oder spaltenweise abzuspeichern. Ersteres wird von der
Programmiersprache C verwendet, während die zweite Variante von Fortran
verwendet wird.</p>
<p>Nachdem die Daten strukturlos im Speicher abgelegt sind, müssen
<tt class="docutils literal"><span class="pre">ndarray</span></tt>-Objekte, wie schon erwähnt, neben den Daten auch Informationen
darüber besitzen, wie auf einzelne Matrixelemente zugegriffen wird. Auf diese
Weise lässt sich sehr leicht die Adresse der Daten eines Matrixelements
bestimmen. Zudem ist es möglich, die gleichen Daten im Speicher auf
verschiedene Weise anzusehen. Damit ist es häufig möglich, unnötige
Kopiervorgänge im Speicher zu vermeiden. Andererseits ist es aus diesem Grunde
wichtig zu wissen, ob NumPy im Einzelfall nur eine andere Sicht auf die Daten
zur Verfügung stellt oder tatsächlich ein neues Array erzeugt.</p>
<p>Um die Informationen über die Struktur eines Arrays besser zu verstehen,
definieren wir uns eine Funktion, die einige Attribute des Arrays ausgibt.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [7]: </span><span class="k">def</span> <span class="nf">array_attributes</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">   ...:</span>     <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;ndim&#39;</span><span class="p">,</span> <span class="s">&#39;size&#39;</span><span class="p">,</span> <span class="s">&#39;itemsize&#39;</span><span class="p">,</span> <span class="s">&#39;dtype&#39;</span><span class="p">,</span> <span class="s">&#39;shape&#39;</span><span class="p">,</span> <span class="s">&#39;strides&#39;</span><span class="p">):</span>
<span class="gp">   ...:</span>         <span class="k">print</span><span class="p">(</span><span class="s">&#39;{:8s}: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">attr</span><span class="p">)))</span>
</pre></div>
</div>
<p>Zum Experimentieren mit Arrays ist die <tt class="docutils literal"><span class="pre">arange</span></tt>-Methode sehr praktisch, die
ähnlich wie das uns bereits bekannte <tt class="docutils literal"><span class="pre">range</span></tt> eine Reihe von Zahlen erzeugt,
nun jedoch in einem Array.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [8]: </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>

<span class="gp">In [9]: </span><span class="n">matrix</span>
<span class="gr">Out[9]: </span><span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>

<span class="gp">In [10]: </span><span class="n">array_attributes</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="go">ndim    : 1</span>
<span class="go">size    : 16</span>
<span class="go">itemsize: 8</span>
<span class="go">dtype   : int64</span>
<span class="go">shape   : (16,)</span>
<span class="go">strides : (8,)</span>
</pre></div>
</div>
<p>Das Attribut <tt class="docutils literal"><span class="pre">ndim</span></tt> gibt an, dass wir es mit einem eindimensionalen Array
zu tun haben, während das Attribut <tt class="docutils literal"><span class="pre">size</span></tt> anzeigt, dass das Array insgesamt
16 Elemente besitzt. Jedes Element besitzt den Datentyp (<tt class="docutils literal"><span class="pre">dtype</span></tt>) <tt class="docutils literal"><span class="pre">int64</span></tt>.
Es handelt sich also um 64-Bit-Integers, die eine Größe von 8 Byte (<tt class="docutils literal"><span class="pre">itemsize</span></tt>)
besitzen. Die Attribute können wir auch direkt in der üblichen objektorientierten
Schreibweise ansprechen. Zum Beispiel gibt</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [11]: </span><span class="n">matrix</span><span class="o">.</span><span class="n">nbytes</span>
<span class="gr">Out[11]: </span><span class="mi">128</span>
</pre></div>
</div>
<p>den Speicherplatzbedarf des Arrays in Bytes an.</p>
<p>Für Arrays kommen eine ganze Reihe verschiedener Datentypen in Frage, zum Beispiel
Integers verschiedener Länge (<tt class="docutils literal"><span class="pre">int8</span></tt>, <tt class="docutils literal"><span class="pre">int16</span></tt>, <tt class="docutils literal"><span class="pre">int32</span></tt>, <tt class="docutils literal"><span class="pre">int64</span></tt>) oder
auch ohne Vorzeichen (<tt class="docutils literal"><span class="pre">uint8</span></tt>, ...), Gleitkommazahlen (<tt class="docutils literal"><span class="pre">float16</span></tt>, <tt class="docutils literal"><span class="pre">float32</span></tt>,
<tt class="docutils literal"><span class="pre">float64</span></tt>), komplexe Zahlen (<tt class="docutils literal"><span class="pre">complex64</span></tt>, <tt class="docutils literal"><span class="pre">complex128</span></tt>), Wahrheitswerte
(<tt class="docutils literal"><span class="pre">bool8</span></tt>) und sogar Unicode-Strings als nichtnumerischer Datentyp. Wenn der
Datentyp nicht angegeben oder durch die Konstruktion des Arrays bestimmt ist,
werden die im jeweiligen System standardmäßig verwendeten Gleitkommazahlen
herangezogen, also meistens <tt class="docutils literal"><span class="pre">float64</span></tt>. Bei Integers ist zu beachten, dass
es im Gegensatz zu Python-Integers wegen der endlichen Länge zu einem Überlauf
kommen kann, wie das folgende Beispiel demonstriert.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [12]: </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="go">Out[12]:</span>
<span class="go">array([   1,   11,   21,   31,   41,   51,   61,   71,   81,   91,  101,</span>
<span class="go">        111,  121, -125, -115, -105], dtype=int8)</span>
</pre></div>
</div>
<p><a class="reference internal" href="_images/question.png"><img alt="frage" src="_images/question.png" style="height: 1em;" /></a> Wie kann man diese Ausgabe verstehen?</p>
<p>Besonders interessant sind die beiden Attribute <tt class="docutils literal"><span class="pre">shape</span></tt> und <tt class="docutils literal"><span class="pre">strides</span></tt>. Der
Wert des Attributs <tt class="docutils literal"><span class="pre">shape</span></tt>, in unserem Beispiel das Tupel <tt class="docutils literal"><span class="pre">(16,)</span></tt>, gibt die
Zahl der Elemente in der jeweiligen Dimension an. Um dies besser zu verstehen,
ändern wir dieses Attribut ab, wobei darauf zu achten ist, dass die Zahl der
Elemente des Arrays erhalten bleibt. Wir wandeln das eindimensionale Array mit
16 Elementen in ein 4×4-Array um.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [13]: </span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="gp">In [14]: </span><span class="n">matrix</span>
<span class="go">Out[14]:</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>

<span class="gp">In [15]: </span><span class="n">matrix</span><span class="o">.</span><span class="n">strides</span>
<span class="gr">Out[15]: </span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>Dabei wird deutlich, dass nicht nur die Form (<tt class="docutils literal"><span class="pre">shape</span></tt>) modifiziert wurde, sondern
auch aus dem Tupel <tt class="docutils literal"><span class="pre">(8,)</span></tt> des Attributs <tt class="docutils literal"><span class="pre">strides</span></tt> <a class="footnote-reference" href="#strides" id="id2">[2]</a> das Tupel <tt class="docutils literal"><span class="pre">(32,</span> <span class="pre">8)</span></tt> wurde.
Die <em>strides</em> geben an, um wieviel Bytes man weitergehen muss, um zum nächsten Element
in dieser Dimension zu gelangen. Die folgende Abbildung zeigt dies an einem
kleinen Array.</p>
<a class="reference internal image-reference" href="_images/strides.png"><img alt="_images/strides.png" class="align-center" src="_images/strides.png" style="height: 8cm;" /></a>
<p>Greifen wir speziell den mittleren Fall mit den <em>strides</em> <tt class="docutils literal"><span class="pre">(24,</span> <span class="pre">8)</span></tt> heraus.
Bewegt man sich in einer Zeile der Matrix von Element zu Element, so muss man
im Speicher jeweils um 8 Bytes weitergehen, wenn ein Datentyp <tt class="docutils literal"><span class="pre">int64</span></tt>
vorliegt. Entlang einer Spalte beträgt die Schrittweite dagegen 24 Bytes.</p>
<p><a class="reference internal" href="_images/question.png"><img alt="frage" src="_images/question.png" style="height: 1em;" /></a> Wie verändern sich die <em>strides</em> in dem 16-elementigen Array <tt class="docutils literal"><span class="pre">np.arange(16)</span></tt>,
wenn man einen <tt class="docutils literal"><span class="pre">shape</span></tt> von <tt class="docutils literal"><span class="pre">(2,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">2)</span></tt> wählt?</p>
<p>Für die Anwendung ist es wichtig zu wissen, dass die Manipulation der Attribute
<tt class="docutils literal"><span class="pre">shape</span></tt> und <tt class="docutils literal"><span class="pre">strides</span></tt> nicht die Daten im Speicher verändert. Es wird also
nur eine neue Sicht auf die vorhandenen Daten vermittelt. Dies ist insofern von
Bedeutung als das Kopieren von größeren Datenmengen durchaus mit einem nicht
unerheblichen Zeitaufwand verbunden sein kann.</p>
<p>Um uns davon zu überzeugen, dass tatsächlich kein neues Array erzeugt wird, generieren
wir nochmals ein eindimensionales Array und daraus mit Hilfe von <tt class="docutils literal"><span class="pre">reshape</span></tt> ein
zweidimensionales Array.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [16]: </span><span class="n">m1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>

<span class="gp">In [17]: </span><span class="n">m1</span>
<span class="gr">Out[17]: </span><span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>

<span class="gp">In [18]: </span><span class="n">m2</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="gp">In [19]: </span><span class="n">m2</span>
<span class="go">Out[19]:</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
</pre></div>
</div>
<p>Nun ändern wir das erste Element in dem eindimensionalen Array ab und stellen in der
Tat fest, dass sich diese Änderung auch auf das zweidimensionale Array auswirkt.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [20]: </span><span class="n">m1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span>

<span class="gp">In [21]: </span><span class="n">m1</span>
<span class="gr">Out[21]: </span><span class="n">array</span><span class="p">([</span><span class="mi">99</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>

<span class="gp">In [22]: </span><span class="n">m2</span>
<span class="go">Out[22]:</span>
<span class="go">array([[99,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
</pre></div>
</div>
<p>Eine Matrix lässt sich auch transponieren, ohne dass Matrixelemente im Speicher hin
und her kopiert werden müssen. Stattdessen werden nur die beiden Werte der <em>strides</em>
vertauscht.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [23]: </span><span class="n">m2</span><span class="o">.</span><span class="n">strides</span>
<span class="gr">Out[23]: </span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>

<span class="gp">In [24]: </span><span class="n">m2</span><span class="o">.</span><span class="n">T</span>
<span class="go">Out[24]:</span>
<span class="go">array([[99,  4,  8, 12],</span>
<span class="go">       [ 1,  5,  9, 13],</span>
<span class="go">       [ 2,  6, 10, 14],</span>
<span class="go">       [ 3,  7, 11, 15]])</span>

<span class="gp">In [25]: </span><span class="n">m2</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">strides</span>
<span class="gr">Out[25]: </span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
</pre></div>
</div>
<p>Obwohl die Daten im Speicher nicht verändert wurden, kann man jetzt mit der
transponierten Matrix arbeiten.</p>
<p>Mit Hilfe der Attribute <tt class="docutils literal"><span class="pre">shape</span></tt> und <tt class="docutils literal"><span class="pre">strides</span></tt> lässt sich die Sicht auf ein
Array auf sehr flexible Weise festlegen. Allerdings ist der Benutzer selbst für
die Folgen verantwortlich, wie der zweite Teil des folgenden Beispiels zeigt.
Dazu gehen wir zu unserem ursprünglichen 4×4-Array zurück und verändern das
Attribut <tt class="docutils literal"><span class="pre">strides</span></tt> mit Hilfe der <tt class="docutils literal"><span class="pre">as_strided</span></tt>-Methode.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [26]: </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="gp">In [27]: </span><span class="n">matrix1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>

<span class="gp">In [28]: </span><span class="n">matrix1</span>
<span class="go">Out[28]:</span>
<span class="go">array([[ 0,  2,  4,  6],</span>
<span class="go">       [ 2,  4,  6,  8],</span>
<span class="go">       [ 4,  6,  8, 10],</span>
<span class="go">       [ 6,  8, 10, 12]])</span>

<span class="gp">In [29]: </span><span class="n">matrix2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="gp">In [30]: </span><span class="n">matrix2</span>
<span class="go">Out[30]:</span>
<span class="go">array([[            0,  4294967296,            1,  8589934592],</span>
<span class="go">       [            2, 12884901888,            3, 17179869184],</span>
<span class="go">       [            4, 21474836480,            5, 25769803776],</span>
<span class="go">       [            6, 30064771072,            7, 34359738368]])</span>
</pre></div>
</div>
<p>Im ersten Fall ist der Wert der <em>strides</em> gerade das Doppelte der
Datenbreite, so dass in einer Zeile von einem Wert zum nächsten jeweils ein
Wert im Array übersprungen wird. Beim Übergang von einer Zeile zur nächsten
wird gegenüber dem Beginn der vorherigen Zeile auch nur um zwei Werte
vorangeschritten, so dass sich das gezeigte Resultat ergibt.</p>
<p>Im zweiten Beispiel wurde ein <em>stride</em> gewählt, der nur die Hälfte einer
Datenbreite beträgt. Der berechnete Beginn eines neuen Werts im Speicher liegt
damit nicht an einer Stelle, die einem tatsächlichen Beginn eines Werts
entspricht. Python interpretiert dennoch die erhaltene Information und erzeugt
so das obige Array. In unserem Beispiel erreicht man bei jedem zweiten Wert
wieder eine korrekte Datengrenze. Die Manipulation von <em>strides</em> erfordert also
eine gewisse Sorgfalt, und man ist für eventuelle Fehler selbst verantwortlich.</p>
</div>
<div class="section" id="erzeugung-von-numpy-arrays">
<span id="arrayerzeugung"></span><h2>Erzeugung von NumPy-Arrays<a class="headerlink" href="#erzeugung-von-numpy-arrays" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>NumPy-Arrays lassen sich je nach Bedarf auf verschiedene Arten erzeugen. Die
Basis bildet die <tt class="docutils literal"><span class="pre">ndarray</span></tt>-Methode, auf die man immer zurückgreifen kann.
In den meisten Fällen wird es aber praktischer sein, eine der spezialisierteren
Methoden zu verwenden, die wir im Folgenden besprechen wollen.</p>
<p>Um ein mit Nullen aufgefülltes 2×2-Array zu erzeugen, geht man folgendermaßen
vor:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="n">matrix1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="gp">In [2]: </span><span class="n">matrix1</span><span class="p">,</span> <span class="n">matrix1</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">Out[2]:</span>
<span class="go">(array([[ 0.,  0.],</span>
<span class="go">        [ 0.,  0.]]), dtype(&#39;float64&#39;))</span>
</pre></div>
</div>
<p>Das Tupel im Argument gibt dabei die Form des Arrays vor. Wird der Datentyp der
Einträge nicht weiter spezifiziert, so werden Gleitkommazahlen mit einer Länge
von 8 Bytes verwendet. Man kann aber auch explizit zum Beispiel Integereinträge
verlangen:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [3]: </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
<span class="go">Out[3]:</span>
<span class="go">array([[0, 0],</span>
<span class="go">       [0, 0]])</span>
</pre></div>
</div>
<p>Neben der <tt class="docutils literal"><span class="pre">zeros</span></tt>-Funktion gibt es auch noch die <tt class="docutils literal"><span class="pre">empty</span></tt>-Funktion, die zwar
den benötigten Speicherplatz zur Verfügung stellt, diesen jedoch nicht initialisiert.
Im Allgemeinen werden also die Arrayelemente von den hier im Beispiel gezeigten
abweichen.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [4]: </span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">Out[4]:</span>
<span class="go">array([[  6.91153891e-310,   2.32617410e-316,   6.91153265e-310],</span>
<span class="go">       [  6.91153265e-310,   6.91153265e-310,   6.91153265e-310],</span>
<span class="go">       [  6.91153265e-310,   6.91153265e-310,   3.95252517e-322]])</span>
</pre></div>
</div>
<p>Die <tt class="docutils literal"><span class="pre">empty</span></tt>-Funktion sollte also nur verwendet werden, wenn die Arrayelemente
später noch belegt werden.</p>
<p>Will man alle Elemente eines Arrays mit einem konstanten Wert ungleich Null
füllen, so kann man <tt class="docutils literal"><span class="pre">ones</span></tt> verwenden und das sich ergebende Array mit einem
Faktor multiplizieren.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [5]: </span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">Out[5]:</span>
<span class="go">array([[ 2.,  2.,  2.],</span>
<span class="go">       [ 2.,  2.,  2.]])</span>
</pre></div>
</div>
<p>Häufig benötigt man eine Einheitsmatrix, die man mit Hilfe von <tt class="docutils literal"><span class="pre">identity</span></tt>
erhält:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [6]: </span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Out[6]:</span>
<span class="go">array([[ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.]])</span>
</pre></div>
</div>
<p>Hierbei wird immer eine Diagonalmatrix erzeugt. Will man dies nicht, so kann
man <tt class="docutils literal"><span class="pre">eye</span></tt> verwenden, das nicht nur nicht quadratische Arrays erzeugen kann,
sondern auch die Diagonale nach oben oder unten verschieben lässt.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [7]: </span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">Out[7]:</span>
<span class="go">array([[ 1.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.,  0.]])</span>
</pre></div>
</div>
<p>Zu beachten ist hier, dass die Form des Arrays nicht als Tupel vorgegeben wird,
da ohnehin nur zweidimensionale Arrays erzeugt werden können. Lässt man das
zweite Argument weg, so wird ein quadratisches Array erzeugt. Will man die
Diagonaleinträge verschieben, so gibt man dies mit Hilfe des Parameters <tt class="docutils literal"><span class="pre">k</span></tt> an:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [8]: </span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Out[8]:</span>
<span class="go">array([[ 0.,  1.,  0.,  0.],</span>
<span class="go">       [-1.,  0.,  1.,  0.],</span>
<span class="go">       [ 0., -1.,  0.,  1.],</span>
<span class="go">       [ 0.,  0., -1.,  0.]])</span>
</pre></div>
</div>
<p>Eine Diagonalmatrix mit unterschiedlichen Einträgen lässt sich aus einem
eindimensionalen Array folgendermaßen erzeugen:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [9]: </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">Out[9]:</span>
<span class="go">array([[1, 0, 0, 0],</span>
<span class="go">       [0, 2, 0, 0],</span>
<span class="go">       [0, 0, 3, 0],</span>
<span class="go">       [0, 0, 0, 4]])</span>
</pre></div>
</div>
<p>Dabei lässt sich wie bei der <tt class="docutils literal"><span class="pre">eye</span></tt>-Funktion die Diagonale verschieben.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [10]: </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Out[10]:</span>
<span class="go">array([[0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 2, 0, 0],</span>
<span class="go">       [0, 0, 0, 3, 0],</span>
<span class="go">       [0, 0, 0, 0, 4],</span>
<span class="go">       [0, 0, 0, 0, 0]])</span>
</pre></div>
</div>
<p>Umgekehrt kann man mit der <tt class="docutils literal"><span class="pre">diag</span></tt>-Funktion auch die Diagonalelemente eines
zweidimensionalen Arrays extrahieren.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [11]: </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="gp">In [12]: </span><span class="n">matrix</span>
<span class="go">Out[12]:</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>

<span class="gp">In [13]: </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="gr">Out[13]: </span><span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>
</pre></div>
</div>
<p>Lassen sich die Arrayeinträge als Funktion der Indizes ausdrücken, so kann
man die <tt class="docutils literal"><span class="pre">fromfunction</span></tt>-Funktion verwenden, wie in dem folgenden Beispiel
zu sehen ist, das eine Multiplikationstabelle erzeugt.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [14]: </span><span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
<span class="go">Out[14]:</span>
<span class="go">array([[ 1,  2,  3,  4,  5,  6],</span>
<span class="go">       [ 2,  4,  6,  8, 10, 12],</span>
<span class="go">       [ 3,  6,  9, 12, 15, 18],</span>
<span class="go">       [ 4,  8, 12, 16, 20, 24],</span>
<span class="go">       [ 5, 10, 15, 20, 25, 30],</span>
<span class="go">       [ 6, 12, 18, 24, 30, 36]])</span>
</pre></div>
</div>
<p>Diese Funktion ist nicht auf zweidimensionale Arrays beschränkt.</p>
<p>Bei der Konstruktion von Arrays sind auch Funktionen interessant, die als
Verallgemeinerung der in Python eingebauten Funktion <tt class="docutils literal"><span class="pre">range</span></tt> angesehen werden
können. Ihr Nutzen ergibt sich vor allem aus der Tatsache, dass man gewissen
Funktionen, den universellen Funktionen oder ufuncs in NumPy, die wir im
Abschnitt <a class="reference internal" href="#ufuncs"><em>Universelle Funktionen</em></a> besprechen werden, ganze Arrays als Argumente übergeben
kann. Damit wird eine besonders effiziente Auswertung dieser Funktionen
möglich.</p>
<p>Eindimensionale Arrays lassen sich mit Hilfe von <tt class="docutils literal"><span class="pre">arange</span></tt>, <tt class="docutils literal"><span class="pre">linspace</span></tt> und
<tt class="docutils literal"><span class="pre">logspace</span></tt> erzeugen:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [15]: </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gr">Out[15]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">1.1</span><span class="p">,</span>  <span class="mf">1.2</span><span class="p">,</span>  <span class="mf">1.3</span><span class="p">,</span>  <span class="mf">1.4</span><span class="p">,</span>  <span class="mf">1.5</span><span class="p">,</span>  <span class="mf">1.6</span><span class="p">,</span>  <span class="mf">1.7</span><span class="p">,</span>  <span class="mf">1.8</span><span class="p">,</span>  <span class="mf">1.9</span><span class="p">])</span>
</pre></div>
</div>
<p>Ähnlich wie bei <tt class="docutils literal"><span class="pre">range</span></tt> erzeugt <tt class="docutils literal"><span class="pre">arange</span></tt> aus der Angabe eines Start- und
eines Endwerts sowie einer Schrittweite eine Folge von Werten. Allerdings
können diese auch Gleitkommazahlen sein. Zudem wird statt einer Liste ein Array
erzeugt. Wie bei <tt class="docutils literal"><span class="pre">range</span></tt> ist der Endwert hierin nicht enthalten. Allerdings
können Rundungsfehler zu unerwarteten Effekten führen.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [16]: </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gr">Out[16]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">1.1</span><span class="p">,</span>  <span class="mf">1.2</span><span class="p">,</span>  <span class="mf">1.3</span><span class="p">,</span>  <span class="mf">1.4</span><span class="p">])</span>

<span class="gp">In [17]: </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gr">Out[17]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">1.1</span><span class="p">,</span>  <span class="mf">1.2</span><span class="p">,</span>  <span class="mf">1.3</span><span class="p">,</span>  <span class="mf">1.4</span><span class="p">,</span>  <span class="mf">1.5</span><span class="p">,</span>  <span class="mf">1.6</span><span class="p">])</span>

<span class="gp">In [18]: </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.601</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gr">Out[18]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">1.1</span><span class="p">,</span>  <span class="mf">1.2</span><span class="p">,</span>  <span class="mf">1.3</span><span class="p">,</span>  <span class="mf">1.4</span><span class="p">,</span>  <span class="mf">1.5</span><span class="p">,</span>  <span class="mf">1.6</span><span class="p">])</span>
</pre></div>
</div>
<p>Dieses Problem kann man umgehen, wenn man statt der Schrittweite eine Anzahl
von Punkten in dem gegebenen Intervall vorgibt. Dafür ist <tt class="docutils literal"><span class="pre">linspace</span></tt> eine
geeignete Funktion, sofern die Schrittweite konstant sein soll. Bei Bedarf kann
man sich neben dem Array auch noch die Schrittweite ausgeben lassen. Benötigt
man eine logarithmische Skala, so verwendet man <tt class="docutils literal"><span class="pre">logspace</span></tt>, das den
Exponenten linear zwischen einem Start- und einem Endwert verändert. Die Basis
ist standardmäßig 10, sie kann aber durch Setzen des Parameters <tt class="docutils literal"><span class="pre">base</span></tt> an
spezielle Erfordernisse angepasst werden.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [19]: </span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="gr">Out[19]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">1.1</span><span class="p">,</span>  <span class="mf">1.2</span><span class="p">,</span>  <span class="mf">1.3</span><span class="p">,</span>  <span class="mf">1.4</span><span class="p">,</span>  <span class="mf">1.5</span><span class="p">,</span>  <span class="mf">1.6</span><span class="p">,</span>  <span class="mf">1.7</span><span class="p">,</span>  <span class="mf">1.8</span><span class="p">,</span>  <span class="mf">1.9</span><span class="p">,</span>  <span class="mf">2.</span> <span class="p">])</span>

<span class="gp">In [20]: </span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Out[20]:</span>
<span class="go">(array([ 1.        ,  1.33333333,  1.66666667,  2.        ]),</span>
<span class="go"> 0.3333333333333333)</span>

<span class="gp">In [21]: </span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">Out[21]:</span>
<span class="go">array([    1.        ,     3.98107171,    15.84893192,    63.09573445,</span>
<span class="go">         251.18864315,  1000.        ])</span>

<span class="gp">In [22]: </span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gr">Out[22]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">])</span>
</pre></div>
</div>
<p>Gerade bei der graphischen Darstellung von Funktionen sind <tt class="docutils literal"><span class="pre">linspace</span></tt>
und <tt class="docutils literal"><span class="pre">logspace</span></tt> besonders nützlich. Im folgenden Beispiel verwenden
wir die matplotlib-Bibliothek, die im Abschnitt <a class="reference internal" href="graphics.html#mpl"><em>Erstellung von Grafiken mit matplotlib</em></a> besprochen wird.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [23]: </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="gp">In [24]: </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

<span class="gp">In [25]: </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="gp">In [26]: </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gr">Out[26]: </span><span class="p">[</span><span class="o">&lt;</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">lines</span><span class="o">.</span><span class="n">Line2D</span> <span class="n">at</span> <span class="mh">0x7f3ad50b76a0</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/mpl_1.png"><img alt="_images/mpl_1.png" class="align-center" src="_images/mpl_1.png" style="height: 5cm;" /></a>
<p>Möchte man eine Funktion auf einem Gitter auswerten und benötigt man dazu
separate Arrays für die x- und y-Werte, so hilft <tt class="docutils literal"><span class="pre">meshgrid</span></tt> weiter.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [27]: </span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

<span class="gp">In [28]: </span><span class="n">xvals</span>
<span class="go">Out[28]:</span>
<span class="go">array([[-1,  0,  1],</span>
<span class="go">       [-1,  0,  1],</span>
<span class="go">       [-1,  0,  1]])</span>

<span class="gp">In [29]: </span><span class="n">yvals</span>
<span class="go">Out[29]:</span>
<span class="go">array([[2, 2, 2],</span>
<span class="go">       [3, 3, 3],</span>
<span class="go">       [4, 4, 4]])</span>
</pre></div>
</div>
<p>In diesem Zusammenhang sind auch die Funktionen <tt class="docutils literal"><span class="pre">mgrid</span></tt> und <tt class="docutils literal"><span class="pre">ogrid</span></tt> von
Interesse, die wir im Abschnitt <a class="reference internal" href="#ufuncs"><em>Universelle Funktionen</em></a> besprechen  werden, nachdem wir die
Adressierung von Arrays genauer angesehen haben.</p>
<p>Zur graphischen Darstellung von Daten ist es häufig erforderlich, die Daten
zunächst aus einer Datei einzulesen und in einem Array zu speichern. Neben wir
an, wir hätten eine Datei <tt class="docutils literal"><span class="pre">x_von_t.dat</span></tt> mit folgendem Inhalt:</p>
<div class="highlight-python"><div class="highlight"><pre># Zeit  Ort
   0.0  0.0
   0.1  0.1
   0.2  0.4
   0.3  0.9
</pre></div>
</div>
<p>Hierbei zeigt das <tt class="docutils literal"><span class="pre">#</span></tt>-Zeichen in der ersten Zeile an, dass es sich um eine
Kommentarzeile handelt, die nicht in das Array übernommen werden soll. Unter
Verwendung von <tt class="docutils literal"><span class="pre">loadtxt</span></tt> kann man die Daten nun einlesen:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [30]: </span><span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s">&quot;x_von_t.dat&quot;</span><span class="p">)</span>
<span class="go">Out[30]:</span>
<span class="go">array([[ 0. ,  0. ],</span>
<span class="go">       [ 0.1,  0.1],</span>
<span class="go">       [ 0.2,  0.4],</span>
<span class="go">       [ 0.3,  0.9]])</span>
</pre></div>
</div>
<p>Bei der <tt class="docutils literal"><span class="pre">loadtxt</span></tt>-Funktion lassen sich zum Beispiel das Kommentarzeichen oder
die Trennzeichen zwischen Einträgen konfigurieren. Noch wesentlich flexibler
ist <tt class="docutils literal"><span class="pre">genfromtxt</span></tt>, das es unter anderem erlaubt, Spaltenüberschriften aus der
Datei zu entnehmen oder mit fehlenden Einträgen umzugehen. Für Details wird auf
die <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html">zugehörige Dokumentation</a>
verwiesen.</p>
<p>Abschließend betrachten wir noch kurz die Erzeugung von Zufallszahlen, die man
zum Beispiel für Simulationszwecke benötigt. Statt viele einzelne Zufallszahlen zu
erzeugen ist es häufig effizienter, gleich ein ganzes Array mit Zufallszahlen
zu füllen. Im folgenden Beispiel erzeugen wir ein Array mit zehn im Intervall zwischen
0 und 1 gleich verteilten Pseudozufallszahlen. Reproduzierbar werden die Zahlenwerte,
wenn zunächst ein Startwert für die Berechnung, ein <em>seed</em>, gesetzt wird.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [31]: </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">Out[31]:</span>
<span class="go">array([[ 0.99281469,  0.90376223,  0.81096671,  0.33726814,  0.34463236],</span>
<span class="go">       [ 0.74234766,  0.05862623,  0.49005243,  0.73496906,  0.21421244]])</span>

<span class="gp">In [32]: </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">Out[32]:</span>
<span class="go">array([[ 0.51071925,  0.11952145,  0.12714712,  0.98081263,  0.05736099],</span>
<span class="go">       [ 0.35101524,  0.86407263,  0.80264858,  0.36629556,  0.59562485]])</span>

<span class="gp">In [33]: </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>

<span class="gp">In [34]: </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">Out[34]:</span>
<span class="go">array([[ 0.19151945,  0.62210877,  0.43772774,  0.78535858,  0.77997581],</span>
<span class="go">       [ 0.27259261,  0.27646426,  0.80187218,  0.95813935,  0.87593263]])</span>

<span class="gp">In [35]: </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">Out[35]:</span>
<span class="go">array([[ 0.19151945,  0.62210877,  0.43772774,  0.78535858,  0.77997581],</span>
<span class="go">       [ 0.27259261,  0.27646426,  0.80187218,  0.95813935,  0.87593263]])</span>
</pre></div>
</div>
<p>Die Zufälligkeit der Daten lässt sich graphisch darstellen.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [36]: </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>

<span class="gp">In [37]: </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">hot</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">&#39;none&#39;</span><span class="p">)</span>
<span class="gr">Out[37]: </span><span class="o">&lt;</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">AxesImage</span> <span class="n">at</span> <span class="mh">0x7f4eacf147b8</span><span class="o">&gt;</span>

<span class="gp">In [38]: </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gr">Out[38]: </span><span class="o">&lt;</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colorbar</span><span class="o">.</span><span class="n">Colorbar</span> <span class="n">at</span> <span class="mh">0x7f4eac6a60f0</span><span class="o">&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/mpl_2.png"><img alt="_images/mpl_2.png" class="align-center" src="_images/mpl_2.png" style="height: 5cm;" /></a>
<p>Als Anwendung betrachten wir drei Realisierungen von hundert Würfen eines
Würfels. Dazu erzeugen wir mit <tt class="docutils literal"><span class="pre">randint(1,</span> <span class="pre">7)</span></tt> ganzzahlige Pseudozufallszahlen
zwischen 1 und 6 in einem zweidimensionalen Array der Form <tt class="docutils literal"><span class="pre">(100,</span> <span class="pre">3)</span></tt>. Diese
drei Spalten zu je 100 Zahlen werden jeweils als Histogramm dargestellt.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [14]: </span><span class="n">wuerfe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<span class="gp">In [15]: </span><span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">wuerfe</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">6.5</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="go">Out[15]:</span>
<span class="go">([array([ 14.,  22.,  16.,  12.,  16.,  20.]),</span>
<span class="go">  array([ 20.,  18.,  17.,  14.,  14.,  17.]),</span>
<span class="go">  array([ 12.,  13.,  24.,  16.,  18.,  17.])],</span>
<span class="go"> array([ 0.5,  1.5,  2.5,  3.5,  4.5,  5.5,  6.5]),</span>
<span class="go"> &lt;a list of 3 Lists of Patches objects&gt;)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/mpl_3.png"><img alt="_images/mpl_3.png" class="align-center" src="_images/mpl_3.png" style="height: 5cm;" /></a>
</div>
<div class="section" id="adressierung-von-numpy-arrays">
<h2>Adressierung von NumPy-Arrays<a class="headerlink" href="#adressierung-von-numpy-arrays" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>Die Adressierungsmöglichkeiten für NumPy-Arrays basieren auf der so genannten
<em>slice</em>-Syntax, die wir von Python-Listen her kennen und uns hier noch einmal
kurz in Erinnerung rufen wollen. Einen Ausschnitt aus einer Liste, ein <em>slice</em>,
erhält man durch die Notation <tt class="docutils literal"><span class="pre">[start:stop:step]</span></tt>. Hierbei werden ausgehend
von dem Element mit dem Index <tt class="docutils literal"><span class="pre">start</span></tt>  die Elemente bis vor das Element mit dem
Index <tt class="docutils literal"><span class="pre">stop</span></tt> mit einer Schrittweite <tt class="docutils literal"><span class="pre">step</span></tt> ausgewählt. Wird die Schrittweite
nicht angegeben, so nimmt <tt class="docutils literal"><span class="pre">step</span></tt> den Defaultwert <tt class="docutils literal"><span class="pre">1</span></tt> an. Negative Schrittweiten
führen in der Liste von hinten nach vorne. Fehlen <tt class="docutils literal"><span class="pre">start</span></tt> und/oder
<tt class="docutils literal"><span class="pre">stop</span></tt> so beginnen die ausgewählten Elemente mit dem ersten Element bzw. enden
mit dem letzten Element. Negative Indexwerte werden vom Ende der Liste her genommen.
Das letzte Element kann also mit dem Index <tt class="docutils literal"><span class="pre">-1</span></tt>, das vorletzten Element mit
dem Index <tt class="docutils literal"><span class="pre">-2</span></tt> usw. angesprochen werden. Diese Indizierung funktioniert so auch
für NumPy-Arrays wie die folgenden Beispiele zeigen.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="gp">In [2]: </span><span class="n">a</span>
<span class="gr">Out[2]: </span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>

<span class="gp">In [3]: </span><span class="n">a</span><span class="p">[:]</span>
<span class="gr">Out[3]: </span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>

<span class="gp">In [4]: </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gr">Out[4]: </span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>

<span class="gp">In [5]: </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="gr">Out[5]: </span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

<span class="gp">In [6]: </span><span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="gr">Out[6]: </span><span class="n">array</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>

<span class="gp">In [7]: </span><span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gr">Out[7]: </span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Für mehrdimensionale Arrays wird die Notation direkt verallgemeinert. Im Gegensatz
zu der im Abschnitt <a class="reference internal" href="#pythonlisten"><em>Python-Listen und Matrizen</em></a> beschriebenen Notation für Listen von Listen
werden hier die diversen Indexangaben durch Kommas getrennt zusammengefasst. Einige
Beispiele für zweidimensionale Arrays sollen das illustrieren.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [8]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>

<span class="gp">In [9]: </span><span class="n">a</span>
<span class="go">Out[9]:</span>
<span class="go">array([[ 0,  1,  2,  3,  4,  5],</span>
<span class="go">       [ 6,  7,  8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15, 16, 17],</span>
<span class="go">       [18, 19, 20, 21, 22, 23],</span>
<span class="go">       [24, 25, 26, 27, 28, 29],</span>
<span class="go">       [30, 31, 32, 33, 34, 35]])</span>

<span class="gp">In [10]: </span><span class="n">a</span><span class="p">[:,</span> <span class="p">:]</span>
<span class="go">Out[10]:</span>
<span class="go">array([[ 0,  1,  2,  3,  4,  5],</span>
<span class="go">       [ 6,  7,  8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15, 16, 17],</span>
<span class="go">       [18, 19, 20, 21, 22, 23],</span>
<span class="go">       [24, 25, 26, 27, 28, 29],</span>
<span class="go">       [30, 31, 32, 33, 34, 35]])</span>

<span class="gp">In [11]: </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">Out[11]:</span>
<span class="go">array([[14, 15],</span>
<span class="go">       [20, 21]])</span>

<span class="gp">In [12]: </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">Out[12]:</span>
<span class="go">array([[15, 16],</span>
<span class="go">       [21, 22]])</span>

<span class="gp">In [13]: </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">Out[13]:</span>
<span class="go">array([[ 0,  2,  4],</span>
<span class="go">       [12, 14, 16],</span>
<span class="go">       [24, 26, 28]])</span>

<span class="gp">In [14]: </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">Out[14]:</span>
<span class="go">array([[12, 14, 16],</span>
<span class="go">       [24, 26, 28]])</span>

<span class="gp">In [15]: </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">Out[15]:</span>
<span class="go">array([[12, 13, 14, 15, 16, 17],</span>
<span class="go">       [18, 19, 20, 21, 22, 23]])</span>
</pre></div>
</div>
<p>Wie das letzte Beispiel zeigt, ergänzt NumPy bei fehlenden Indexangaben jeweils
einen Doppelpunkt, so dass alle Elemente ausgewählt werden, die mit den explizit
gemachten Indexangaben konsistent sind.</p>
<p>Will man eine Spalte (oder auch eine Zeile) in einer zweidimensionalen Array auswählen,
so hat man zwei verschiedene Möglichkeiten:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [16]: </span><span class="n">a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Out[16]:</span>
<span class="go">array([[ 0],</span>
<span class="go">       [ 6],</span>
<span class="go">       [12],</span>
<span class="go">       [18],</span>
<span class="go">       [24],</span>
<span class="go">       [30]])</span>

<span class="gp">In [17]: </span><span class="n">a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gr">Out[17]: </span><span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">30</span><span class="p">])</span>
</pre></div>
</div>
<p>Im ersten Fall sorgt die für beide Dimensionen vorhandene Indexnotation dafür,
dass ein zweidimensionales Array erzeugt wird, das die Elemente der ersten
Spalte enthält. Im zweiten Fall wird für die zweite Dimension ein fester Index
angegeben, so dass nun ein eindimensionales Array erzeugt wird, die wiederum
aus den Elementen der ersten Spalte besteht.</p>
<p>In einigen NumPy-Methoden gibt es einen Parameter <tt class="docutils literal"><span class="pre">axis</span></tt>, der die Richtung
in dem Array angibt, in der die Methode ausgeführt werden soll. Die Achsennummer
ergibt sich aus der Position der zugehörigen Indexangabe. Wie man aus den obigen
Beispielen entnehmen kann, verläuft die Achse 0 von oben nach unten, während die
Achse 1 von links nach rechts verläuft. Dies wird auch durch die folgende
Abbildung veranschaulicht.</p>
<a class="reference internal image-reference" href="_images/axes.png"><img alt="_images/axes.png" class="align-center" src="_images/axes.png" style="height: 3cm;" /></a>
<p>Das Aufsummieren von Elementen unserer Beispielmatrix erfolgt dann mit Hilfe
der <tt class="docutils literal"><span class="pre">sum</span></tt>-Methode entweder von oben nach unten, von links nach rechts oder
über alle Elemente.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [18]: </span><span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">Out[18]: </span><span class="n">array</span><span class="p">([</span> <span class="mi">90</span><span class="p">,</span>  <span class="mi">96</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span> <span class="mi">108</span><span class="p">,</span> <span class="mi">114</span><span class="p">,</span> <span class="mi">120</span><span class="p">])</span>

<span class="gp">In [19]: </span><span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gr">Out[19]: </span><span class="n">array</span><span class="p">([</span> <span class="mi">15</span><span class="p">,</span>  <span class="mi">51</span><span class="p">,</span>  <span class="mi">87</span><span class="p">,</span> <span class="mi">123</span><span class="p">,</span> <span class="mi">159</span><span class="p">,</span> <span class="mi">195</span><span class="p">])</span>

<span class="gp">In [20]: </span><span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gr">Out[20]: </span><span class="mi">630</span>
</pre></div>
</div>
<p>Zur Verdeutlichung betrachten wir noch ein dreidimensionales Array das im
Folgenden graphisch dargestellt ist.</p>
<a class="reference internal image-reference" href="_images/array3d.png"><img alt="_images/array3d.png" class="align-center" src="_images/array3d.png" style="height: 5cm;" /></a>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [21]: </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="gp">In [22]: </span><span class="n">b</span>
<span class="go">Out[22]:</span>
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]],</span>

<span class="go">       [[12, 13, 14, 15],</span>
<span class="go">        [16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]]])</span>

<span class="gp">In [23]: </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Out[23]:</span>
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]]])</span>

<span class="gp">In [24]: </span><span class="n">b</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Out[24]:</span>
<span class="go">array([[[ 0,  1,  2,  3]],</span>

<span class="go">       [[12, 13, 14, 15]]])</span>

<span class="gp">In [25]: </span><span class="n">b</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Out[25]:</span>
<span class="go">array([[[ 0],</span>
<span class="go">        [ 4],</span>
<span class="go">        [ 8]],</span>

<span class="go">       [[12],</span>
<span class="go">        [16],</span>
<span class="go">        [20]]])</span>

<span class="gp">In [26]: </span><span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Out[26]:</span>
<span class="go">array([[[ 0],</span>
<span class="go">        [ 4],</span>
<span class="go">        [ 8]],</span>

<span class="go">       [[12],</span>
<span class="go">        [16],</span>
<span class="go">        [20]]])</span>
</pre></div>
</div>
<p>Man sieht hier deutlich, wie je nach Wahl der Achse ein entsprechender Schnitt
durch das als Würfel vorstellbare Array gemacht wird. Das letzte Beispiel zeigt
die Benutzung des Auslassungszeichens <tt class="docutils literal"><span class="pre">...</span></tt> (im Englischen <em>ellipsis</em> genannt).
Es steht für die Anzahl von Doppelpunkten, die nötig sind, um die Indizes für
alle Dimensionen zu spezifizieren. Allerdings funktioniert dies nur beim ersten
Auftreten des Auslassungszeichens, da sonst nicht klar ist, wie viele Indexspezifikation
für jedes Auslassungszeichen einzusetzen sind. Alle weiteren Auslassungszeichen
werden daher durch einen einzelnen Doppelpunkt ersetzt.</p>
<p>Weiter oben hatten wir in einem Beispiel gesehen, dass die Angabe eines festen
Index die Dimension des Arrays effektiv um Eins vermindert. Umgekehrt ist es
auch möglich, eine zusätzliche Dimension der Länge Eins hinzuzufügen. Hierzu
dient <tt class="docutils literal"><span class="pre">newaxis</span></tt>, das an der gewünschten Stelle als Index eingesetzt werden kann.
Die folgenden Beispiele zeigen, wie aus einem eindimensionalen Array so zwei
verschiedene zweidimensionale Arrays konstruiert werden können.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [27]: </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="gp">In [28]: </span><span class="n">c</span>
<span class="gr">Out[28]: </span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

<span class="gp">In [29]: </span><span class="n">c</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="go">Out[29]:</span>
<span class="go">array([[0],</span>
<span class="go">       [1],</span>
<span class="go">       [2],</span>
<span class="go">       [3],</span>
<span class="go">       [4]])</span>

<span class="gp">In [30]: </span><span class="n">c</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
<span class="gr">Out[30]: </span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</pre></div>
</div>
<p>Eine Anwendung hiervon werden wir weiter unten in diesem Kapitel kennenlernen, wenn wir
uns mit der Erweiterung von Arrays auf eine Zielgröße, dem so genannten <em>broadcasting</em>
beschäftigen.</p>
<p>Zunächst wollen wir aber noch eine weitere Indizierungsmethode, das so genannte
<em>fancy indexing</em>, ansprechen. Obwohl es sich hierbei um ein sehr flexibles und
mächtiges Verfahren handelt, sollte man bedenken, dass hier immer eine Kopie des
Arrays erzeugt wird und nicht einfach nur eine neue Sicht auf bereits vorhandene
Daten. Da Letzteres effizienter ist, sollte man <em>fancy indexing</em> in erster Linie in
Situationen einsetzen, in denen das normale Indizieren nicht ausreicht.</p>
<p>Beim <em>fancy indexing</em> werden die möglichen Indizes als Arrays oder zum Beispiel als
Liste, nicht jedoch als Tupel, angegeben. Die Elemente können dabei <em>Integer</em> oder
<em>Boolean</em> sein. Beginnen wir mit dem ersten Fall, wobei wir zunächst von einem
eindimensionalen Array ausgehen.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [31]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>

<span class="gp">In [32]: </span><span class="n">a</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
<span class="gr">Out[32]: </span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>

<span class="gp">In [33]: </span><span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])]</span>
<span class="go">Out[33]:</span>
<span class="go">array([[10, 12],</span>
<span class="go">       [11, 14]])</span>
</pre></div>
</div>
<p>Im ersten Fall werden einzelne Arrayelemente durch Angabe der Indizes ausgewählt,
wobei auch Wiederholungen sowie eine nichtmonotone Wahl von Indizes möglich sind.
Sind die Indizes als Array angegeben, so wird ein Array der gleichen Form erzeugt.</p>
<p>Bei der Auswahl von Elementen aus einem mehrdimensionalen Arrays muss man gegebenenfalls
weitere Indexlisten oder -arrays angeben.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [34]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="gp">In [35]: </span><span class="n">a</span>
<span class="go">Out[35]:</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>

<span class="gp">In [36]: </span><span class="n">a</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="go">Out[36]:</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11]])</span>

<span class="gp">In [37]: </span><span class="n">a</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="gr">Out[37]: </span><span class="n">array</span><span class="p">([</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>
</pre></div>
</div>
<p>Interessant ist die Verwendung von Indexarrays mit Elementen vom Typ <em>Boolean</em>.
Ein solches Indexarray lässt sich zum Beispiel mit Hilfe einer logischen Operation
auf einem Array erzeugen, wie das folgende Beispiel demonstriert. Eine Reihe
von Zufallszahlen soll dabei bei einem Schwellenwert nach unten abgeschnitten
werden.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">threshold</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="k">print</span> <span class="n">a</span>
<span class="k">print</span> <span class="s">&quot;-&quot;</span><span class="o">*</span><span class="mi">30</span>
<span class="n">indexarray</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">threshold</span>
<span class="k">print</span> <span class="n">indexarray</span>
<span class="k">print</span> <span class="s">&quot;-&quot;</span><span class="o">*</span><span class="mi">30</span>
<span class="n">a</span><span class="p">[</span><span class="n">indexarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">threshold</span>
<span class="k">print</span> <span class="n">a</span>
</pre></div>
</td></tr></table></div>
<p>Damit ergibt sich beispielsweise die folgende Ausgabe:</p>
<div class="highlight-python"><div class="highlight"><pre>[ 0.11859559  0.49034494  0.08552061  0.69204077  0.18406457  0.06819091
  0.36785529  0.16873423  0.44615435  0.57774615  0.54327126  0.57381642]
------------------------------
[ True False  True False  True  True False  True False False False False]
------------------------------
[ 0.3         0.49034494  0.3         0.69204077  0.3         0.3
  0.36785529  0.3         0.44615435  0.57774615  0.54327126  0.57381642]
</pre></div>
</div>
<p>In Zeile 5 wird ein Array <tt class="docutils literal"><span class="pre">indexarray</span></tt> erzeugt, das an den Stellen, an denen die Elemente
des Arrays <tt class="docutils literal"><span class="pre">a</span></tt> kleiner als der Schwellwert sind, den Wahrheitswert <tt class="docutils literal"><span class="pre">True</span></tt>
besitzt. In Zeile 8 werden die auf diese Weise indizierten Elemente dann auf
den Schwellwert gesetzt.  Es sei noch angemerkt, dass sich diese Funktionalität
auch direkt mit der <tt class="docutils literal"><span class="pre">clip</span></tt>-Funktion erreichen lässt.</p>
<p>Als Anwendungsbeispiel für die Indizierung von Arrays durch <em>slicing</em> und durch
<em>fancy indexing</em> betrachten wir das Sieb des Eratosthenes zur Bestimmung von
Primzahlen. Die folgende Abbildung illustriert das Prinzip.</p>
<a class="reference internal image-reference" href="_images/eratosthenes.png"><img alt="_images/eratosthenes.png" class="align-center" src="_images/eratosthenes.png" style="height: 6cm;" /></a>
<p>Ausgehend von der Zwei als kleinster Primzahl werden in aufsteigender
Reihenfolge für alle Primzahlen deren Vielfache als Nichtprimzahlen
identifiziert. Dies ist in der Abbildung durch Kreuze in der entsprechenden
Farbe angedeutet. Beim Durchstreichen genügt es, mit dem Quadrat der jeweiligen
Primzahl zu beginnen, da kleinere Vielfache bereits bei der Betrachtung einer
kleineren Primzahl berücksichtigt wurden. So werden nacheinander alle Zahlen
in der Liste identifiziert, die keine Primzahlen sind. Übrig bleiben somit die
gesuchten Primzahlen. Eine Realisierung dieses Verfahrens unter Verwendung der
Möglichkeiten von NumPy könnte folgendermaßen aussehen.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">nmax</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">integers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nmax</span><span class="p">)</span>
<span class="n">is_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">is_prime</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nmax</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_prime</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
        <span class="n">is_prime</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="n">j</span><span class="p">::</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
<span class="k">print</span><span class="p">(</span><span class="n">integers</span><span class="p">[</span><span class="n">is_prime</span><span class="p">])</span>
</pre></div>
</td></tr></table></div>
<p>Als Ergebnis wird am Ende die Liste</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span> <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">5</span>  <span class="mi">7</span> <span class="mi">11</span> <span class="mi">13</span> <span class="mi">17</span> <span class="mi">19</span> <span class="mi">23</span> <span class="mi">29</span> <span class="mi">31</span> <span class="mi">37</span> <span class="mi">41</span> <span class="mi">43</span> <span class="mi">47</span><span class="p">]</span>
</pre></div>
</div>
<p>ausgegeben. Um die Indizierung leicht nachvollziehbar zu machen, enthält das
Array <tt class="docutils literal"><span class="pre">integers</span></tt> der zu untersuchenden Zahlen auch die Null und die Eins.
Nachdem in Zeile 3 zunächst alle Zahlen als potentielle Primzahlen markiert
werden, wird dies in Zeile 4 für die Null und die Eins gleich wieder rückgängig
gemacht. Da das Wegstreichen von Zahlen erst mit dem Quadrat einer Primzahl
beginnt, müssen nur Primzahlen bis zur Wurzel aus der maximalen Zahl <tt class="docutils literal"><span class="pre">nmax</span></tt>
betrachtet werden. In der Schleife der Zeilen 6 und 7 werden für jede dieser
Primzahlen beginnend bei deren Quadrat die Vielfachen der Primzahl bis zum Ende
der Liste zu Nichtprimzahlen erklärt. Die Ausgabe in Zeile 8 benutzt dann <em>fancy
indexing</em> mit Hilfe des booleschen Arrays <tt class="docutils literal"><span class="pre">is_prime</span></tt>, um die tatsächlichen
Primzahlen aus der Liste der potentiellen Primzahlen <tt class="docutils literal"><span class="pre">integers</span></tt> auszuwählen.</p>
<p>In einem Beispiel zum <em>fancy indexing</em> haben wir in der Vergleichsoperation <tt class="docutils literal"><span class="pre">a</span>
<span class="pre">&lt;</span> <span class="pre">threshold</span></tt> ein Array (<tt class="docutils literal"><span class="pre">a</span></tt>) und ein Skalar (<tt class="docutils literal"><span class="pre">threshold</span></tt>) miteinander
verglichen. Wie kann dies funktionieren? Den Vergleich zweier Arrays derselben
Form kann man sinnvoll elementweise definieren.  Soll ein Array mit einem Skalar
verglichen werden, so wird der Skalar von NumPy zunächst mit gleichen Elementen
so erweitert, das ein Array mit der benötigten Form entsteht. Dieser als
<em>broadcasting</em> bezeichnete Prozess kommt beispielsweise auch bei arithmetischen
Operationen zum Einsatz. Die beiden folgenden Anweisungen sind daher äquivalent:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [38]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="gp">In [39]: </span><span class="n">a</span><span class="o">*</span><span class="mi">3</span>
<span class="gr">Out[39]: </span><span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>

<span class="gp">In [40]: </span><span class="n">a</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gr">Out[40]: </span><span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
<p><em>Broadcasting</em> ist genau dann möglich, wenn beim Vergleich der Achsen der
beiden beteiligten Arrays von der letzten Achse beginnend die Länge der Achsen
jeweils gleich ist oder eine Achse die Länge Eins besitzt. Eine Achse der Länge
Eins wird durch Wiederholen der Elemente im erforderlichen Umfang verlängert.
Entsprechendes geschieht beim Hinzufügen von Achsen von vorne, um die
Dimensionen der Arrays identisch zu machen. Die folgende Abbildung illustriert
das <em>broadcasting</em>.</p>
<a class="reference internal image-reference" href="_images/broadcast.png"><img alt="_images/broadcast.png" class="align-center" src="_images/broadcast.png" style="height: 6cm;" /></a>
<p>Hier ist ein Array der Form <tt class="docutils literal"><span class="pre">(3,</span> <span class="pre">4)</span></tt> vorgegeben. Für ein Array der Form
<tt class="docutils literal"><span class="pre">(1,)</span></tt> wird die Länge auf die Länge der Achse 1 des ersten Array, also 4,
erweitert. Zudem wird eine weitere Achse 0 mit der gleichen Länge wie im
ursprünglichen Array hinzugefügt. Geht man von einem Array der Form <tt class="docutils literal"><span class="pre">(4,)</span></tt>
aus, so muss nur noch in gleicher Weise die Achse 0 hinzugefügt werden.  Dagegen
genügt ein Array der Form <tt class="docutils literal"><span class="pre">(3,)</span></tt> nicht den Bedingungen des <em>broadcasting</em>, da
die Achse weder die Länge Eins noch die Länge der Achse 1 des ursprünglichen
Arrays besitzt. Anders ist dies bei einem Array der Form <tt class="docutils literal"><span class="pre">(3,</span> <span class="pre">1)</span></tt>, bei dem nur
die Länge der Achse 1 auf 4 erhöht werden muss.</p>
<p>Betrachten wir abschließend noch entsprechende Codebeispiele.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [41]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">12.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="gp">In [42]: </span><span class="n">a</span>
<span class="go">Out[42]:</span>
<span class="go">array([[  0.,   1.,   2.,   3.],</span>
<span class="go">       [  4.,   5.,   6.,   7.],</span>
<span class="go">       [  8.,   9.,  10.,  11.]])</span>

<span class="gp">In [43]: </span><span class="n">a</span><span class="o">+</span><span class="mf">1.</span>
<span class="go">Out[43]:</span>
<span class="go">array([[  1.,   2.,   3.,   4.],</span>
<span class="go">       [  5.,   6.,   7.,   8.],</span>
<span class="go">       [  9.,  10.,  11.,  12.]])</span>

<span class="gp">In [44]: </span><span class="n">a</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Out[44]:</span>
<span class="go">array([[  1.,   2.,   3.,   4.],</span>
<span class="go">       [  5.,   6.,   7.,   8.],</span>
<span class="go">       [  9.,  10.,  11.,  12.]])</span>

<span class="gp">In [45]: </span><span class="n">a</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">---------------------------------------------------------------------------</span>
<span class="go">ValueError                                Traceback (most recent call last)</span>
<span class="go">&lt;ipython-input-7-1b5c4daa3b16&gt; in &lt;module&gt;()</span>
<span class="go">----&gt; 1 a+np.ones(3)</span>

<span class="go">ValueError: operands could not be broadcast together with shapes (3,4) (3,)</span>

<span class="gp">In [46]: </span><span class="n">a</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="go">Out[46]:</span>
<span class="go">array([[  1.,   2.,   3.,   4.],</span>
<span class="go">       [  5.,   6.,   7.,   8.],</span>
<span class="go">       [  9.,  10.,  11.,  12.]])</span>

<span class="gp">In [47]: </span><span class="n">a</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Out[47]:</span>
<span class="go">array([[  1.,   2.,   3.,   4.],</span>
<span class="go">       [  5.,   6.,   7.,   8.],</span>
<span class="go">       [  9.,  10.,  11.,  12.]])</span>
</pre></div>
</div>
</div>
<div class="section" id="universelle-funktionen">
<span id="ufuncs"></span><h2>Universelle Funktionen<a class="headerlink" href="#universelle-funktionen" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>Im Abschnitt <a class="reference internal" href="#arrayerzeugung"><em>Erzeugung von NumPy-Arrays</em></a> hatten wir in einem Beispiel bereits eine
Funktion auf ein Array angewandt. Um dieses Vorgehen besser zu verstehen,
importieren wir zusätzlich zum <tt class="docutils literal"><span class="pre">numpy</span></tt>-Paket, das in diesem Kapitel immer
importiert sein sollte, noch das <tt class="docutils literal"><span class="pre">math</span></tt>-Modul und versuchen dann, den Sinus
eines Arrays auszuwerten.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">math</span>

<span class="gp">In [2]: </span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
<span class="go">---------------------------------------------------------------------------</span>
<span class="go">TypeError                                 Traceback (most recent call last)</span>

<span class="go">&lt;ipython console&gt; in &lt;module&gt;()</span>

<span class="go">TypeError: only length-1 arrays can be converted to Python scalars</span>
</pre></div>
</div>
<p>Dabei scheitern wir jedoch, da der Sinus aus dem <tt class="docutils literal"><span class="pre">math</span></tt>-Modul nur mit skalaren Größen
umgehen kann. Hätte unser Array nur ein Element enthalten, so wären wir noch erfolgreich
gewesen. Im Beispiel hatten wir jedoch mehr als ein Element, genauer gesagt elf Elemente,
und somit kommt es zu einer <tt class="docutils literal"><span class="pre">TypeError</span></tt>-Ausnahme.</p>
<p>Den Ausweg bietet in diesem Fall das <tt class="docutils literal"><span class="pre">numpy</span></tt>-Paket selbst, das neben einer ganzen
Reihe weiterer Funktionen auch eine eigene Sinusfunktion zur Verfügung stellt. Diese ist
in der Lage, mit Arrays beliebiger Dimension umzugehen. Dabei wird die Funktion
elementweise angewandt und wieder ein Array der ursprünglichen Form erzeugt.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [3]: </span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
<span class="go">Out[3]:</span>
<span class="go">array([  0.00000000e+00,   3.09016994e-01,   5.87785252e-01,</span>
<span class="go">         8.09016994e-01,   9.51056516e-01,   1.00000000e+00,</span>
<span class="go">         9.51056516e-01,   8.09016994e-01,   5.87785252e-01,</span>
<span class="go">         3.09016994e-01,   1.22460635e-16])</span>

<span class="gp">In [4]: </span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="go">Out[4]:</span>
<span class="go">array([[  0.00000000e+00,   5.00000000e-01,   8.66025404e-01,</span>
<span class="go">          1.00000000e+00,   8.66025404e-01,   5.00000000e-01],</span>
<span class="go">       [  1.22460635e-16,  -5.00000000e-01,  -8.66025404e-01,</span>
<span class="go">         -1.00000000e+00,  -8.66025404e-01,  -5.00000000e-01]])</span>
</pre></div>
</div>
<p>Statt die Kreiszahl aus dem <tt class="docutils literal"><span class="pre">math</span></tt>-Modul zu nehmen, hätten wir sie genauso gut aus dem
<tt class="docutils literal"><span class="pre">numpy</span></tt>-Paket nehmen können.</p>
<p>Funktionen wie die gerade benutzte Sinusfunktion aus dem <tt class="docutils literal"><span class="pre">numpy</span></tt>-Paket, die
Arrays als Argumente akzeptieren, werden universelle Funktionen (<em>universal
function</em> oder kurz <em>ufunc</em>) genannt. Die im <tt class="docutils literal"><span class="pre">numpy</span></tt>-Paket verfügbaren
universellen Funktionen sind in der <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs">NumPy-Dokumentation zu ufuncs</a>
aufgeführt. Implementationen von speziellen Funktionen als universelle Funktion
sind im <tt class="docutils literal"><span class="pre">scipy</span></tt>-Paket zu finden. Viele Funktionen in <tt class="docutils literal"><span class="pre">scipy.special</span></tt>,
jedoch nicht alle,  sind als <em>ufuncs</em> implementiert.  Als nur eines von vielen
möglichen Beispielen wählen wir die Gammafunktion:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [5]: </span><span class="kn">import</span> <span class="nn">scipy.special</span>

<span class="gp">In [6]: </span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="go">Out[6]:</span>
<span class="go">array([  1.        ,   0.88622693,   1.        ,   1.32934039,</span>
<span class="go">         2.        ,   3.32335097,   6.        ,  11.6317284 ,  24.        ])</span>
</pre></div>
</div>
<p>Gelegentlich benötigt man eine Funktion von zwei Variablen auf einem Gitter.
Man könnte hierzu die <tt class="docutils literal"><span class="pre">meshgrid</span></tt>-Funktion heranziehen, die wir im Abschnitt
<a class="reference internal" href="#arrayerzeugung"><em>Erzeugung von NumPy-Arrays</em></a> erwähnt hatten. Dabei muss allerdings entweder die
Gitterpunkte explizit angeben oder beispielsweise mit <tt class="docutils literal"><span class="pre">linspace</span></tt> erzeugen.
Dann ist es häufig einfacher, ein <tt class="docutils literal"><span class="pre">mgrid</span></tt>-Gitter zu verwenden.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [7]: </span><span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">Out[7]:</span>
<span class="go">array([[[0, 0, 0],</span>
<span class="go">        [1, 1, 1],</span>
<span class="go">        [2, 2, 2]],</span>

<span class="go">       [[0, 1, 2],</span>
<span class="go">        [0, 1, 2],</span>
<span class="go">        [0, 1, 2]]])</span>

<span class="gp">In [8]: </span><span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">7j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">7j</span><span class="p">]</span>
<span class="go">Out[8]:</span>
<span class="go">array([[[ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ],</span>
<span class="go">        [ 0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5],</span>
<span class="go">        [ 1. ,  1. ,  1. ,  1. ,  1. ,  1. ,  1. ],</span>
<span class="go">        [ 1.5,  1.5,  1.5,  1.5,  1.5,  1.5,  1.5],</span>
<span class="go">        [ 2. ,  2. ,  2. ,  2. ,  2. ,  2. ,  2. ],</span>
<span class="go">        [ 2.5,  2.5,  2.5,  2.5,  2.5,  2.5,  2.5],</span>
<span class="go">        [ 3. ,  3. ,  3. ,  3. ,  3. ,  3. ,  3. ]],</span>

<span class="go">       [[ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ],</span>
<span class="go">        [ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ],</span>
<span class="go">        [ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ],</span>
<span class="go">        [ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ],</span>
<span class="go">        [ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ],</span>
<span class="go">        [ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ],</span>
<span class="go">        [ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ]]])</span>
</pre></div>
</div>
<p>Man beachte, dass im zweiten Fall das dritte Element in der <em>slice</em>-Syntax imaginär ist. Damit wird
angedeutet, dass nicht die Schrittweite gemeint ist, sondern die Anzahl der Werte im durch die
ersten beiden Zahlen spezifizierten Intervall. Das folgende Beispiel zeigt eine
weitere Anwendung. Man sieht hier, dass die Schrittweite in <tt class="docutils literal"><span class="pre">mgrid</span></tt> auch durch
eine Gleitkommazahl gegeben sein kann.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [9]: </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mf">0.1</span><span class="p">]</span>

<span class="gp">In [10]: </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/mpl_4.png"><img alt="_images/mpl_4.png" class="align-center" src="_images/mpl_4.png" style="height: 4.5cm;" /></a>
<p>Unter Verwendung des <em>broadcasting</em> genügt auch ein mit <tt class="docutils literal"><span class="pre">ogrid</span></tt> erzeugtes Gitter,
das wesentlich weniger Speicherplatz erfordert.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [11]: </span><span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">7j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">7j</span><span class="p">]</span>
<span class="go">Out[11]:</span>
<span class="go">[array([[ 0. ],</span>
<span class="go">       [ 0.5],</span>
<span class="go">       [ 1. ],</span>
<span class="go">       [ 1.5],</span>
<span class="go">       [ 2. ],</span>
<span class="go">       [ 2.5],</span>
<span class="go">       [ 3. ]]),</span>
<span class="go"> array([[ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ]])]</span>
</pre></div>
</div>
<p>Alternativ kann man die Werte für <tt class="docutils literal"><span class="pre">x</span></tt> und <tt class="docutils literal"><span class="pre">y</span></tt> auch expliziter wie folgt
erzeugen.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [12]: </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

<span class="gp">In [13]: </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

<span class="gp">In [14]: </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="gp">In [15]: </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">&#39;viridis&#39;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/mpl_5.png"><img alt="_images/mpl_5.png" class="align-center" src="_images/mpl_5.png" style="height: 4.5cm;" /></a>
<p>In Eingabe 13 ist es wichtig, dass eine weitere Achse hinzugefügt wird. Erst
dann spannen <tt class="docutils literal"><span class="pre">x</span></tt> und <tt class="docutils literal"><span class="pre">y</span></tt> durch <em>broadcasting</em> ein zweidimensionales Gitter
auf. In Eingabe 14 berechnet <tt class="docutils literal"><span class="pre">hypot</span></tt> die Länge der Hypotenuse eines
rechtwinkligen Dreiecks mit den durch die Argumente gegebenen Kathetenlängen.</p>
<p>Es ist nicht nur praktisch, Funktionen von Arrays direkt berechnen zu können,
sondern es spart häufig auch Rechenzeit. Wir wollen dies an einem Beispiel
illustrieren, in dem wir den Sinus entweder einzeln in einer Schleife oder
mit Hilfe einer universellen Funktion berechnen.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">sin_math</span><span class="p">(</span><span class="n">nmax</span><span class="p">):</span>
    <span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">nmax</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xvals</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span>

<span class="k">def</span> <span class="nf">sin_numpy</span><span class="p">(</span><span class="n">nmax</span><span class="p">):</span>
    <span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">nmax</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">yvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">xvals</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span>

<span class="n">maxpower</span> <span class="o">=</span> <span class="mi">27</span>
<span class="n">nvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">maxpower</span><span class="p">)</span>
<span class="n">tvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">nvals</span><span class="p">)</span>
<span class="k">for</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nmax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxpower</span><span class="p">,</span> <span class="n">maxpower</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)):</span>
    <span class="n">nvals</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">nmax</span>
    <span class="n">tvals</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_math</span><span class="p">(</span><span class="n">nmax</span><span class="p">)</span><span class="o">/</span><span class="n">sin_numpy</span><span class="p">(</span><span class="n">nmax</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rc</span><span class="p">(</span><span class="s">&#39;text&#39;</span><span class="p">,</span> <span class="n">usetex</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xscale</span><span class="p">(</span><span class="s">&#39;log&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;$n_\mathrm{max}$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;$t_\mathrm{math}/t_\mathrm{numpy}$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">nvals</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="s">&#39;o&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<a class="reference internal image-reference" href="_images/mpl_6.png"><img alt="_images/mpl_6.png" class="align-center" src="_images/mpl_6.png" style="height: 6cm;" /></a>
<p>Ist die jeweilige Funktion häufig zu berechnen, so kann man etwa eine
Größenordnung an Rechenzeit einsparen. Der Vorteil der universellen Funktion
wird noch etwas größer, wenn man verlangt, dass das Ergebnis in einem Array
oder in einer Liste abgespeichert wird. In der Funktion <tt class="docutils literal"><span class="pre">sin_numpy</span></tt> ist das
bereits der Fall, nicht jedoch in der Funktion <tt class="docutils literal"><span class="pre">sin_math</span></tt>.</p>
<p>Wegen der genannten Rechenzeitvorteile lohnt es sich, einen Blick in die Liste
der von NumPy zur Verfügung gestellten <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/routines.math.html">mathematischen Funktionen</a> zu werfen.</p>
</div>
<div class="section" id="lineare-algebra">
<h2>Lineare Algebra<a class="headerlink" href="#lineare-algebra" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>Physikalische Fragestellungen, die sich mit Hilfe von Vektoren und Matrizen formulieren lassen,
benötigen zur Lösung sehr häufig Methoden der linearen Algebra. NumPy leistet hierbei Unterstützung,
insbesondere mit dem <tt class="docutils literal"><span class="pre">linalg</span></tt>-Paket. Im Folgenden gehen wir auf einige Aspekte ein, ohne
Vollständigkeit anzustreben. Daher empfiehlt es sich, auch einen Blick in den
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/routines.linalg.html">entsprechenden Abschnitt der Dokumentation</a>
zu werfen. Zunächst importieren wir die Module, die wir für die Beispiele dieses Kapitels benötigen:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="gp">In [2]: </span><span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="kn">as</span> <span class="nn">LA</span>
</pre></div>
</div>
<p>Beim Arbeiten mit Matrizen und NumPy muss man immer bedenken, dass der Multiplikationsoperator <cite>*</cite>
nicht für eine Matrixmultiplikation steht. Vielmehr wird damit eine elementweise Multiplikation
ausgeführt:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [3]: </span><span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>

<span class="gp">In [4]: </span><span class="n">a1</span>
<span class="go">Out[4]:</span>
<span class="go">array([[ 1, -3],</span>
<span class="go">       [-2,  5]])</span>

<span class="gp">In [5]: </span><span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

<span class="gp">In [6]: </span><span class="n">a2</span>
<span class="go">Out[6]:</span>
<span class="go">array([[ 3, -6],</span>
<span class="go">       [ 2, -1]])</span>

<span class="gp">In [7]: </span><span class="n">a1</span><span class="o">*</span><span class="n">a2</span>
<span class="go">Out[7]:</span>
<span class="go">array([[ 3, 18],</span>
<span class="go">       [-4, -5]])</span>
</pre></div>
</div>
<p>Möchte man dagegen eine Matrixmultiplikation ausführen, so verwendet man das <tt class="docutils literal"><span class="pre">dot</span></tt>-Produkt:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [8]: </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
<span class="go">Out[8]:</span>
<span class="go">array([[-3, -3],</span>
<span class="go">       [ 4,  7]])</span>
</pre></div>
</div>
<p>Ab Python 3.5 und NumPy 1.10 steht hierfür auch ein spezieller Operator zur
Verfügung.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [9]: </span><span class="n">a1</span> <span class="err">@</span> <span class="n">a2</span>
<span class="go">Out[9]:</span>
<span class="go">array([[-3, -3],</span>
<span class="go">       [ 4,  7]])</span>
</pre></div>
</div>
<p>Man könnte die Norm eines Vektors ebenfalls mit Hilfe des <tt class="docutils literal"><span class="pre">dot</span></tt>-Produkts bestimmen. Es bietet
sich jedoch an, hierzu direkt die <tt class="docutils literal"><span class="pre">norm</span></tt>-Funktion zu verwenden:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [10]: </span><span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

<span class="gp">In [11]: </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
<span class="gr">Out[11]: </span><span class="mf">3.7416573867739413</span>

<span class="gp">In [12]: </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gr">Out[12]: </span><span class="mf">14.0</span>
</pre></div>
</div>
<p>Als nächstes wollen wir ein inhomogenes lineares Gleichungssystem <tt class="docutils literal"><span class="pre">ax</span> <span class="pre">=</span> <span class="pre">b</span></tt> lösen, wobei die
Matrix <tt class="docutils literal"><span class="pre">a</span></tt> und der Vektor <tt class="docutils literal"><span class="pre">b</span></tt> gegeben sind und der Vektor <tt class="docutils literal"><span class="pre">x</span></tt> gesucht ist.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [13]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>

<span class="gp">In [14]: </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

<span class="gp">In [15]: </span><span class="n">LA</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gr">Out[15]: </span><span class="mf">0.99999999999999978</span>

<span class="gp">In [16]: </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">LA</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="gr">Out[16]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">])</span>
</pre></div>
</div>
<p>In Eingabe 15 haben wir zunächst überprüft, dass die Determinante der Matrix
<tt class="docutils literal"><span class="pre">a</span></tt> ungleich Null ist, so dass die invertierte Matrix existiert. Anschließend
haben wir den Vektor <tt class="docutils literal"><span class="pre">b</span></tt> von links mit der Inversen von <tt class="docutils literal"><span class="pre">a</span></tt> multipliziert,
um den Lösungsvektor zu erhalten. Allerdings erfolgt die numerische Lösung
eines inhomogenen linearen Gleichungssystems normalerweise nicht über eine
Inversion der Matrix, sondern mit Hilfe einer geeignet durchgeführten Gauß-Elimination.
NumPy stell hierzu die <tt class="docutils literal"><span class="pre">solve</span></tt>-Funktion zur Verfügung:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [17]: </span><span class="n">LA</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gr">Out[17]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">])</span>
</pre></div>
</div>
<p>Eine nicht invertierbare Matrix führt hier wie auch bei der Bestimmung der Determinante
auf eine <tt class="docutils literal"><span class="pre">LinAlgError</span></tt>-Ausnahme mit dem Hinweis auf eine singuläre Matrix.</p>
<p>Eine häufig vorkommende Problemstellung im Bereich der linearen Algebra sind
Eigenwertprobleme. Die <tt class="docutils literal"><span class="pre">eig</span></tt>-Funktion bestimmt rechtsseitige Eigenvektoren und
die zugehörigen Eigenwerte für beliebige quadratische Matrizen:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [18]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

<span class="gp">In [19]: </span><span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="gp">In [20]: </span><span class="n">evals</span>
<span class="gr">Out[20]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">3.60555128</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.60555128</span><span class="p">])</span>

<span class="gp">In [21]: </span><span class="n">evecs</span>
<span class="go">Out[21]:</span>
<span class="go">array([[ 0.75499722, -0.54580557],</span>
<span class="go">       [ 0.65572799,  0.83791185]])</span>

<span class="gp">In [22]: </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">evecs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
<span class="go">    print(np.dot(a, evecs[:, n]), evals[n]*evecs[:, n])</span>
<span class="go">Out[22]:</span>
<span class="go">[ 2.72218119  2.36426089] [ 2.72218119  2.36426089]</span>
<span class="go">[ 1.96792999 -3.02113415] [ 1.96792999 -3.02113415]</span>
</pre></div>
</div>
<p>Die Ausgabe am Ende zeigt, dass die Eigenvektoren und -werte in der Tat korrekt
sind.  Zudem wird hier deutlich, dass die Eigenvektoren als Spaltenvektoren in
der Matrix <tt class="docutils literal"><span class="pre">evecs</span></tt> gespeichert sind. Benötigt man nur die Eigenwerte einer
Matrix, so kann man durch Benutzung der <tt class="docutils literal"><span class="pre">eigvals</span></tt>-Funktion Rechenzeit sparen.</p>
<p>Für die Lösung eines Eigenwertproblems von symmetrischen oder hermiteschen <a class="footnote-reference" href="#hermitesch" id="id3">[3]</a>
Matrizen gibt es die Funktionen <tt class="docutils literal"><span class="pre">eigh</span></tt> und <tt class="docutils literal"><span class="pre">eigvalsh</span></tt>, bei denen es genügt,
nur die obere oder die untere Hälfte der Matrix zu spezifizieren. Viel
wichtiger ist jedoch, dass diese Funktionen einen erheblichen Zeitvorteil
bieten können:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [23]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">250000</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>

<span class="gp">In [24]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">T</span>

<span class="gp">In [25]: </span><span class="o">%</span><span class="n">timeit</span> <span class="n">LA</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1 loop, best of 3: 209 ms per loop</span>

<span class="gp">In [26]: </span><span class="o">%</span><span class="n">timeit</span> <span class="n">LA</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">10 loops, best of 3: 28.2 ms per loop</span>
</pre></div>
</div>
<p>Hier wird in Eingabe 24 durch Addition der Transponierten eine symmetrische
Matrix erzeugt, so dass die beiden Funktionen <tt class="docutils literal"><span class="pre">eig</span></tt> und <tt class="docutils literal"><span class="pre">eigh</span></tt> mit der
gleichen Matrix arbeiten. Die Funktion <tt class="docutils literal"><span class="pre">eigh</span></tt> ist in diesem Beispiel etwa
siebenmal so schnell.</p>
</div>
<div class="section" id="einfache-anwendungen">
<h2>Einfache Anwendungen<a class="headerlink" href="#einfache-anwendungen" title="Permalink zu dieser Überschrift">¶</a></h2>
<p>In diesem Abschnitt stellen wir einige einfache Problemstellungen vor, die sich
mit Hilfe von NumPy gut bearbeiten lassen. Wir verzichten dabei bewusst auf die
Angabe der Lösung, zeigen jedoch die zu erwartenden Resultate.</p>
<div class="section" id="mandelbrot-menge">
<h3>Mandelbrot-Menge<a class="headerlink" href="#mandelbrot-menge" title="Permalink zu dieser Überschrift">¶</a></h3>
<p>Betrachtet man die Rekursionsformel <span class="math">\(z_{n+1} = z_n^2+c\)</span> mit <span class="math">\(z_0=0\)</span>,
so ist die Mandelbrot-Menge durch die komplexen Zahlen <span class="math">\(c\)</span> definiert, für
die Folge der <span class="math">\(z_n\)</span> beschränkt bleibt. Überschreitet der Betrag von
<span class="math">\(z\)</span> die Schwelle 2, so divergiert die Folge. In der Praxis wird man
natürlich nur eine endliche Zahl von Iterationen ausführen können.</p>
<p>In der linken der beiden folgenden Abbildung ist die Mandelbrot-Menge in weiß
dargestellt.  Bei der Berechnung wird man möglicherweise Überlaufwarnungen
erhalten. Diese kann man vermeiden, wenn man die Berechnung nur für die Werte
von <span class="math">\(c\)</span> fortsetzt, für die die Schwelle von Zwei noch nicht überschritten
wurde. Dann eröffnet sich auch die Möglichkeit, die Zahl der Iterationen bis zum
Erreichen der Schwelle abzuspeichern und in einer Farbabbildung darzustellen.
Dies ist im rechten Bild für einen Ausschnitt gezeigt.</p>
<a class="reference internal image-reference" href="_images/mandelbrot.png"><img alt="_images/mandelbrot.png" class="align-center" src="_images/mandelbrot.png" style="height: 6cm;" /></a>
</div>
<div class="section" id="brownsche-bewegung">
<h3>Brownsche Bewegung<a class="headerlink" href="#brownsche-bewegung" title="Permalink zu dieser Überschrift">¶</a></h3>
<p>Eine Zufallsbewegung in einer Dimension kann man durch Zufallszahlen darstellen,
die aus der Menge der beiden Zahlen <span class="math">\(-1\)</span> und <span class="math">\(1\)</span> gezogen werden.
Jede Zufallszahl gibt die Richtung an, in der zu dem entsprechenden Zeitpunkt
ein Schritt ausgeführt wird. Es sollen nun mehrere Realisierung erzeugt und
graphisch dargestellt werden. Aus den erzeugten Daten soll auch der Mittelwert
und die Varianz des Orts als Funktion der Zeit berechnet und dargestellt werden.
Für die Berechnung ist es praktisch, dass NumPy eine Funktion zur Verfügung
stellt, die für ein Array sukzessive kumulative Summen berechnen kann.</p>
<a class="reference internal image-reference" href="_images/brownianmotion.png"><img alt="_images/brownianmotion.png" class="align-center" src="_images/brownianmotion.png" style="height: 10cm;" /></a>
</div>
<div class="section" id="fibonacci-zahlen-und-goldener-schnitt">
<h3>Fibonacci-Zahlen und goldener Schnitt<a class="headerlink" href="#fibonacci-zahlen-und-goldener-schnitt" title="Permalink zu dieser Überschrift">¶</a></h3>
<p>Die Fibonacci-Folge ist durch die Rekursionsformel <span class="math">\(f_{n+1} = f_n+f_{n-1}\)</span>
mit den Anfangswerten <span class="math">\(f_1=f_2=1\)</span> bestimmt. Das Verhältnis
<span class="math">\(f_{n+1}/f_{n}\)</span> geht für große <span class="math">\(n\)</span> gegen einen Grenzwert, der mit
Hilfe des <tt class="docutils literal"><span class="pre">linalg</span></tt>-Moduls von NumPy berechnet werden soll. Dies gelingt, wenn
man die Rekursionsformel als Abbildung des Tupels <span class="math">\((f_n, f_{n-1})\)</span> auf
das Tupel <span class="math">\((f_{n+1}, f_n)\)</span> interpretiert.</p>
</div>
<div class="section" id="bildbearbeitung">
<h3>Bildbearbeitung<a class="headerlink" href="#bildbearbeitung" title="Permalink zu dieser Überschrift">¶</a></h3>
<p>NumPy-Arrays können auch Bilddaten repräsentieren, so dass sich die Bearbeitung
eines Bildes auf die Manipulation eines NumPy-Arrays zurückführen lässt. Der
folgende Code zeigt, wie man ein in der SciPy-Bibliothek verfügbares Bild als
Array interpretieren und graphisch darstellen kann.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">misc</span>

<span class="gp">In [2]: </span><span class="n">face</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">face</span><span class="p">(</span><span class="n">gray</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">face</span>
<span class="go">Out[3]:</span>
<span class="go">array([[114, 130, 145, ..., 119, 129, 137],</span>
<span class="go">       [ 83, 104, 123, ..., 118, 134, 146],</span>
<span class="go">       [ 68,  88, 109, ..., 119, 134, 145],</span>
<span class="go">       ...,</span>
<span class="go">       [ 98, 103, 116, ..., 144, 143, 143],</span>
<span class="go">       [ 94, 104, 120, ..., 143, 142, 142],</span>
<span class="go">       [ 94, 106, 119, ..., 142, 141, 140]], dtype=uint8)</span>
</pre></div>
</div>
<p>Wir haben es hier mit einem Array zu tun, dessen Elemente durch vorzeichenlose
8-Bit-Integers dargestellt sind, also Zahlen zwischen 0 und 255 repräsentieren.
Diese können wir als Grauwerte darstellen.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [4]: </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/face_orig.png"><img alt="_images/face_orig.png" class="align-center" src="_images/face_orig.png" style="height: 5cm;" /></a>
<p>Durch geeignete Manipulation des NumPy-Arrays <tt class="docutils literal"><span class="pre">face</span></tt> lässt sich das Bild in
ein Schwarz-Weiß-Bild verwandeln oder man kann die Kontrastkurve verändern.
Des Weiteren kann man das Bild zum Beispiel mit verschiedenen Rahmen versehen.
Einige Möglichkeiten zeigen die folgenden Bilder.</p>
<a class="reference internal image-reference" href="_images/facecollection.png"><img alt="_images/facecollection.png" class="align-center" src="_images/facecollection.png" style="height: 8cm;" /></a>
<table class="docutils footnote" frame="void" id="array" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Wir verwenden im Folgenden das englische Wort <em>Array</em>, um damit den <tt class="docutils literal"><span class="pre">ndarray</span></tt>-Datentyp
aus NumPy zu bezeichnen. Ein Grund dafür, nicht von Matrizen zu sprechen, besteht darin,
dass sich Arrays nicht notwendigerweise wie Matrizen verhalten. So entspricht das Produkt
von zwei Arrays im Allgemeinen nicht dem Matrixprodukt.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="strides" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Das englische Wort <em>stride</em> bedeutet Schritt.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="hermitesch" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Eine hermitesche Matrix geht beim Transponieren in die konjugiert komplexe Matrix über:
<span class="math">\(a_{ij}=a_{ji}^*\)</span>.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="advancedpython.html">Fortgeschrittene Aspekte von Python</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Inhalt</a>
        &#160;&#160;::&#160;&#160;
        <a href="graphics.html">Erstellung von Grafiken</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012-2016, Gert-Ludwig Ingold.
      Mit <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3 erstellt.
    </div>
  </body>
</html>