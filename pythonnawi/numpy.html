<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>NumPy &mdash; Python für Naturwissenschaftler</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2016alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Python für Naturwissenschaftler" href="index.html" />
    <link rel="next" title="Erstellung von Grafiken mit matplotlib" href="graphics.html" />
    <link rel="prev" title="Fortgeschrittene Aspekte von Python" href="advancedpython.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Python für Naturwissenschaftler</span></a></h1>
        <h2 class="heading"><span>NumPy</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="advancedpython.html">Fortgeschrittene Aspekte von Python</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Inhalt</a>
        &#160;&#160;::&#160;&#160;
        <a href="graphics.html">Erstellung von Grafiken mit matplotlib</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="numpy">
<h1>NumPy<a class="headerlink" href="#numpy" title="Link zu dieser Überschrift">¶</a></h1>
<p>In der Vorlesung »Einführung in das Programmieren für Physiker und Naturwissenschaftler«
wurde am Beispiel von NumPy und SciPy eine kurze Einführung in die Benutzung numerischer
Programmbibliotheken gegeben. Dabei wurde an einigen wenigen Beispielen gezeigt, wie man
in Python mit Vektoren und Matrizen arbeiten und einfache Problemstellungen der linearen
Algebra lösen kann. Im Folgenden wollen wir uns etwas genauer mit NumPy beschäftigen ohne
dabei eine vollständige Beschreibung anzustreben. Bei Bedarf sollte daher die
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/">NumPy Referenzdokumentation</a> herangezogen
werden. Als Informationsquelle sind zudem die <a class="reference external" href="http://scipy-lectures.github.com/">Python Scientific Lecture Notes</a> empfehlenswert. Dort werden auch andere
Programmbibliotheken diskutiert, die in naturwissenschaftlichen Anwendungen hilfreich
sein können.</p>
<div class="section" id="python-listen-und-numpy-arrays">
<span id="pythonlisten"></span><h2>Python-Listen und NumPy-Arrays<a class="headerlink" href="#python-listen-und-numpy-arrays" title="Link zu dieser Überschrift">¶</a></h2>
<p>Viele naturwissenschaftliche Problemstellungen lassen sich in natürlicher Weise mit Hilfe
von Vektoren und Matrizen formulieren. Dies kann entweder eine Eigenschaft des ursprünglichen
Problems sein, beispielsweise bei der Beschreibung eines gekoppelten schwingenden Systems
mit Hilfe von gekoppelten Differentialgleichungen. Es kann aber auch vorkommen, dass erst
die numerische Umsetzung zu einer Formulierung in Vektoren und Matrizen führt, zum Beispiel
bei der Diskretisierung einer partiellen Differentialgleichung.</p>
<p>Will man solche Problemstellungen mit den Standardmitteln bearbeiten, die von
Python zur Verfügung gestellt werden, so wird man auf Listen zurückgreifen
müssen. Um eine zweidimensionale Matrix zu definieren, würde man eine Liste von
Listen anlegen und könnte dann durch eine doppelte Indizierung auf ein einzelnes Element
zugreifen.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.4</span><span class="p">,</span> <span class="mf">5.5</span><span class="p">,</span> <span class="mf">6.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">7.7</span><span class="p">,</span> <span class="mf">8.8</span><span class="p">,</span> <span class="mf">9.9</span><span class="p">]]</span>

<span class="gp">In [2]: </span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gr">Out[2]: </span><span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">]</span>

<span class="gp">In [3]: </span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="gr">Out[3]: </span><span class="mf">3.3</span>
</pre></div>
</div>
<p>Das Beispiel erklärt die doppelte Indizierung. Durch den ersten Index, hier <code class="docutils literal"><span class="pre">[0]</span></code>, wird
die erste Unterliste ausgewählt aus der wiederum ein einzelnes Element, hier das dritte,
ausgewählt werden kann. Somit besteht hier, ganz im Gegensatz zu zweidimensionalen Matrizen,
ein grundsätzlicher Unterschied zwischen Zeilen und Spalten. Eine Zeile kann man entweder
wie oben in der Eingabe 2 erhalten oder auch etwas umständlicher mit</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [4]: </span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span>
<span class="gr">Out[4]: </span><span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">]</span>
</pre></div>
</div>
<p>Hier ist explizit angegeben, dass wir alle Elemente der ersten Zeile haben wollen. Ein
enstprechender Zugriff auf eine Spalte funktioniert jedoch nicht:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [5]: </span><span class="n">matrix</span><span class="p">[:][</span><span class="mi">0</span><span class="p">]</span>
<span class="gr">Out[5]: </span><span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">]</span>
</pre></div>
</div>
<p>Hier gibt <code class="docutils literal"><span class="pre">matrix[:]</span></code> eine Liste mit allen Unterlisten, also einfach die ursprüngliche
Liste zurück. Somit ist <code class="docutils literal"><span class="pre">matrix[:][0]</span></code> nichts anderes als die erste Unterliste. Wir
erhalten also wiederum die erste Zeile und keineswegs die erste Spalte. Allgemein ist
die Extraktion einer Untermatrix aus einer durch Listen dargestellten Matrix nicht ohne
einen gewissen Aufwand möglich.</p>
<p>Ein weiterer Nachteil besteht in der Flexibilität von Listen, die ja bekanntlich beliebige
Objekte enthalten können. Python muss daher einen erheblichen Aufwand bei der Verwaltung
von Listen treiben. Dies betrifft alleine schon die Adressierung eines einzelnen Elements.
Andererseits wird diese Flexibilität bei Matrizen überhaupt nicht benötigt, da dort alle
Einträge vom gleichen Datentyp sind. Es sollte also möglich sein, erheblich effizientere
Programme zu schreiben, indem man Matrizen nicht durch Listen darstellt, sondern durch
einen auf diese Aufgabe zugeschnittenen Datentypen. Hierzu greift man auf das von NumPy
zur Verfügung gestellte <code class="docutils literal"><span class="pre">ndarray</span></code>-Objekt, also ein N-dimensionales Array, zurück.</p>
<p>Ein Array <a class="footnote-reference" href="#array" id="id1">[1]</a> besitzt als wesentliche Bestandteile die Daten im eigentlichen Sinne, also die
Werte der einzelnen Matrixelemente, sowie Information darüber, wie auf ein spezifisches
Matrixelement zugegriffen werden kann. Die Daten sind im Speicher einfach hintereinander,
also in eindimensionaler Form, abgelegt. Dabei gibt es die Möglichkeit, die Matrix zeilenweise
oder spaltenweise abzuspeichern. Ersteres wird von der Programmiersprache C verwendet,
während die zweite Variante von Fortran verwendet wird.</p>
<p>Nachdem die Daten strukturlos im Speicher abgelegt sind, müssen <code class="docutils literal"><span class="pre">ndarray</span></code>-Objekte, wie
schon erwähnt, neben den Daten auch Informationen darüber besitzen, wie auf einzelne
Matrixelemente zugegriffen wird. Auf diese Weise lässt sich sehr leicht die Adresse der
Daten eines Matrixelements bestimmen. Zudem ist es möglich, die gleichen Daten im Speicher
auf verschiedene Weise anzusehen. Damit ist es häufig möglich, unnötige Kopiervorgänge im
Speicher zu vermeiden. Andererseits ist es aus diesem Grunde wichtig zu wissen, ob NumPy
im Einzelfall nur eine andere Sicht auf die Daten zur Verfügung stellt oder tatsächlich
ein neues Array erzeugt.</p>
<p>Um die Informationen über die Struktur eines Arrays besser zu verstehen, betrachten wir
ein Beispiel.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="gp">In [2]: </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">matrix</span>
<span class="gr">Out[3]: </span><span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>

<span class="gp">In [4]: </span><span class="n">matrix</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">nbytes</span>
<span class="gr">Out[4]: </span><span class="p">(</span><span class="n">dtype</span><span class="p">(</span><span class="s">&#39;int64&#39;</span><span class="p">),</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>

<span class="gp">In [5]: </span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
<span class="gr">Out[5]: </span><span class="p">(</span><span class="mi">16</span><span class="p">,)</span>

<span class="gp">In [6]: </span><span class="n">matrix</span><span class="o">.</span><span class="n">strides</span>
<span class="gr">Out[6]: </span><span class="p">(</span><span class="mi">8</span><span class="p">,)</span>
</pre></div>
</div>
<p>Wir laden zunächst das <code class="docutils literal"><span class="pre">numpy</span></code>-Modul, für das üblicherweise die Abkürzung
<code class="docutils literal"><span class="pre">np</span></code> verwendet wird. Dieser Schritt wird in allen folgenden Beispielen
vorausgesetzt.  Dann erzeugen wir uns auf möglichst einfache Weise ein Array
mit 16 Elementen. Die Funktionsweise von <code class="docutils literal"><span class="pre">arange</span></code> werden wir später noch
etwas ausführlicher diskutieren. Wir erhalten somit ein eindimensionales Array,
das die Zahlen von 0 bis 15 als Integers enthält.  Das Objekt <code class="docutils literal"><span class="pre">matrix</span></code> hat
nun einige Eigenschaften. Der Datentyp <code class="docutils literal"><span class="pre">dtype</span></code> ist hier <code class="docutils literal"><span class="pre">int64</span></code>, also ein
Integer mit einer Länge von 64 Bit oder 8 Bytes. Letzteres wird auch durch das
Attribut <code class="docutils literal"><span class="pre">itemsize</span></code> angegeben. Die Größe des Arrays, also <code class="docutils literal"><span class="pre">size</span></code>, ist 16,
so dass sich insgesamt ein Speicherbedarf <code class="docutils literal"><span class="pre">nbytes</span></code> von 128 Bytes ergibt. Das
Tupel <code class="docutils literal"><span class="pre">shape</span></code> gibt die Form des Arrays an. In unserem Fall gibt es nur eine
Dimension, die 16 Elemente enthält. Das Tupel <code class="docutils literal"><span class="pre">strides</span></code> schließlich gibt an,
wie weit benachbarte Elemente in einer bestimmten Dimension voneinander
entfernt sind. Bei einem eindimensionalen Array ist dies gerade die Zahl der
Bytes, die ein Dateneintrag benötigt.</p>
<p>Mit Hilfe der Attribute <code class="docutils literal"><span class="pre">shape</span></code> und <code class="docutils literal"><span class="pre">strides</span></code> kann man nun eine andere
Sicht auf das gleiche Array erhalten.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [7]: </span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="gp">In [8]: </span><span class="n">matrix</span>
<span class="go">Out[8]:</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>

<span class="gp">In [9]: </span><span class="n">matrix</span><span class="o">.</span><span class="n">strides</span>
<span class="gr">Out[9]: </span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>

<span class="gp">In [10]: </span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="gp">In [11]: </span><span class="n">matrix</span>
<span class="go">Out[11]:</span>
<span class="go">array([[[[ 0,  1],</span>
<span class="go">         [ 2,  3]],</span>

<span class="go">        [[ 4,  5],</span>
<span class="go">         [ 6,  7]]],</span>


<span class="go">       [[[ 8,  9],</span>
<span class="go">         [10, 11]],</span>

<span class="go">        [[12, 13],</span>
<span class="go">         [14, 15]]]])</span>

<span class="gp">In [12]: </span><span class="n">matrix</span><span class="o">.</span><span class="n">strides</span>
<span class="gr">Out[12]: </span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>Wir interpretieren zunächst die 16 Matrixelemente als ein 4×4-Array, ohne dabei
die eigentlichen Array-Daten im Speicher in irgendeiner Weise zu modifizieren.
Lediglich das Attribut <code class="docutils literal"><span class="pre">shape</span></code> haben wir neu gesetzt. Das Attribut
<code class="docutils literal"><span class="pre">strides</span></code> gibt uns nun an, dass der Abstand der Daten in der ersten
Dimension, also innerhalb einer Spalte, 32 Bytes beträgt, während der Abstand in
der zweiten Dimension, also innerhalb einer Zeile, nach wie vor 8 ist. So lange
das Produkt der Dimensionen der Gesamtzahl der Matrixelemente entspricht,
können wir auch andere Matrixdimensionen wählen. So können wir unsere Daten
auch als ein 2×2×2×2-Array ansehen, wie der zweite Teil der obigen Ausgabe
zeigt.</p>
<p>Mit Hilfe der Attribute <code class="docutils literal"><span class="pre">shape</span></code> und <code class="docutils literal"><span class="pre">strides</span></code> lässt sich die Sicht auf ein
Array auf sehr flexible Weise festlegen. Allerdings ist der Benutzer selbst für
die Folgen verantwortlich, wie der zweite Teil des folgenden Beispiels zeigt.
Dazu gehen wir zum 4×4-Array zurück und verändern das Attribut <code class="docutils literal"><span class="pre">strides</span></code> mit
Hilfe der <code class="docutils literal"><span class="pre">as_strided</span></code>-Methode.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [13]: </span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="gp">In [14]: </span><span class="n">matrix1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>

<span class="gp">In [15]: </span><span class="n">matrix1</span>
<span class="go">Out[15]:</span>
<span class="go">array([[ 0,  2,  4,  6],</span>
<span class="go">       [ 2,  4,  6,  8],</span>
<span class="go">       [ 4,  6,  8, 10],</span>
<span class="go">       [ 6,  8, 10, 12]])</span>

<span class="gp">In [16]: </span><span class="n">matrix2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="gp">In [17]: </span><span class="n">matrix2</span>
<span class="go">Out[17]:</span>
<span class="go">array([[            0,  4294967296,            1,  8589934592],</span>
<span class="go">       [            2, 12884901888,            3, 17179869184],</span>
<span class="go">       [            4, 21474836480,            5, 25769803776],</span>
<span class="go">       [            6, 30064771072,            7, 34359738368]])</span>
</pre></div>
</div>
<p>Im ersten Fall ist der Wert der <em>strides</em> gerade das Doppelte der
Datenbreite, so dass in einer Zeile von einem Wert zum nächsten jeweils ein
Wert im Array übersprungen wird. Beim Übergang von einer Zeile zur nächsten
wird gegenüber dem Beginn der vorherigen Zeile auch nur um zwei Werte
vorangeschritten, so dass sich das gezeigte Resultat ergibt.</p>
<p>Im zweiten Beispiel wurde ein <em>stride</em> gewählt, der nur die Hälfte einer
Datenbreite beträgt. Der berechnete Beginn eines neuen Werts im Speicher liegt
damit nicht an einer Stelle, die einem tatsächlichen Beginn eines Werts
entspricht. Python interpretiert dennoch die erhaltene Information und erzeugt
so das obige Array. In unserem Beispiel erreicht man bei jedem zweiten Wert
wieder eine korrekte Datengrenze. Die Manipulation von <em>strides</em> erfordert also
eine gewisse Sorgfalt, und man ist für eventuelle Fehler selbst verantwortlich.</p>
<p>Für die Anwendung ist es wichtig zu wissen, dass die Manipulation der Attribute
<code class="docutils literal"><span class="pre">shape</span></code> und <code class="docutils literal"><span class="pre">strides</span></code> nicht die Daten im Speicher verändert. Es wird also
nur eine neue Sicht auf die vorhandenen Daten vermittelt. Dies ist insofern von
Bedeutung als das Kopieren von größeren Datenmengen durchaus mit einem größeren
Zeitaufwand verbunden sein kann. Ein Beispiel für die Durchführung einer
häufigen Matrixoperation durch Anpassung der <em>strides</em> werden wir gleich sehen.
Zuvor wollen wir uns aber überzeugen, dass in den obigen Beispielen tatsächlich
kein neues Array erzeugt wurde.</p>
<p>Dazu setzen wir den oberen linken Eintrag im ursprünglichen Array auf einen neuen
Wert und zeigen, dass diese Änderung auch in den Arrays mit veränderten <em>strides</em>
zu sehen ist.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [18]: </span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span>

<span class="gp">In [19]: </span><span class="n">matrix</span>
<span class="go">Out[19]:</span>
<span class="go">array([[99,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>

<span class="gp">In [20]: </span><span class="n">matrix1</span>
<span class="go">Out[20]:</span>
<span class="go">array([[99,  2,  4,  6],</span>
<span class="go">       [ 2,  4,  6,  8],</span>
<span class="go">       [ 4,  6,  8, 10],</span>
<span class="go">       [ 6,  8, 10, 12]])</span>
</pre></div>
</div>
<p>Eine Matrix lässt sich nun transponieren, ohne dass Matrixelemente im Speicher hin
und her kopiert werden müssen. Dies zeigt das folgende Beispiel, in welchem einfach
die zwei Werte der <em>strides</em> vertrauscht werden:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [21]: </span><span class="n">matrix</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">strides</span>
<span class="go">Out[21]:</span>
<span class="go">(array([[99,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11],</span>
<span class="go">        [12, 13, 14, 15]]), (32, 8))</span>


<span class="gp">In [22]: </span><span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">32</span><span class="p">))</span>
<span class="go">Out[22]:</span>
<span class="go">array([[99,  4,  8, 12],</span>
<span class="go">       [ 1,  5,  9, 13],</span>
<span class="go">       [ 2,  6, 10, 14],</span>
<span class="go">       [ 3,  7, 11, 15]])</span>
</pre></div>
</div>
<p>Obwohl die Daten im Speicher nicht verändert wurden, kann man jetzt mit der
transponierten Matrix arbeiten.</p>
</div>
<div class="section" id="erzeugung-von-numpy-arrays">
<span id="arrayerzeugung"></span><h2>Erzeugung von NumPy-Arrays<a class="headerlink" href="#erzeugung-von-numpy-arrays" title="Link zu dieser Überschrift">¶</a></h2>
<p>NumPy-Arrays lassen sich je nach Bedarf auf verschiedene Arten erzeugen. Die
Basis bildet die <code class="docutils literal"><span class="pre">ndarray</span></code>-Methode, auf die man immer zurückgreifen kann.
In den meisten Fällen wird es aber praktischer sein, auf angepasstere Methoden
zurückgreifen, die wir im Folgenden besprechen wollen.</p>
<p>Um ein mit Nullen aufgefülltes 2×2-Array zu erzeugen, geht man folgendermaßen
vor:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="n">matrix1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="gp">In [2]: </span><span class="n">matrix1</span><span class="p">,</span> <span class="n">matrix1</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">Out[2]:</span>
<span class="go">(array([[ 0.,  0.],</span>
<span class="go">       [ 0.,  0.]]), dtype(&#39;float64&#39;))</span>
</pre></div>
</div>
<p>Das Tupel im Argument gibt dabei die Form des Arrays vor. Wird der Datentyp der
Einträge nicht weiter spezifiziert, so werden Gleitkommazahlen mit einer Länge
von 8 Byte verwendet. Man kann aber auch explizit zum Beispiel Integereinträge
verlangen:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [3]: </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
<span class="go">Out[3]:</span>
<span class="go">array([[0, 0],</span>
<span class="go">       [0, 0]])</span>
</pre></div>
</div>
<p>Will man alle Elemente eines Arrays mit einem konstanten Wert ungleich Null
füllen, so kann man <code class="docutils literal"><span class="pre">ones</span></code> verwenden und das sich ergebende Array mit einem
Faktor multiplizieren.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [4]: </span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">Out[4]:</span>
<span class="go">array([[ 2.,  2.,  2.],</span>
<span class="go">       [ 2.,  2.,  2.]])</span>
</pre></div>
</div>
<p>Häufig benötigt man eine Einheitsmatrix, die man mit Hilfe von <code class="docutils literal"><span class="pre">identity</span></code>
erhält:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [5]: </span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Out[5]:</span>
<span class="go">array([[ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.]])</span>
</pre></div>
</div>
<p>Hierbei wird immer eine Diagonalmatrix erzeugt. Will man dies nicht, so kann
man <code class="docutils literal"><span class="pre">eye</span></code> verwenden, das nicht nur nicht quadratische Arrays erzeugen kann,
sondern auch die Diagonale nach oben oder unten verschieben lässt.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [6]: </span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">Out[6]:</span>
<span class="go">array([[ 1.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.,  0.]])</span>
</pre></div>
</div>
<p>Zu beachten ist hier, dass die Form des Arrays nicht als Tupel vorgegeben wird,
da ohnehin nur zweidimensionale Arrays erzeugt werden können. Lässt man das
zweite Argument weg, so wird ein quadratisches Array erzeugt. Will man die
Diagonaleinträge verschieben, so gibt man dies mit Hilfe des Parameters <code class="docutils literal"><span class="pre">k</span></code> an:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [7]: </span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Out[7]:</span>
<span class="go">array([[ 0.,  1.,  0.,  0.],</span>
<span class="go">       [-1.,  0.,  1.,  0.],</span>
<span class="go">       [ 0., -1.,  0.,  1.],</span>
<span class="go">       [ 0.,  0., -1.,  0.]])</span>
</pre></div>
</div>
<p>Hat man, wie zu Beginn des vorigen Abschnitts beschrieben, eine Matrix in Form
einer Liste mit Unterlisten vorliegen, so kann man diese in ein Array umwandeln:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [8]: </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="go">Out[8]:</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<p>Dies geht zum Beispiel auch, wenn man statt Listen Tupel vorliegen hat.</p>
<p>Lassen sich die Arrayeinträge als Funktion der Indizes ausdrücken, so kann
man die <code class="docutils literal"><span class="pre">fromfunction</span></code>-Funktion verwenden, wie in dem folgenden Beispiel
zu sehen ist, das eine Multiplikationstabelle erzeugt.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [9]: </span><span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
<span class="go">Out[9]:</span>
<span class="go">array([[ 1,  2,  3,  4,  5,  6],</span>
<span class="go">       [ 2,  4,  6,  8, 10, 12],</span>
<span class="go">       [ 3,  6,  9, 12, 15, 18],</span>
<span class="go">       [ 4,  8, 12, 16, 20, 24],</span>
<span class="go">       [ 5, 10, 15, 20, 25, 30],</span>
<span class="go">       [ 6, 12, 18, 24, 30, 36]])</span>
</pre></div>
</div>
<p>Diese Funktion ist nicht auf zweidimensionale Arrays beschränkt.</p>
<p>Bei der Konstruktion von Arrays sind auch Funktionen interessant, die als
Verallgemeinerung der in Python eingebauten Funktion <code class="docutils literal"><span class="pre">range</span></code> angesehen werden
können. Ihr Nutzen ergibt sich vor allem aus der Tatsache, dass man gewissen
Funktionen, den universellen Funktionen oder ufuncs in NumPy, die wir später
noch besprechen werden, ganze Arrays als Argumente übergeben kann. Damit wird
eine besonders effiziente Auswertung dieser Funktionen möglich.</p>
<p>Eindimensionale Arrays lassen sich mit Hilfe von <code class="docutils literal"><span class="pre">arange</span></code>, <code class="docutils literal"><span class="pre">linspace</span></code> und
<code class="docutils literal"><span class="pre">logspace</span></code> erzeugen:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [10]: </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gr">Out[10]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">1.1</span><span class="p">,</span>  <span class="mf">1.2</span><span class="p">,</span>  <span class="mf">1.3</span><span class="p">,</span>  <span class="mf">1.4</span><span class="p">,</span>  <span class="mf">1.5</span><span class="p">,</span>  <span class="mf">1.6</span><span class="p">,</span>  <span class="mf">1.7</span><span class="p">,</span>  <span class="mf">1.8</span><span class="p">,</span>  <span class="mf">1.9</span><span class="p">])</span>

<span class="gp">In [11]: </span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="gr">Out[11]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">1.1</span><span class="p">,</span>  <span class="mf">1.2</span><span class="p">,</span>  <span class="mf">1.3</span><span class="p">,</span>  <span class="mf">1.4</span><span class="p">,</span>  <span class="mf">1.5</span><span class="p">,</span>  <span class="mf">1.6</span><span class="p">,</span>  <span class="mf">1.7</span><span class="p">,</span>  <span class="mf">1.8</span><span class="p">,</span>  <span class="mf">1.9</span><span class="p">,</span>  <span class="mf">2.</span> <span class="p">])</span>

<span class="gp">In [12]: </span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Out[12]:</span>
<span class="go">(array([ 1.        ,  1.33333333,  1.66666667,  2.        ]),</span>
<span class="go"> 0.3333333333333333)</span>

<span class="gp">In [13]: </span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">Out[13]:</span>
<span class="go">array([    1.        ,     3.98107171,    15.84893192,    63.09573445,</span>
<span class="go">         251.18864315,  1000.        ])</span>

<span class="gp">In [14]: </span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gr">Out[14]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">])</span>
</pre></div>
</div>
<p>Ähnlich wie bei <code class="docutils literal"><span class="pre">range</span></code> erzeugt <code class="docutils literal"><span class="pre">arange</span></code> aus der Angabe eines Start- und
eines Endwerts sowie einer Schrittweite eine Folge von Werten. Allerdings
können diese auch Gleitkommazahlen sein. Zudem wird statt einer Liste ein Array
erzeugt. Wie bei <code class="docutils literal"><span class="pre">range</span></code> ist der Endwert hierin nicht enthalten.</p>
<p>Häufig möchte man aber statt einer Schrittweite eine Anzahl von Punkten
vorgeben. Dafür ist <code class="docutils literal"><span class="pre">linspace</span></code> eine geeignete Funktion, sofern die
Schrittweite konstant sein soll. Bei Bedarf kann man sich neben dem Array auch
noch die Schrittweite ausgeben lassen. Benötigt man eine logarithmische Skala,
so verwendet man <code class="docutils literal"><span class="pre">logspace</span></code>, das den Exponenten linear zwischen einem Start-
und einem Endwert verändert. Die Basis ist standardmäßig 10, sie kann aber durch
Setzen des Parameters <code class="docutils literal"><span class="pre">base</span></code> an spezielle Erfordernisse angepasst werden.</p>
<p>Möchte man eine Funktion auf einem Gitter auswerten und benötigt man dazu
separate Arrays für die x- und y-Werte, so hilft <code class="docutils literal"><span class="pre">meshgrid</span></code> weiter.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [15]: </span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

<span class="gp">In [16]: </span><span class="n">xvals</span>
<span class="go">Out[16]:</span>
<span class="go">array([[-1,  0,  1],</span>
<span class="go">       [-1,  0,  1],</span>
<span class="go">       [-1,  0,  1]])</span>

<span class="gp">In [17]: </span><span class="n">yvals</span>
<span class="go">Out[17]:</span>
<span class="go">array([[2, 2, 2],</span>
<span class="go">       [3, 3, 3],</span>
<span class="go">       [4, 4, 4]])</span>
</pre></div>
</div>
<p>In diesem Zusammenhang sind auch die Funktionen <code class="docutils literal"><span class="pre">mgrid</span></code> und <code class="docutils literal"><span class="pre">ogrid</span></code> von
Interesse, die wir besprechen werden, wenn wir die Adressierung von Arrays
genauer angesehen haben.</p>
<p>Abschließend wollen wir noch kurz andeuten, wie man ein Array durch Einlesen
von Daten aus einer Datei erhalten kann. Die Datei heiße <code class="docutils literal"><span class="pre">x_von_t.dat</span></code>
und habe den folgenden Inhalt:</p>
<div class="highlight-python"><div class="highlight"><pre># Zeit  Ort
   0.0  0.0
   0.1  0.1
   0.2  0.4
   0.3  0.9
</pre></div>
</div>
<p>Hierbei zeigt das <code class="docutils literal"><span class="pre">#</span></code>-Zeichen in der ersten Zeile an, dass es sich um eine
Kommentarzeile handelt, die nicht in das Array übernommen werden soll. Unter
Verwendung von <code class="docutils literal"><span class="pre">loadtxt</span></code> kann man die Daten nun einlesen:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [18]: </span><span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s">&quot;x_von_t.dat&quot;</span><span class="p">)</span>
<span class="go">Out[18]:</span>
<span class="go">array([[ 0. ,  0. ],</span>
<span class="go">       [ 0.1,  0.1],</span>
<span class="go">       [ 0.2,  0.4],</span>
<span class="go">       [ 0.3,  0.9]])</span>
</pre></div>
</div>
<p>Bei der <code class="docutils literal"><span class="pre">loadtxt</span></code>-Funktion lassen sich zum Beispiel das Kommentarzeichen oder
die Trennzeichen zwischen Einträgen konfigurieren. Noch wesentlich flexibler
ist <code class="docutils literal"><span class="pre">genfromtxt</span></code>, das es unter anderem erlaubt, Spaltenüberschriften aus der
Datei zu entnehmen oder mit fehlenden Einträgen umzugehen. Für Details wird auf
die <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html">zugehörige Dokumentation</a>
verwiesen.</p>
</div>
<div class="section" id="adressierung-von-numpy-arrays">
<h2>Adressierung von NumPy-Arrays<a class="headerlink" href="#adressierung-von-numpy-arrays" title="Link zu dieser Überschrift">¶</a></h2>
<p>Die Adressierungsmöglichkeiten für NumPy-Arrays basieren auf der so genannten
<em>slice</em>-Syntax, die wir von Python-Listen her kennen und uns hier noch einmal
kurz in Erinnerung rufen wollen. Einen Ausschnitt aus einer Liste, ein <em>slice</em>,
erhält man durch die Notation <code class="docutils literal"><span class="pre">[start:stop:step]</span></code>. Hierbei werden ausgehend
von dem Element mit dem Index <code class="docutils literal"><span class="pre">start</span></code>  die Elemente bis vor das Element mit dem
Index <code class="docutils literal"><span class="pre">stop</span></code> mit einer Schrittweite <code class="docutils literal"><span class="pre">step</span></code> ausgewählt. Wird die Schrittweite
nicht angegeben, so nimmt <code class="docutils literal"><span class="pre">step</span></code> den Defaultwert <code class="docutils literal"><span class="pre">1</span></code> an. Negative Schrittweiten
führen in der Liste von hinten nach vorne. Fehlen <code class="docutils literal"><span class="pre">start</span></code> und/oder
<code class="docutils literal"><span class="pre">stop</span></code> so beginnen die ausgewählten Elemente mit dem ersten Element bzw. enden
mit dem letzten Element. Negative Indexwerte werden vom Ende der Liste her genommen.
Das letzte Element kann also mit dem Index <code class="docutils literal"><span class="pre">-1</span></code>, das vorletzten Element mit
dem Index <code class="docutils literal"><span class="pre">-2</span></code> usw. angesprochen werden. Diese Indizierung funktioniert so auch
für NumPy-Arrays wie die folgenden Beispiele zeigen.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [19]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="gp">In [20]: </span><span class="n">a</span>
<span class="gr">Out[20]: </span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>

<span class="gp">In [21]: </span><span class="n">a</span><span class="p">[:]</span>
<span class="gr">Out[21]: </span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>

<span class="gp">In [22]: </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gr">Out[22]: </span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>

<span class="gp">In [23]: </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="gr">Out[23]: </span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

<span class="gp">In [24]: </span><span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="gr">Out[24]: </span><span class="n">array</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>

<span class="gp">In [25]: </span><span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gr">Out[25]: </span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Für mehrdimensionale Arrays wird die Notation direkt verallgemeinert. Im Gegensatz
zu der im Abschnitt <a class="reference internal" href="#pythonlisten"><span>Python-Listen und NumPy-Arrays</span></a> beschriebenen Notation für Listen von Listen
werden hier die diversen Indexangaben durch Kommas getrennt zusammengefasst. Einige
Beispiele für zweidimensionale Arrays sollen das illustrieren.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [26]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>

<span class="gp">In [27]: </span><span class="n">a</span>
<span class="go">Out[27]:</span>
<span class="go">array([[ 0,  1,  2,  3,  4,  5],</span>
<span class="go">       [ 6,  7,  8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15, 16, 17],</span>
<span class="go">       [18, 19, 20, 21, 22, 23],</span>
<span class="go">       [24, 25, 26, 27, 28, 29],</span>
<span class="go">       [30, 31, 32, 33, 34, 35]])</span>

<span class="gp">In [28]: </span><span class="n">a</span><span class="p">[:,</span> <span class="p">:]</span>
<span class="go">Out[28]:</span>
<span class="go">array([[ 0,  1,  2,  3,  4,  5],</span>
<span class="go">       [ 6,  7,  8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15, 16, 17],</span>
<span class="go">       [18, 19, 20, 21, 22, 23],</span>
<span class="go">       [24, 25, 26, 27, 28, 29],</span>
<span class="go">       [30, 31, 32, 33, 34, 35]])</span>

<span class="gp">In [29]: </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">Out[29]:</span>
<span class="go">array([[14, 15],</span>
<span class="go">       [20, 21]])</span>

<span class="gp">In [30]: </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">Out[30]:</span>
<span class="go">array([[15, 16],</span>
<span class="go">       [21, 22]])</span>

<span class="gp">In [31]: </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">Out[31]:</span>
<span class="go">array([[ 0,  2,  4],</span>
<span class="go">       [12, 14, 16],</span>
<span class="go">       [24, 26, 28]])</span>

<span class="gp">In [32]: </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">Out[32]:</span>
<span class="go">array([[12, 14, 16],</span>
<span class="go">       [24, 26, 28]])</span>

<span class="gp">In [33]: </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">Out[33]:</span>
<span class="go">array([[12, 13, 14, 15, 16, 17],</span>
<span class="go">       [18, 19, 20, 21, 22, 23]])</span>
</pre></div>
</div>
<p>Wie das letzte Beispiel zeigt, ergänzt NumPy bei fehlenden Indexangaben jeweils
einen Doppelpunkt, so dass alle Elemente ausgewählt werden, die mit den explizit
gemachten Indexangaben konsistent sind.</p>
<p>Will man eine Spalte (oder auch eine Zeile) in einer zweidimensionalen Array auswählen,
so hat man zwei verschiedene Möglichkeiten:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [34]: </span><span class="n">a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Out[34]:</span>
<span class="go">array([[ 0],</span>
<span class="go">       [ 6],</span>
<span class="go">       [12],</span>
<span class="go">       [18],</span>
<span class="go">       [24],</span>
<span class="go">       [30]])</span>

<span class="gp">In [35]: </span><span class="n">a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gr">Out[35]: </span><span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">30</span><span class="p">])</span>
</pre></div>
</div>
<p>Im ersten Fall sorgt die für beide Dimensionen vorhandene Indexnotation dafür,
dass ein zweidimensionales Array erzeugt wird, das die Elemente der ersten
Spalte enthält. Im zweiten Fall wird für die zweite Dimension ein fester Index
angegeben, so dass nun ein eindimensionales Array erzeugt wird, die wiederum
aus den Elementen der ersten Spalte besteht.</p>
<p>In einigen NumPy-Methoden gibt es einen Parameter <code class="docutils literal"><span class="pre">axis</span></code>, der die Richtung
in dem Array angibt, in der die Methode ausgeführt werden soll. Die Achsennummer
ergibt sich aus der Position der zugehörigen Indexangabe. Wie man aus den obigen
Beispielen entnehmen kann, verläuft die Achse 0 von oben nach unten, während die
Achse 1 von links nach rechts verläuft. Das Aufsummieren von Elementen unserer
Beispielmatrix erfolgt dann mit Hilfe der <code class="docutils literal"><span class="pre">sum</span></code>-Methode entweder von oben nach
unten, von links nach rechts oder über alle Elemente.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [36]: </span><span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">Out[36]: </span><span class="n">array</span><span class="p">([</span> <span class="mi">90</span><span class="p">,</span>  <span class="mi">96</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span> <span class="mi">108</span><span class="p">,</span> <span class="mi">114</span><span class="p">,</span> <span class="mi">120</span><span class="p">])</span>

<span class="gp">In [37]: </span><span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gr">Out[37]: </span><span class="n">array</span><span class="p">([</span> <span class="mi">15</span><span class="p">,</span>  <span class="mi">51</span><span class="p">,</span>  <span class="mi">87</span><span class="p">,</span> <span class="mi">123</span><span class="p">,</span> <span class="mi">159</span><span class="p">,</span> <span class="mi">195</span><span class="p">])</span>

<span class="gp">In [38]: </span><span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gr">Out[38]: </span><span class="mi">630</span>
</pre></div>
</div>
<p>Zur Verdeutlichung betrachten wir noch ein dreidimensionales Array.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [39]: </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">27</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="gp">In [40]: </span><span class="n">b</span>
<span class="go">Out[40]:</span>
<span class="go">array([[[ 0,  1,  2],</span>
<span class="go">        [ 3,  4,  5],</span>
<span class="go">        [ 6,  7,  8]],</span>

<span class="go">       [[ 9, 10, 11],</span>
<span class="go">        [12, 13, 14],</span>
<span class="go">        [15, 16, 17]],</span>

<span class="go">       [[18, 19, 20],</span>
<span class="go">        [21, 22, 23],</span>
<span class="go">        [24, 25, 26]]])</span>

<span class="gp">In [41]: </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Out[41]:</span>
<span class="go">array([[[0, 1, 2],</span>
<span class="go">        [3, 4, 5],</span>
<span class="go">        [6, 7, 8]]])</span>

<span class="gp">In [42]: </span><span class="n">b</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Out[42]:</span>
<span class="go">array([[[ 0,  1,  2]],</span>

<span class="go">       [[ 9, 10, 11]],</span>

<span class="go">       [[18, 19, 20]]])</span>

<span class="gp">In [43]: </span><span class="n">b</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Out[43]:</span>
<span class="go">array([[[ 0],</span>
<span class="go">        [ 3],</span>
<span class="go">        [ 6]],</span>

<span class="go">       [[ 9],</span>
<span class="go">        [12],</span>
<span class="go">        [15]],</span>

<span class="go">       [[18],</span>
<span class="go">        [21],</span>
<span class="go">        [24]]])</span>

<span class="gp">In [44]: </span><span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Out[44]:</span>
<span class="go">array([[[ 0],</span>
<span class="go">        [ 3],</span>
<span class="go">        [ 6]],</span>

<span class="go">       [[ 9],</span>
<span class="go">        [12],</span>
<span class="go">        [15]],</span>

<span class="go">       [[18],</span>
<span class="go">        [21],</span>
<span class="go">        [24]]])</span>
</pre></div>
</div>
<p>Man sieht hier deutlich, wie je nach Wahl der Achse ein entsprechender Schnitt
durch das als Würfel vorstellbare Array gemacht wird. Das letzte Beispiel zeigt
die Benutzung des Auslassungszeichens <code class="docutils literal"><span class="pre">...</span></code> (im Englischen <em>ellipsis</em> genannt).
Es steht für die Anzahl von Doppelpunkten, die nötig sind, um die Indizes für
alle Dimensionen zu spezifizieren. Allerdings funktioniert dies nur beim ersten
Auftreten des Auslassungszeichens, da sonst nicht klar ist, wie viele Indexspezifikation
für jedes Auslassungszeichen einzusetzen sind. Alle weiteren Auslassungszeichen
werden daher durch einen einzelnen Doppelpunkt ersetzt.</p>
<p>Weiter oben hatten wir in einem Beispiel gesehen, dass die Angabe eines festen
Index die Dimension des Arrays effektiv um Eins vermindert. Umgekehrt ist es
auch möglich, eine zusätzliche Dimension der Länge Eins hinzuzufügen. Hierzu
dient <code class="docutils literal"><span class="pre">newaxis</span></code>, das an der gewünschten Stelle als Index eingesetzt werden kann.
Die folgenden Beispiele zeigen, wie aus einem eindimensionalen Array so zwei
verschiedene zweidimensionale Arrays konstruiert werden können.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [45]: </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="gp">In [46]: </span><span class="n">c</span>
<span class="gr">Out[46]: </span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

<span class="gp">In [47]: </span><span class="n">c</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="go">Out[47]:</span>
<span class="go">array([[0],</span>
<span class="go">       [1],</span>
<span class="go">       [2],</span>
<span class="go">       [3],</span>
<span class="go">       [4]])</span>

<span class="gp">In [48]: </span><span class="n">c</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
<span class="gr">Out[48]: </span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</pre></div>
</div>
<p>Eine Anwendung hiervon werden wir weiter unten in diesem Kapitel kennenlernen, wenn wir
uns mit der Erweiterung von Arrays auf eine Zielgröße, dem so genannten <em>broadcasting</em>
beschäftigen.</p>
<p>Zunächst wollen wir aber noch eine weitere Indizierungsmethode, das so genannte
<em>fancy indexing</em>, ansprechen. Obwohl es sich hierbei um ein sehr flexibles und
mächtiges Verfahren handelt, sollte man bedenken, dass hier immer eine Kopie des
Arrays erzeugt wird und nicht einfach nur eine neue Sicht auf bereits vorhandene
Daten. Da Letzteres effizienter ist, sollte man <em>fancy indexing</em> in erster Linie in
Situationen einsetzen, in denen das normale Indizieren nicht ausreicht.</p>
<p>Beim <em>fancy indexing</em> werden die möglichen Indizes als Arrays oder zum Beispiel als
Liste, nicht jedoch als Tupel, angegeben. Die Elemente können dabei <em>Integer</em> oder
<em>Boolean</em> sein. Beginnen wir mit dem ersten Fall, wobei wir zunächst von einem
eindimensionalen Array ausgehen.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [49]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>

<span class="gp">In [50]: </span><span class="n">a</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
<span class="gr">Out[50]: </span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>

<span class="gp">In [51]: </span><span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])]</span>
<span class="go">Out[51]:</span>
<span class="go">array([[10, 12],</span>
<span class="go">       [11, 14]])</span>
</pre></div>
</div>
<p>Im ersten Fall werden einzelne Arrayelemente durch Angabe der Indizes ausgewählt,
wobei auch Wiederholungen sowie eine nichtmonotone Wahl von Indizes möglich sind.
Sind die Indizes als Array angegeben, so wird ein Array der gleichen Form erzeugt.</p>
<p>Bei der Auswahl von Elementen aus einem mehrdimensionalen Arrays muss man gegebenenfalls
weitere Indexlisten oder -arrays angeben.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [52]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="gp">In [53]: </span><span class="n">a</span>
<span class="go">Out[53]:</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>

<span class="gp">In [54]: </span><span class="n">a</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="go">Out[54]:</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11]])</span>

<span class="gp">In [55]: </span><span class="n">a</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="gr">Out[55]: </span><span class="n">array</span><span class="p">([</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>
</pre></div>
</div>
<p>Interessant ist die Verwendung von Indexarrays mit Elementen vom Typ <em>Boolean</em>.
Ein solches Indexarray lässt sich zum Beispiel mit Hilfe einer logischen Operation
auf einem Array erzeugen, wie das folgende Beispiel demonstriert. Eine Reihe
von Zufallszahlen soll dabei bei einem Schwellenwert nach unten abgeschnitten
werden.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">threshold</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="k">print</span> <span class="n">a</span>
<span class="k">print</span> <span class="s">&quot;-&quot;</span><span class="o">*</span><span class="mi">30</span>
<span class="n">indexarray</span> <span class="o">=</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">threshold</span>
<span class="k">print</span> <span class="n">indexarray</span>
<span class="k">print</span> <span class="s">&quot;-&quot;</span><span class="o">*</span><span class="mi">30</span>
<span class="n">a</span><span class="p">[</span><span class="n">indexarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">threshold</span>
<span class="k">print</span> <span class="n">a</span>
</pre></div>
</td></tr></table></div>
<p>Damit ergibt sich beispielsweise die folgende Ausgabe:</p>
<div class="highlight-python"><div class="highlight"><pre>[ 0.11859559  0.49034494  0.08552061  0.69204077  0.18406457  0.06819091
  0.36785529  0.16873423  0.44615435  0.57774615  0.54327126  0.57381642]
------------------------------
[ True False  True False  True  True False  True False False False False]
------------------------------
[ 0.3         0.49034494  0.3         0.69204077  0.3         0.3
  0.36785529  0.3         0.44615435  0.57774615  0.54327126  0.57381642]
</pre></div>
</div>
<p>In Zeile 5 wird ein Array <code class="docutils literal"><span class="pre">indexarray</span></code> erzeugt, das an den Stellen, an denen die Elemente
des Arrays <code class="docutils literal"><span class="pre">a</span></code> kleiner als der Schwellwert sind, den Wahrheitswert <code class="docutils literal"><span class="pre">True</span></code>
besitzt. In Zeile 8 werden die auf diese Weise indizierten Elemente dann auf
den Schwellwert gesetzt.  Es sei noch angemerkt, dass sich diese Funktionalität
auch direkt mit der <code class="docutils literal"><span class="pre">clip</span></code>-Funktion erreichen lässt.</p>
<p>Im vorigen Beispiel haben wir in der Vergleichsoperation in Zeile 5 ein
Array und ein Skalar miteinander verglichen. Wie kann dies funktionieren? Den
Vergleich zweier Arrays derselben Form kann man sinnvoll elementweise definieren.
Soll ein Array mit einem Skalar verglichen werden, so wird der Skalar von NumPy
zunächst mit gleichen Elementen so erweitert, das ein Array mit der benötigten
Form entsteht. Dieser als <em>broadcasting</em> bezeichnete Prozess kommt beispielsweise
auch bei arithmetischen Operationen zum Einsatz. Die beiden folgenden Anweisungen
sind daher äquivalent:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [56]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="gp">In [57]: </span><span class="n">a</span><span class="o">*</span><span class="mi">3</span>
<span class="gr">Out[57]: </span><span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>

<span class="gp">In [58]: </span><span class="n">a</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gr">Out[58]: </span><span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
<p><em>Broadcasting</em> ist genau dann möglich, wenn beim Vergleich der Achsen der
beiden beteiligten Arrays von der letzten Achse beginnend die Länge der Achsen
jeweils gleich ist oder eine Achse die Länge Eins besitzt. Eine Achse der Länge
Eins wird durch Wiederholen der Elemente im erforderlichen Umfang verlängert.
Entsprechendes geschieht beim Hinzufügen von Achsen von vorne, um die
Dimensionen der Arrays identisch zu machen. Wir illustrieren dies an einem
Beispiel.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [59]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="gp">In [60]: </span><span class="n">a</span>
<span class="go">Out[60]:</span>
<span class="go">array([[ 0,  1,  2,  3,  4],</span>
<span class="go">       [ 5,  6,  7,  8,  9],</span>
<span class="go">       [10, 11, 12, 13, 14],</span>
<span class="go">       [15, 16, 17, 18, 19]])</span>

<span class="gp">In [61]: </span><span class="n">a</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">Out[61]:</span>
<span class="go">array([[ 0,  1,  4,  9, 16],</span>
<span class="go">       [ 0,  6, 14, 24, 36],</span>
<span class="go">       [ 0, 11, 24, 39, 56],</span>
<span class="go">       [ 0, 16, 34, 54, 76]])</span>

<span class="gp">In [62]: </span><span class="n">a</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">---------------------------------------------------------------------------</span>
<span class="go">ValueError                                Traceback (most recent call last)</span>

<span class="go">&lt;ipython console&gt; in &lt;module&gt;()</span>

<span class="go">ValueError: operands could not be broadcast together with shapes (4,5) (4,)</span>
</pre></div>
</div>
<p>Das Array <code class="docutils literal"><span class="pre">a</span></code> hat die Form <code class="docutils literal"><span class="pre">(4,</span> <span class="pre">5)</span></code> und kann daher mit einem Array der Form
<code class="docutils literal"><span class="pre">(5,)</span></code> multipliziert werden. Von hinten gerechnet stimmen die Achsenlängen überein,
so dass vorne eine Achse der Länge 4 angefügt werden kann. Ein entsprechend erweitertes
Array hätte folgendes Aussehen:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [63]: </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">Out[63]:</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [0, 1, 2, 3, 4],</span>
<span class="go">       [0, 1, 2, 3, 4],</span>
<span class="go">       [0, 1, 2, 3, 4]])</span>
</pre></div>
</div>
<p>Damit ist ein elementweises Multiplizieren möglich. Im zweiten Beispiel oben haben wir
es neben unserem Array <code class="docutils literal"><span class="pre">a</span></code> der Form <code class="docutils literal"><span class="pre">(4,</span> <span class="pre">5)</span></code> mit einem Array der Form <code class="docutils literal"><span class="pre">(4,)</span></code> zu tun.
In diesem Fall ist kein <em>broadcasting</em> möglich, und es kommt zu einer <code class="docutils literal"><span class="pre">ValueError</span></code>-Ausnahme.
Anders stellt sich die Situation dar, wenn die Achsenlänge 4 zur Achse 0 gehört und die Achse 1
die Länge 1 besitzt. Dies können wir mit Hilfe von <code class="docutils literal"><span class="pre">newaxis</span></code> erreichen:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [64]: </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

<span class="gp">In [65]: </span><span class="n">b</span>
<span class="go">Out[65]:</span>
<span class="go">array([[0],</span>
<span class="go">       [1],</span>
<span class="go">       [2],</span>
<span class="go">       [3]])</span>

<span class="gp">In [66]: </span><span class="n">b</span><span class="o">.</span><span class="n">shape</span>
<span class="gr">Out[66]: </span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="gp">In [67]: </span><span class="n">a</span><span class="o">*</span><span class="n">b</span>
<span class="go">Out[67]:</span>
<span class="go">array([[ 0,  0,  0,  0,  0],</span>
<span class="go">       [ 5,  6,  7,  8,  9],</span>
<span class="go">       [20, 22, 24, 26, 28],</span>
<span class="go">       [45, 48, 51, 54, 57]])</span>
</pre></div>
</div>
</div>
<div class="section" id="universelle-funktionen">
<h2>Universelle Funktionen<a class="headerlink" href="#universelle-funktionen" title="Link zu dieser Überschrift">¶</a></h2>
<p>Im vorigen Unterkapitel haben wir bereits begonnen, mathematische Operationen
mit Arrays zu betrachten. Was passiert, wenn wir versuchen, Funktionen von
Arrays auszuwerten? Für die folgenden Betrachtungen importieren wir zusätzlich
zum <code class="docutils literal"><span class="pre">numpy</span></code>-Paket, das in diesem Kapitel immer importiert sein sollte, noch
das <code class="docutils literal"><span class="pre">math</span></code>-Modul und versuchen dann, den Sinus eines Arrays auszuwerten.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">math</span>

<span class="gp">In [2]: </span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
<span class="go">---------------------------------------------------------------------------</span>
<span class="go">TypeError                                 Traceback (most recent call last)</span>

<span class="go">&lt;ipython console&gt; in &lt;module&gt;()</span>

<span class="go">TypeError: only length-1 arrays can be converted to Python scalars</span>
</pre></div>
</div>
<p>Dabei scheitern wir jedoch, da der Sinus aus dem <code class="docutils literal"><span class="pre">math</span></code>-Modul nur mit skalaren Größen
umgehen kann. Hätte unser Array nur ein Element enthalten, so wären wir noch erfolgreich
gewesen. Im Beispiel hatten wir jedoch mehr als ein Element, genauer gesagt elf Elemente,
und somit kommt es zu einer <code class="docutils literal"><span class="pre">TypeError</span></code>-Ausnahme.</p>
<p>Den Ausweg bietet in diesem Fall das <code class="docutils literal"><span class="pre">numpy</span></code>-Paket selbst, das eine eigene Sinusfunktion
zur Verfügung stellt, die in der Lage ist, auch mit Arrays umzugehen.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [3]: </span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
<span class="go">Out[3]:</span>
<span class="go">array([  0.00000000e+00,   3.09016994e-01,   5.87785252e-01,</span>
<span class="go">         8.09016994e-01,   9.51056516e-01,   1.00000000e+00,</span>
<span class="go">         9.51056516e-01,   8.09016994e-01,   5.87785252e-01,</span>
<span class="go">         3.09016994e-01,   1.22460635e-16])</span>

<span class="gp">In [4]: </span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="go">Out[4]:</span>
<span class="go">array([[  0.00000000e+00,   5.00000000e-01,   8.66025404e-01,</span>
<span class="go">          1.00000000e+00,   8.66025404e-01,   5.00000000e-01],</span>
<span class="go">       [  1.22460635e-16,  -5.00000000e-01,  -8.66025404e-01,</span>
<span class="go">         -1.00000000e+00,  -8.66025404e-01,  -5.00000000e-01]])</span>
</pre></div>
</div>
<p>Statt die Kreiszahl aus dem <code class="docutils literal"><span class="pre">math</span></code>-Modul zu nehmen, hätten wir sie genauso gut aus dem
<code class="docutils literal"><span class="pre">numpy</span></code>-Paket nehmen können.</p>
<p>Funktionen wie die gerade benutzte Sinusfunktion aus dem <code class="docutils literal"><span class="pre">numpy</span></code>-Paket, die
Arrays als Argumente akzeptieren, werden universelle Funktionen (<em>universal
function</em> oder kurz <em>ufunc</em>) genannt. Die im <code class="docutils literal"><span class="pre">numpy</span></code>-Paket verfügbaren
universellen Funktionen sind in der <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs">NumPy-Dokumentation zu ufuncs</a>
aufgeführt. Implementationen von speziellen Funktionen als universelle Funktion
sind im <code class="docutils literal"><span class="pre">scipy</span></code>-Paket zu finden. Viele Funktionen in <code class="docutils literal"><span class="pre">scipy.special</span></code>,
jedoch nicht alle,  sind als <em>ufuncs</em> implementiert.  Als nur eines von vielen
möglichen Beispielen wählen wir die Gammafunktion:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [5]: </span><span class="kn">import</span> <span class="nn">scipy.special</span>

<span class="gp">In [6]: </span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="go">Out[6]:</span>
<span class="go">array([  1.        ,   0.88622693,   1.        ,   1.32934039,</span>
<span class="go">         2.        ,   3.32335097,   6.        ,  11.6317284 ,  24.        ])</span>
</pre></div>
</div>
<p>Gelegentlich benötigt man eine Funktion von zwei Variablen auf einem Gitter.
Man könnte hierzu die <code class="docutils literal"><span class="pre">meshgrid</span></code>-Funktion heranziehen, die wir im Abschnitt
<a class="reference internal" href="#arrayerzeugung"><span>Erzeugung von NumPy-Arrays</span></a> erwähnt hatten.  Da man dort die einzelnen Gitterpunkte
explizit angegeben muss, ist es häufig bequemer, eine <code class="docutils literal"><span class="pre">mgrid</span></code>-Gitter zu
verwenden.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [7]: </span><span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">Out[7]:</span>
<span class="go">array([[[0, 0, 0],</span>
<span class="go">        [1, 1, 1],</span>
<span class="go">        [2, 2, 2]],</span>

<span class="go">       [[0, 1, 2],</span>
<span class="go">        [0, 1, 2],</span>
<span class="go">        [0, 1, 2]]])</span>

<span class="gp">In [8]: </span><span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">7j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">7j</span><span class="p">]</span>
<span class="go">Out[8]:</span>
<span class="go">array([[[ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ],</span>
<span class="go">        [ 0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5],</span>
<span class="go">        [ 1. ,  1. ,  1. ,  1. ,  1. ,  1. ,  1. ],</span>
<span class="go">        [ 1.5,  1.5,  1.5,  1.5,  1.5,  1.5,  1.5],</span>
<span class="go">        [ 2. ,  2. ,  2. ,  2. ,  2. ,  2. ,  2. ],</span>
<span class="go">        [ 2.5,  2.5,  2.5,  2.5,  2.5,  2.5,  2.5],</span>
<span class="go">        [ 3. ,  3. ,  3. ,  3. ,  3. ,  3. ,  3. ]],</span>

<span class="go">       [[ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ],</span>
<span class="go">        [ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ],</span>
<span class="go">        [ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ],</span>
<span class="go">        [ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ],</span>
<span class="go">        [ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ],</span>
<span class="go">        [ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ],</span>
<span class="go">        [ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ]]])</span>
</pre></div>
</div>
<p>Man beachte, dass im zweiten Fall das dritte Element in der <em>slice</em>-Syntax imaginär ist. Damit wird
angedeutet, dass nicht die Schrittweite gemeint ist, sondern die Anzahl der Werte im durch die
ersten beiden Zahlen spezifizierten Intervall. Unter Verwendung des <em>Broadcasting</em> genügt auch
ein <code class="docutils literal"><span class="pre">ogrid</span></code>-Gitter.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [9]: </span><span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">7j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">7j</span><span class="p">]</span>
<span class="go">Out[9]:</span>
<span class="go">[array([[ 0. ],</span>
<span class="go">       [ 0.5],</span>
<span class="go">       [ 1. ],</span>
<span class="go">       [ 1.5],</span>
<span class="go">       [ 2. ],</span>
<span class="go">       [ 2.5],</span>
<span class="go">       [ 3. ]]),</span>
<span class="go"> array([[ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ]])]</span>
</pre></div>
</div>
<p>Eine Anwendung bei der Berechnung von Kugelflächenfunktionen könnte folgendermaßen aussehen <a class="footnote-reference" href="#sph-harm" id="id2">[2]</a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.special</span>

<span class="n">thetas</span><span class="p">,</span> <span class="n">phis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span><span class="mi">5j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span><span class="mi">9j</span><span class="p">]</span>
<span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span>
<span class="n">resultat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">sph_harm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">phis</span><span class="p">,</span> <span class="n">thetas</span><span class="p">)</span>

<span class="k">print</span> <span class="n">resultat</span>
</pre></div>
</div>
<p>Wir verzichten darauf, das Ergebnis anzugeben, da es keine weiteren Einsichten
bringt, außer dass tatsächlich ein 5×9-Array erzeugt wird. Abschließend sei
noch angemerkt, dass der Aufruf von <code class="docutils literal"><span class="pre">sph_harm</span></code> nicht funktioniert, wenn man
<code class="docutils literal"><span class="pre">phis</span></code> und <code class="docutils literal"><span class="pre">thetas</span></code> folgendermaßen definiert:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">phis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<p>Diese Definition würde kein <em>Broadcasting</em> erlauben. Hätten beide Arrays die
gleiche Länge, würde die Kugelflächenfunktion zwar ausgewertet werden, aber man
würde kein zweidimensionales Array sondern nur ein eindimensionales Array
erhalten.</p>
<p>Es ist nicht nur praktisch, Funktionen von Arrays direkt berechnen zu können,
sondern es spart häufig auch Rechenzeit. Wir wollen dies an einem Beispiel
illustrieren.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [10]: </span><span class="n">nmax</span> <span class="o">=</span> <span class="mi">100000</span>

<span class="gp">In [11]: </span><span class="o">%%</span><span class="n">timeit</span>
<span class="gp">   ...:</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmax</span><span class="p">):</span>
<span class="gp">   ...:</span>     <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">nmax</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">   ...:</span>     <span class="n">y</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">   ...:</span>
<span class="go">10 loops, best of 3: 33.2 ms per loop</span>

<span class="gp">In [12]: </span><span class="o">%%</span><span class="n">timeit</span>
<span class="gp">   ...:</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">nmax</span><span class="p">)</span>
<span class="gp">   ...:</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">   ...:</span>
<span class="go">100 loops, best of 3: 2.96 ms per loop</span>

<span class="gp">In [13]: </span><span class="o">%%</span><span class="n">timeit</span>
<span class="gp">   ...:</span> <span class="n">prefactor</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="n">nmax</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">   ...:</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmax</span><span class="p">):</span>
<span class="gp">   ...:</span>     <span class="n">y</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">prefactor</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="gp">   ...:</span>
<span class="go">100 loops, best of 3: 16.5 ms per loop</span>
</pre></div>
</div>
<p>Die angegebenen Rechenzeiten sind natürlich von der Hardware abhängig, auf der
der Code ausgeführt wurde. Daher kommt es statt auf die Absolutwerte auf
Verhältnisse von Rechenzeiten zueinander an. Dabei zeigt sich, dass die im
ersten Codestück programmierte explizite <code class="docutils literal"><span class="pre">for</span></code>-Schleife etwa elfmal
langsamer ist als das zweite Codestück, das eine universelle Funktion
verwendet. Ein Anteil dieses Geschwindigkeitsvorteils ergibt sich daraus, dass
in der <code class="docutils literal"><span class="pre">for</span></code>-Schleife unnötige Rechenarbeit geleistet wird. Zieht man die
Berechnung des konstanten Faktors <code class="docutils literal"><span class="pre">prefactor</span></code> aus der Schleife heraus, so
wird die Rechenzeit immerhin etwas mehr als halbiert. Dennoch ist die
Verwendung der universellen Funktion deutlich schneller. Der
Geschwindigkeitsvorteil ergibt sich allerdings erst bei hinreichend großen
Arrays. Bei kleinen Arrays kann dagegen der mit der Verwaltung der Arrays
verbundene Aufwand überwiegen.</p>
<p>Abschließend sei noch angemerkt, dass es sich wegen der genannten Rechenzeitvorteile
lohnt, einen Blick in die Liste der von NumPy zur Verfügung gestellten
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/routines.math.html">mathematischen Funktionen</a>
zu werfen. Möchte man zum Beispiel die Summe der Elemente eines Arrays berechnen, so verwendet
man sinnvollerweise die <code class="docutils literal"><span class="pre">sum</span></code>-Funktion von NumPy.</p>
</div>
<div class="section" id="lineare-algebra">
<h2>Lineare Algebra<a class="headerlink" href="#lineare-algebra" title="Link zu dieser Überschrift">¶</a></h2>
<p>Physikalische Fragestellungen, die sich mit Hilfe von Vektoren und Matrizen formulieren lassen,
benötigen zur Lösung sehr häufig Methoden der linearen Algebra. NumPy leistet hierbei Unterstützung,
insbesondere mit dem <code class="docutils literal"><span class="pre">linalg</span></code>-Paket. Im Folgenden gehen wir auf einige Aspekte ein, ohne
Vollständigkeit anzustreben. Daher empfiehlt es sich, auch einen Blick in den
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/routines.linalg.html">entsprechenden Abschnitt der Dokumentation</a>
zu werfen. Zunächst importieren wir die Module, die wir für die Beispiele dieses Kapitels benötigen:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="gp">In [2]: </span><span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="kn">as</span> <span class="nn">LA</span>
</pre></div>
</div>
<p>Beim Arbeiten mit Matrizen und NumPy muss man immer bedenken, dass der Multiplikationsoperator <cite>*</cite>
nicht für eine Matrixmultiplikation steht. Vielmehr wird damit eine elementweise Multiplikation
ausgeführt:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [3]: </span><span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>

<span class="gp">In [4]: </span><span class="n">a1</span>
<span class="go">Out[4]:</span>
<span class="go">array([[ 1, -3],</span>
<span class="go">       [-2,  5]])</span>

<span class="gp">In [5]: </span><span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

<span class="gp">In [6]: </span><span class="n">a2</span>
<span class="go">Out[6]:</span>
<span class="go">array([[ 3, -6],</span>
<span class="go">       [ 2, -1]])</span>

<span class="gp">In [7]: </span><span class="n">a1</span><span class="o">*</span><span class="n">a2</span>
<span class="go">Out[7]:</span>
<span class="go">array([[ 3, 18],</span>
<span class="go">       [-4, -5]])</span>
</pre></div>
</div>
<p>Möchte man dagegen eine Matrixmultiplikation ausführen, so verwendet man das <code class="docutils literal"><span class="pre">dot</span></code>-Produkt:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [8]: </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
<span class="go">Out[8]:</span>
<span class="go">array([[-3, -3],</span>
<span class="go">       [ 4,  7]])</span>
</pre></div>
</div>
<p>Man könnte die Norm eines Vektors ebenfalls mit Hilfe des <code class="docutils literal"><span class="pre">dot</span></code>-Produkts bestimmen. Es bietet
sich jedoch an, hierzu direkt die <code class="docutils literal"><span class="pre">norm</span></code>-Funktion zu verwenden:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [9]: </span><span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

<span class="gp">In [10]: </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
<span class="gr">Out[10]: </span><span class="mf">3.7416573867739413</span>

<span class="gp">In [11]: </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gr">Out[11]: </span><span class="mf">14.0</span>
</pre></div>
</div>
<p>Als nächstes wollen wir ein inhomogenes lineares Gleichungssystem <code class="docutils literal"><span class="pre">ax</span> <span class="pre">=</span> <span class="pre">b</span></code> lösen, wobei die
Matrix <code class="docutils literal"><span class="pre">a</span></code> und der Vektor <code class="docutils literal"><span class="pre">b</span></code> gegeben sind und der Vektor <code class="docutils literal"><span class="pre">x</span></code> gesucht ist.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [12]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>

<span class="gp">In [13]: </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

<span class="gp">In [14]: </span><span class="n">LA</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gr">Out[14]: </span><span class="mf">0.99999999999999978</span>

<span class="gp">In [15]: </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">LA</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="gr">Out[15]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">])</span>
</pre></div>
</div>
<p>In Eingabe 14 haben wir zunächst überprüft, dass die Determinante der Matrix
<code class="docutils literal"><span class="pre">a</span></code> ungleich Null ist, so dass die invertierte Matrix existiert. Anschließend
haben wir den Vektor <code class="docutils literal"><span class="pre">b</span></code> von links mit der Inversen von <code class="docutils literal"><span class="pre">a</span></code> multipliziert,
um den Lösungsvektor zu erhalten. Allerdings erfolgt die numerische Lösung
eines inhomogenen linearen Gleichungssystems normalerweise nicht über eine
Inversion der Matrix, sondern mit Hilfe einer geeignet durchgeführten Gauß-Elimination.
NumPy stell hierzu die <code class="docutils literal"><span class="pre">solve</span></code>-Funktion zur Verfügung:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [16]: </span><span class="n">LA</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gr">Out[16]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">])</span>
</pre></div>
</div>
<p>Eine nicht invertierbare Matrix führt hier wie auch bei der Bestimmung der Determinante
auf eine <code class="docutils literal"><span class="pre">LinAlgError</span></code>-Ausnahme mit dem Hinweis auf eine singuläre Matrix.</p>
<p>Eine häufig vorkommende Problemstellung im Bereich der linearen Algebra sind
Eigenwertprobleme. Die <code class="docutils literal"><span class="pre">eig</span></code>-Funktion bestimmt rechtsseitige Eigenvektoren und
die zugehörigen Eigenwerte für beliebige quadratische Matrizen:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [17]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

<span class="gp">In [18]: </span><span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="gp">In [19]: </span><span class="n">evals</span>
<span class="gr">Out[19]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">3.60555128</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.60555128</span><span class="p">])</span>

<span class="gp">In [20]: </span><span class="n">evecs</span>
<span class="go">Out[20]:</span>
<span class="go">array([[ 0.75499722, -0.54580557],</span>
<span class="go">       [ 0.65572799,  0.83791185]])</span>

<span class="gp">In [21]: </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">evecs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
<span class="go">    print(np.dot(a, evecs[:, n]), evals[n]*evecs[:, n])</span>
<span class="go">Out[21]:</span>
<span class="go">[ 2.72218119  2.36426089] [ 2.72218119  2.36426089]</span>
<span class="go">[ 1.96792999 -3.02113415] [ 1.96792999 -3.02113415]</span>
</pre></div>
</div>
<p>Die Ausgabe am Ende zeigt, dass die Eigenvektoren und -werte in der Tat korrekt sind.
Benötigt man nur die Eigenwerte einer Matrix, so kann man durch Benutzung der
<code class="docutils literal"><span class="pre">eigvals</span></code>-Funktion Rechenzeit sparen.</p>
<p>Für die Lösung eines Eigenwertproblems von symmetrischen oder hermiteschen <a class="footnote-reference" href="#hermitesch" id="id3">[3]</a>
Matrizen gibt es die Funktionen <code class="docutils literal"><span class="pre">eigh</span></code> und <code class="docutils literal"><span class="pre">eigvalsh</span></code>, bei denen es genügt,
nur die obere oder die untere Hälfte der Matrix zu spezifizieren. Viel
wichtiger ist jedoch, dass diese Funktionen einen erheblichen Zeitvorteil
bieten können:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [22]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">250000</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>

<span class="gp">In [23]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">T</span>

<span class="gp">In [24]: </span><span class="o">%</span><span class="n">timeit</span> <span class="n">LA</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1 loops, best of 3: 736 ms per loop</span>

<span class="gp">In [25]: </span><span class="o">%</span><span class="n">timeit</span> <span class="n">LA</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">10 loops, best of 3: 208 ms per loop</span>
</pre></div>
</div>
<p>Hier wird in Eingabe 23 durch Addition der Transponierten eine symmetrische
Matrix erzeugt, so dass die beiden Funktionen <code class="docutils literal"><span class="pre">eig</span></code> und <code class="docutils literal"><span class="pre">eigh</span></code> mit der
gleichen Matrix arbeiten. Die Funktion <code class="docutils literal"><span class="pre">eigh</span></code> ist in diesem Beispiel immerhin
um mehr als einen Faktor 3 schneller.</p>
<table class="docutils footnote" frame="void" id="array" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Wir verwenden im Folgenden das englische Wort <em>Array</em>, um damit den <code class="docutils literal"><span class="pre">ndarray</span></code>-Datentyp
aus NumPy zu bezeichnen. Ein Grund dafür, nicht von Matrizen zu sprechen, besteht darin,
dass sich Arrays nicht notwendigerweise wie Matrizen verhalten. So entspricht das Produkt
von zwei Arrays im Allgemeinen nicht dem Matrixprodukt.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="sph-harm" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Im <code class="docutils literal"><span class="pre">scipy</span></code>-Modul sind die Winkel im Vergleich zur üblichen Konvention gerade vertauscht
benannt (siehe auch die <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.special.sph_harm.html#scipy.special.sph_harm">Dokumentation zur Funktion sph_harm</a>).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="hermitesch" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Eine hermitesche Matrix geht beim Transponieren in die konjugiert komplexe Matrix über:
<span class="math">\(a_{ij}=a_{ji}^*\)</span>.</td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="advancedpython.html">Fortgeschrittene Aspekte von Python</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Inhalt</a>
        &#160;&#160;::&#160;&#160;
        <a href="graphics.html">Erstellung von Grafiken mit matplotlib</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2012-2016, Gert-Ludwig Ingold.
      Mit <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.3 erstellt.
    </div>
  </body>
</html>